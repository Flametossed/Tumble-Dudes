<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tumble Dudes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <!-- PeerJS for P2P Networking -->
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #222; }
        
        /* Lobby UI Styles */
        #lobby-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #6a0dad, #222);
            display: flex;
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; color: white;
        }

        .panel {
            background: rgba(0,0,0,0.85); 
            padding: 25px; 
            border-radius: 20px;
            border: 2px solid #ff00ff; 
            text-align: center; 
            width: 95%; 
            max-width: 700px; /* Wider panel for side-by-side layout */
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            box-sizing: border-box;
            max-height: 98vh;
            overflow-y: auto;
        }

        input[type="text"] {
            width: 100%; padding: 12px; margin: 0; background: #333;
            border: 1px solid #555; color: white; border-radius: 8px; box-sizing: border-box;
            text-transform: uppercase; text-align: center; letter-spacing: 2px;
        }

        /* Compact Character Creator Styles */
        #character-creator {
            width: 100%;
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: row; /* Horizontal layout */
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }
        
        .cc-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1;
        }

        .cc-column-center {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #char-preview-container {
            width: 160px;
            height: 160px;
            background: rgba(0,0,0,0.3);
            border-radius: 50%;
            overflow: hidden;
            border: 3px solid rgba(255,255,255,0.1);
            position: relative;
            cursor: grab;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }

        #char-preview-container:active {
            cursor: grabbing;
        }
        
        #preview-canvas-target { width: 100%; height: 100%; }

        .creator-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0,0,0,0.3);
            padding: 8px 12px;
            border-radius: 6px;
        }
        
        .creator-row label {
            font-size: 0.75em;
            color: #aaa;
            text-transform: uppercase;
            font-weight: bold;
            text-align: left;
        }
        
        .selector-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .arrow-btn {
            background: rgba(255,255,255,0.1);
            border: none; color: white; width: 20px; height: 20px;
            border-radius: 4px; cursor: pointer; font-size: 0.7em;
            display: flex; align-items: center; justify-content: center;
            transition: background 0.2s;
        }
        .arrow-btn:hover { background: rgba(255,255,255,0.3); }

        .color-display {
            width: 30px; height: 18px; border-radius: 3px;
            border: 1px solid rgba(255,255,255,0.3);
            font-size: 0.7em; line-height: 18px; color: #fff; text-shadow: 1px 1px 1px #000;
        }

        /* Action Buttons */
        .action-row {
            display: flex;
            width: 100%;
            gap: 20px;
            margin-top: 10px;
            align-items: flex-start;
        }

        .action-col {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .separator-vert {
            width: 1px;
            background: #444;
            align-self: stretch;
        }

        button.btn-primary {
            width: 100%; padding: 12px; background: #ff00ff; color: white;
            border: none; border-radius: 8px; font-weight: bold; cursor: pointer;
            transition: 0.2s; font-size: 1em;
        }
        button.btn-primary:hover { background: #d400d4; transform: scale(1.02); }
        button.btn-primary:disabled { background: #555; cursor: not-allowed; transform: none; }

        button.btn-secondary {
            background: rgba(255, 255, 255, 0.1); 
            border: 1px solid #555; 
            color: #ddd;
            padding: 10px 16px; /* Slightly bigger padding for better touch */
            margin-top: 15px; /* More spacing from top elements */
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }
        button.btn-secondary:hover { border-color: white; color: white; background: rgba(255,255,255,0.2); }

        .join-group {
            display: flex;
            gap: 5px;
        }
        .join-group input {
            flex: 1;
            margin: 0;
            font-size: 0.9em;
            padding: 10px;
        }
        .join-group button {
            width: auto;
            padding: 0 20px;
            margin: 0;
        }

        #player-list {
            list-style: none; padding: 0; margin: 20px 0; text-align: left;
            width: 100%; 
            max-height: 150px; overflow-y: auto;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }
        #player-list li {
            padding: 10px; border-bottom: 1px solid #444; font-size: 1.1em;
            display: flex; align-items: center; gap: 10px;
        }
        
        .player-icon {
            width: 20px; height: 20px; border-radius: 4px;
            display: inline-block; border: 2px solid white;
            position: relative;
        }

        #code-display {
            font-size: 2.5em; 
            font-family: monospace; color: #00ffff;
            margin: 10px 0; letter-spacing: 5px;
            font-weight: bold;
        }

        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 200; color: #ff00ff;
            display: none; align-items: center; justify-content: center;
            font-size: 1.5em; flex-direction: column; gap: 20px;
        }

        /* Game UI */
        #ui {
            position: absolute; top: 20px; left: 20px; color: white; pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8); z-index: 10;
            display: none; 
            flex-direction: column; gap: 10px;
        }

        #speed-meter {
            width: 200px; height: 20px; background: rgba(0,0,0,0.5);
            border: 2px solid white; border-radius: 10px; overflow: hidden;
            margin-top: 5px;
        }
        #speed-bar {
            width: 0%; height: 100%; background: linear-gradient(90deg, #ffff00, #ff0000);
            transition: width 0.1s;
        }

        #commentary-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            border-left: 4px solid #ff00ff;
            max-width: 400px;
            font-style: italic;
            font-size: 1.1rem;
            color: #fff;
            margin-top: 10px;
            transition: opacity 0.5s;
            opacity: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Ping indicator */
        #ping-indicator {
            position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.6);
            padding: 8px 12px; border-radius: 6px; color: white; font-size: 0.9em;
            display: none; align-items: center; gap: 8px;
        }
        .ping-dot { width: 8px; height: 8px; border-radius: 50%; animation: pulse 2s infinite; }
        .ping-good { background: #44cc44; } .ping-medium { background: #ffaa00; } .ping-bad { background: #ff4444; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        
        /* Notification */
        #notification-area {
            position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
            z-index: 150; display: flex; flex-direction: column; gap: 10px; pointer-events: none;
        }
        .notification {
            background: rgba(255, 68, 68, 0.9); color: white; padding: 12px 20px;
            border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideIn 0.3s, slideOut 0.3s 2.7s; min-width: 250px; text-align: center;
        }
        @keyframes slideIn { from { transform: translateY(-20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-20px); opacity: 0; } }
        
        /* Countdown overlay */
        #countdown-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7); z-index: 110;
            display: none; align-items: center; justify-content: center;
            color: white; font-size: 8em; font-weight: bold; text-shadow: 0 0 20px #ff00ff;
        }
        #countdown-overlay.go { color: #44cc44; text-shadow: 0 0 20px #44cc44; }
        
        #win-screen {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(30, 30, 30, 0.95); padding: 40px; border-radius: 20px;
            text-align: center; color: white; box-shadow: 0 0 50px rgba(0,0,0,0.5); z-index: 20;
            width: 400px; border: 2px solid #ff00ff;
        }
        #final-leaderboard {
            width: 100%; margin: 20px auto; background: rgba(0,0,0,0.3);
            border-radius: 10px; padding: 10px; max-height: 200px;
            overflow-y: auto; box-sizing: border-box;
        }
        .leaderboard-row {
            display: flex; justify-content: space-between; padding: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 1.1em;
        }
        .leaderboard-row:last-child { border-bottom: none; }
        #end-screen-controls { display: flex; justify-content: center; flex-wrap: wrap; gap: 10px; }
        #end-screen-controls button {
            background: #ff00ff; color: white; border: none; padding: 10px 20px;
            font-size: 1rem; border-radius: 10px; cursor: pointer; transition: transform 0.1s;
        }
        #end-screen-controls button:hover { background: #d400d4; transform: scale(1.05); }

        .mute-btn {
            position: absolute; bottom: 20px; left: 20px; z-index: 90;
            background: rgba(0,0,0,0.5); padding: 5px 10px; font-size: 0.8rem;
            pointer-events: auto !important; color: white; border: 1px solid white; border-radius: 4px;
        }
        
        #invite-btn {
            background: linear-gradient(135deg, #00ffff, #0088ff) !important;
            border: none !important; color: white !important;
            padding: 10px 20px !important; margin: 15px 0 !important;
            font-size: 1em !important; font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3); animation: glow 2s infinite;
        }
        #invite-btn:hover { transform: scale(1.05) !important; box-shadow: 0 6px 20px rgba(0, 255, 255, 0.5) !important; }
        @keyframes glow {
            0%, 100% { box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 4px 25px rgba(0, 255, 255, 0.6); }
        }
        #waiting-message { font-size: 1.1em; color: #ffaa00; margin: 15px 0; font-style: italic; }
        
        @media (max-width: 650px) {
            #character-creator { flex-direction: column; }
            .panel { width: 90%; }
            .action-row { flex-direction: column; gap: 15px; }
            .separator-vert { width: 100%; height: 1px; }
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div>Connecting to Cloud...</div>
        <div style="font-size: 0.5em; color: #888;">v8.6 Styles</div>
    </div>
    
    <div id="notification-area"></div>
    <div id="countdown-overlay"></div>

    <!-- Lobby UI -->
    <div id="lobby-ui">
        <h1 style="margin-bottom: 0; text-shadow: 0 0 10px #ff00ff;">TUMBLE DUDES</h1>
        
        <div id="auth-status" style="margin-bottom: 10px; color: #00ffff; font-size: 0.9em;">Ready to Connect</div>

        <!-- Main Menu -->
        <div id="main-menu" class="panel">
            <input type="text" id="username-input" placeholder="ENTER USERNAME" maxlength="12">
            
            <!-- Character Creation UI -->
            <div id="character-creator">
                <!-- Left Column: Body Options -->
                <div class="cc-column">
                    <div class="creator-row">
                        <label>Skin</label>
                        <div class="selector-control">
                            <button class="arrow-btn" onclick="cycleOption('skin', -1)">‚óÄ</button>
                            <div id="swatch-skin" class="color-display"></div>
                            <button class="arrow-btn" onclick="cycleOption('skin', 1)">‚ñ∂</button>
                        </div>
                    </div>
                    <div class="creator-row">
                        <label>Hair</label>
                        <div class="selector-control">
                            <button class="arrow-btn" onclick="cycleOption('hair', -1)">‚óÄ</button>
                            <div id="swatch-hair" class="color-display"></div>
                            <button class="arrow-btn" onclick="cycleOption('hair', 1)">‚ñ∂</button>
                        </div>
                    </div>
                    <!-- New Hair Style Selector -->
                    <div class="creator-row">
                        <label>Style</label>
                        <div class="selector-control">
                            <button class="arrow-btn" onclick="cycleOption('hairStyle', -1)">‚óÄ</button>
                            <div id="text-hairStyle" class="color-display" style="width: 50px; font-size: 0.6em;">STD</div>
                            <button class="arrow-btn" onclick="cycleOption('hairStyle', 1)">‚ñ∂</button>
                        </div>
                    </div>
                </div>

                <!-- Center Column: Preview -->
                <div class="cc-column-center">
                    <div id="char-preview-container">
                        <!-- ThreeJS Canvas will be injected here -->
                    </div>
                    <button class="btn-secondary" onclick="randomizeCharacter()">üé≤ Randomize</button>
                </div>

                <!-- Right Column: Clothing Options -->
                <div class="cc-column">
                    <div class="creator-row">
                        <label>Shirt</label>
                        <div class="selector-control">
                            <button class="arrow-btn" onclick="cycleOption('shirt', -1)">‚óÄ</button>
                            <div id="swatch-shirt" class="color-display"></div>
                            <button class="arrow-btn" onclick="cycleOption('shirt', 1)">‚ñ∂</button>
                        </div>
                    </div>
                    <div class="creator-row">
                        <label>Pants</label>
                        <div class="selector-control">
                            <button class="arrow-btn" onclick="cycleOption('pants', -1)">‚óÄ</button>
                            <div id="swatch-pants" class="color-display"></div>
                            <button class="arrow-btn" onclick="cycleOption('pants', 1)">‚ñ∂</button>
                        </div>
                    </div>
                </div>
            </div>

            <div style="border-top: 1px solid #444; width: 100%; margin: 5px 0;"></div>

            <!-- Action Controls -->
            <div class="action-row">
                <div class="action-col">
                    <div style="font-size:0.8em; color:#888; text-transform:uppercase; letter-spacing:1px;">Start New</div>
                    <button class="btn-primary" onclick="createLobby()">HOST GAME</button>
                </div>
                
                <div class="separator-vert"></div>
                
                <div class="action-col" style="flex: 1.5;">
                    <div style="font-size:0.8em; color:#888; text-transform:uppercase; letter-spacing:1px;">Join Existing</div>
                    <div class="join-group">
                        <input type="text" id="code-input" placeholder="HOST CODE" style="background: rgba(0,0,0,0.3);">
                        <button class="btn-primary" onclick="joinLobby()">JOIN</button>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 15px; font-size: 0.7em; color: #666;">
                v8.7
            </div>
        </div>

        <!-- Wait Room -->
        <div id="wait-room" class="panel" style="display: none;">
            <h3 style="margin: 0; color: #ff00ff;">LOBBY CODE</h3>
            <div id="code-display"><span id="lobby-code-display">??????</span></div>
            <button id="invite-btn" class="btn-secondary" onclick="copyInviteLink()">üîó SHARE INVITE LINK</button>
            <div id="waiting-message" style="display: none;">‚è≥ Waiting for other players to join...</div>
            <div id="player-count">1 / 6 Players</div>
            <ul id="player-list">
                <!-- Players go here -->
            </ul>
            <button id="ready-btn" class="btn-primary" onclick="toggleReady()">‚úì READY UP</button>
            <button id="start-btn" class="btn-primary" onclick="hostStartGame()" style="display: none;">START RACE</button>
            <p id="wait-text" style="font-size: 0.8em; color: #aaa; margin-top: 10px;">Waiting for host...</p>
            <button class="btn-secondary" onclick="backToMenu()">Cancel</button>
        </div>
    </div>

    <!-- Game UI -->
    <div id="ui">
        <div>
            <h1 style="margin:0;">TUMBLE DUDES</h1>
            <div id="rank">Rank: -- / --</div>
            <div id="speed-meter"><div id="speed-bar"></div></div>
        </div>
        <div id="commentary-box">
            <span id="commentary-wave">üîä</span>
            <span id="commentary-text">waiting for sportscaster...</span>
        </div>
    </div>
    
    <div id="ping-indicator">
        <div class="ping-dot ping-good"></div>
        <span id="ping-text">-- ms</span>
    </div>

    <button class="mute-btn" onclick="toggleMusic()">üéµ Toggle Music</button>

    <div id="win-screen">
        <h2 id="win-text" style="color: #44cc44; margin-top:0;">FINISHED!</h2>
        <div id="final-leaderboard">
            <!-- Leaderboard Items Injected JS -->
        </div>
        <div id="end-screen-controls">
            <!-- Buttons injected JS -->
        </div>
    </div>

    <script>
        // --- COLOR PALETTES & OPTIONS ---
        const PALETTES = {
            skin: ['#ffccaa', '#8d5524', '#c68642', '#e0ac69', '#f1c27d', '#ffdbac', '#5c3a21', '#9eff9e', '#9ecaff', '#ca9eff'],
            hair: ['#442200', '#000000', '#e6be8a', '#8d5524', '#ff0000', '#aaaaaa', '#ffffff', '#00ff00', '#0000ff', '#ff00ff'],
            shirt: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#00ffff', '#ff00ff', '#ffffff', '#000000', '#ff8800', '#8800ff'],
            pants: ['#0000ff', '#000000', '#555555', '#ffffff', '#654321', '#004400', '#440000', '#ffcc00', '#00ffff', '#ff00ff']
        };

        const HAIR_STYLES = ['Standard', 'Spiky', 'Mohawk', 'Bob', 'Bald'];

        let myCostume = {
            skin: 0, // Indices now
            hair: 0,
            shirt: 0,
            pants: 0,
            hairStyle: 0
        };

        // --- PREVIEW VARIABLES ---
        let previewScene, previewCamera, previewRenderer, previewMesh;
        let isPreviewInit = false;

        function initPreview() {
            if(isPreviewInit) return;
            const container = document.getElementById('char-preview-container');
            const w = container.clientWidth;
            const h = container.clientHeight;

            previewScene = new THREE.Scene();
            previewScene.background = new THREE.Color(0x333333); // Dark grey background for preview

            previewCamera = new THREE.PerspectiveCamera(50, w / h, 0.1, 100);
            previewCamera.position.set(0, 1.2, 3);
            previewCamera.lookAt(0, 1, 0);

            previewRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            previewRenderer.setSize(w, h);
            previewRenderer.setClearColor(0x000000, 0); // Transparent
            container.appendChild(previewRenderer.domElement);

            // Lighting for preview
            const amb = new THREE.AmbientLight(0xffffff, 0.6);
            previewScene.add(amb);
            const dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(2, 5, 5);
            previewScene.add(dir);

            updatePreviewCharacter();
            animatePreview();
            isPreviewInit = true;
            
            // Mouse/Touch Rotation Control
            let isDragging = false;
            let previousMouseX = 0;
            
            container.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMouseX = e.clientX;
            });
            
            window.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            window.addEventListener('mousemove', (e) => {
                if(isDragging && previewMesh) {
                    const deltaX = e.clientX - previousMouseX;
                    previewMesh.rotation.y += deltaX * 0.01;
                    previousMouseX = e.clientX;
                }
            });
            
            // Initial UI Update
            updateSwatch('skin');
            updateSwatch('hair');
            updateSwatch('shirt');
            updateSwatch('pants');
            updateSwatch('hairStyle');
        }

        function updatePreviewCharacter() {
            if(previewMesh) {
                previewScene.remove(previewMesh);
            }
            // Get hex codes
            const costumeData = {
                skin: PALETTES.skin[myCostume.skin],
                hair: PALETTES.hair[myCostume.hair],
                shirt: PALETTES.shirt[myCostume.shirt],
                pants: PALETTES.pants[myCostume.pants],
                hairStyle: myCostume.hairStyle
            };
            
            previewMesh = createHumanoid(costumeData, null); // No name for preview
            previewMesh.position.set(0, 0, 0);
            previewScene.add(previewMesh);
        }

        function animatePreview() {
            requestAnimationFrame(animatePreview);
            // No auto-rotation anymore
            if(previewRenderer) {
                previewRenderer.render(previewScene, previewCamera);
            }
        }

        function cycleOption(type, dir) {
            let len;
            if(type === 'hairStyle') len = HAIR_STYLES.length;
            else len = PALETTES[type].length;
            
            myCostume[type] = (myCostume[type] + dir + len) % len;
            updateSwatch(type);
            updatePreviewCharacter();
        }

        function updateSwatch(type) {
            if(type === 'hairStyle') {
                document.getElementById('text-hairStyle').innerText = HAIR_STYLES[myCostume.hairStyle].substring(0,4).toUpperCase();
                return;
            }
            const color = PALETTES[type][myCostume[type]];
            document.getElementById(`swatch-${type}`).style.backgroundColor = color;
        }

        function randomizeCharacter() {
            ['skin', 'hair', 'shirt', 'pants'].forEach(type => {
                myCostume[type] = Math.floor(Math.random() * PALETTES[type].length);
                updateSwatch(type);
            });
            myCostume.hairStyle = Math.floor(Math.random() * HAIR_STYLES.length);
            updateSwatch('hairStyle');
            updatePreviewCharacter();
        }

        // --- PEERJS CONFIG ---
        let peer = null;
        let connections = [];
        let hostConn = null;
        
        let myId = null;
        let myUsername = "Bean";
        let isHost = false;
        
        // Ping tracking
        let lastPingTime = 0;
        let currentPing = 0;
        let pingHistory = [];
        
        // Game State Sync
        window.opponentsData = {};
        let myState = { x: 0, y: 0, z: 0, rot: 0, finished: false };

        // --- GAME VARS ---
        let scene, camera, renderer, world;
        let player, playerBody, playerMesh; 
        let opponents = {};
        let obstacles = [];
        let gameActive = false;
        let finishLineX = 0;
        let lastCommentaryTime = 0;
        let playerMomentum = 20; 
        let hasFinished = false;
        
        // Checkpoint System
        let currentRespawnPos = { x: -5, y: 5, z: 0 };
        let checkpointPos = null;
        let checkpointActivated = false;
        window.checkpointFlagMat = null; 

        // Jump Vars
        let lastGroundedTime = 0;
        let backgroundObjects = [];
        let cameraAngle = 0;
        let isPointerLocked = false;
        let audioCtx;
        let isMuted = false;
        let noteIndex = 0;
        let isPlayingMusic = false;
        let currentTrack = null;
        const keys = { w: false, a: false, s: false, d: false, space: false };
        
        // Countdown state
        let isCountingDown = false;
        
        // Sound effect cooldowns
        let lastCollisionSound = 0;

        // Fixed timestep
        let lastPhysicsTime = performance.now();
        let accumulator = 0;
        const fixedTimeStep = 1/60; 
        const CAMERA_SMOOTHING_BASE = 0.9;
        let prevPlayerPos = { x: 0, y: 0, z: 0 };
        let prevObstacleStates = [];

        // --- COMMENTARY PHRASES ---
        const COMMENTARY = {
            start: ["And they're off!", "Let the tumbling begin!", "It's race time!", "Who will reach the finish first?"],
            checkpoint: ["Checkpoint secured!", "Halfway there!", "What a recovery!", "Crushing it so far!"],
            fall: ["Ouch! That's gonna hurt!", "Down they go!", "Back to the checkpoint!", "That looked painful!"],
            finish: ["They've crossed the line!", "What an incredible run!", "Ladies and gentlemen, we have a finisher!", "That's how it's done!"]
        };

        // --- SOUND EFFECTS ---
        function playSoundEffect(type) {
            if (!audioCtx || isMuted) return;
            switch(type) {
                case 'jump': playTone(400, 0.1, 'sine', 0.15); setTimeout(() => playTone(600, 0.08, 'sine', 0.1), 50); break;
                case 'collision': playTone(100, 0.2, 'sawtooth', 0.2); break;
                case 'finish': playTone(523, 0.15, 'sine', 0.2); setTimeout(() => playTone(659, 0.15, 'sine', 0.2), 150); setTimeout(() => playTone(784, 0.3, 'sine', 0.2), 300); break;
                case 'countdown': playTone(800, 0.1, 'square', 0.15); break;
                case 'go': playTone(1000, 0.2, 'sine', 0.2); setTimeout(() => playTone(1200, 0.3, 'sine', 0.2), 100); break;
            }
        }

        // --- NOTIFICATION SYSTEM ---
        function showNotification(message, duration = 3000) {
            const notifArea = document.getElementById('notification-area');
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;
            notifArea.appendChild(notif);
            setTimeout(() => { notif.remove(); }, duration);
        }

        // --- NETWORK FUNCTIONS ---
        function createLobby() {
            if (typeof Peer === 'undefined') { alert('PeerJS library not loaded yet.'); return; }
            
            const username = document.getElementById('username-input').value || "Host Dude";
            myUsername = username;
            isHost = true;
            
            const code = Math.floor(1000 + Math.random() * 9000).toString();
            const peerId = "tumble-" + code;

            initPeer(peerId, code);
        }

        function joinLobby() {
            if (typeof Peer === 'undefined') { alert('PeerJS library not loaded yet.'); return; }
            
            const username = document.getElementById('username-input').value || "Guest Dude";
            myUsername = username;
            isHost = false;
            
            const code = document.getElementById('code-input').value;
            if(!code) { alert("Enter code!"); return; }
            
            initPeer(null, code);
        }

        function copyInviteLink() {
            const code = document.getElementById('lobby-code-display').innerText;
            if(!code || code === "??????") return;
            const baseUrl = window.location.href.split('?')[0];
            const url = baseUrl + '?code=' + code;
            navigator.clipboard.writeText(url).then(() => {
                const btn = document.getElementById('invite-btn');
                const orig = btn.innerText;
                btn.innerText = "‚úÖ LINK COPIED!";
                btn.style.background = "linear-gradient(135deg, #44cc44, #228822)";
                setTimeout(() => { btn.innerText = orig; btn.style.background = ""; }, 2000);
            }).catch(err => { alert("Invite Link: " + url); });
        }

        function initPeer(customId, lobbyCode) {
            document.getElementById('loading-overlay').style.display = 'flex';
            
            const connectionTimeout = setTimeout(() => {
                if(peer && !peer.id) {
                    document.getElementById('loading-overlay').style.display = 'none';
                    alert(`Connection timeout! Check firewall settings.`);
                    if(peer) peer.destroy();
                    peer = null;
                    backToMenu();
                }
            }, 15000);
            
            peer = new Peer(customId, {
                host: '0.peerjs.com', secure: true, port: 443, path: '/',
                config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' }] },
                debug: 1
            });

            peer.on('open', (id) => {
                clearTimeout(connectionTimeout);
                myId = id;
                document.getElementById('loading-overlay').style.display = 'none';
                
                // Construct the costume object with HEX values for network transmission
                const costumeToSend = {
                    skin: PALETTES.skin[myCostume.skin],
                    hair: PALETTES.hair[myCostume.hair],
                    shirt: PALETTES.shirt[myCostume.shirt],
                    pants: PALETTES.pants[myCostume.pants],
                    hairStyle: myCostume.hairStyle
                };
                
                if(isHost) {
                    enterLobbyUI(lobbyCode);
                    window.opponentsData[myId] = { username: myUsername, isHost: true, costume: costumeToSend, ready: false };
                    updateLobbyList();
                    startPingLoop();
                } else {
                    const hostId = "tumble-" + lobbyCode;
                    hostConn = peer.connect(hostId);
                    
                    hostConn.on('open', () => {
                        console.log("Connected to Host!");
                        hostConn.send({ type: 'join', username: myUsername, costume: costumeToSend });
                        enterLobbyUI(lobbyCode);
                        startPingLoop();
                    });

                    hostConn.on('data', handleDataFromHost);
                    hostConn.on('close', () => { showNotification("Host disconnected!"); setTimeout(() => backToMenu(), 2000); });
                    hostConn.on('error', (err) => { alert("Connection Error: " + err); backToMenu(); });
                }
            });

            peer.on('connection', (conn) => {
                if(!isHost) return;
                conn.on('open', () => {
                    connections.push(conn);
                    conn.send({ type: 'state_update', players: window.opponentsData });
                });
                conn.on('data', (data) => handleDataFromClient(data, conn.peer));
                conn.on('close', () => {
                    if(window.opponentsData[conn.peer]) showNotification(`${window.opponentsData[conn.peer].username} disconnected`);
                    delete window.opponentsData[conn.peer];
                    connections = connections.filter(c => c.peer !== conn.peer);
                    updateLobbyList();
                    broadcastState();
                });
            });

            peer.on('error', (err) => {
                clearTimeout(connectionTimeout);
                document.getElementById('loading-overlay').style.display = 'none';
                console.error('Peer error:', err);
                alert("Network Error: " + (err.type || err.message));
                backToMenu();
            });
        }

        // --- PING SYSTEM ---
        function startPingLoop() {
            setInterval(() => {
                if(!gameActive) return;
                lastPingTime = Date.now();
                if(isHost) {
                    connections.forEach(c => { c.send({ type: 'ping', timestamp: Date.now() }); });
                } else if(hostConn && hostConn.open) {
                    hostConn.send({ type: 'pong', timestamp: Date.now() });
                }
            }, 2000);
        }
        
        function updatePingDisplay() {
            if(!gameActive) return;
            const pingIndicator = document.getElementById('ping-indicator');
            const pingText = document.getElementById('ping-text');
            const pingDot = pingIndicator.querySelector('.ping-dot');
            pingIndicator.style.display = 'flex';
            pingText.textContent = `${currentPing} ms`;
            pingDot.className = 'ping-dot';
            if(currentPing < 100) pingDot.classList.add('ping-good');
            else if(currentPing < 200) pingDot.classList.add('ping-medium');
            else pingDot.classList.add('ping-bad');
        }

        // --- HOST LOGIC ---
        function handleDataFromClient(data, clientId) {
            if(data.type === 'join') {
                if(Object.keys(window.opponentsData).length >= 6) return;
                
                const costume = data.costume || { skin:'#ffccaa', hair:'#000000', shirt:'#888888', pants:'#333333', hairStyle: 0 };
                
                window.opponentsData[clientId] = { 
                    username: data.username, isHost: false, costume: costume, ready: false,
                    x: -5, y: 5, z: 0, rot: 0, finished: false
                };
                
                for (const pid in window.opponentsData) window.opponentsData[pid].ready = false;
                
                updateLobbyList();
                broadcastState();
            } else if (data.type === 'pos') {
                if(window.opponentsData[clientId]) Object.assign(window.opponentsData[clientId], data.state);
            } else if (data.type === 'ready') {
                if(window.opponentsData[clientId]) {
                    window.opponentsData[clientId].ready = data.ready;
                    updateLobbyList();
                    broadcastState();
                }
            } else if (data.type === 'pong') {
                // Keep-alive/ping
            }
        }

        function broadcastState() {
            const msg = { type: 'state_update', players: window.opponentsData };
            connections.forEach(c => c.send(msg));
        }

        // --- CLIENT LOGIC ---
        function handleDataFromHost(data) {
            if (data.type === 'state_update') {
                window.opponentsData = data.players;
                updateLobbyList();
            } else if (data.type === 'start_game') {
                startCountdown(data.level);
            } else if (data.type === 'ping') {
                const rtt = Date.now() - data.timestamp;
                currentPing = rtt;
                updatePingDisplay();
                if(hostConn && hostConn.open) hostConn.send({ type: 'pong', timestamp: data.timestamp });
            }
        }

        // --- UI FUNCS ---
        function enterLobbyUI(code) {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('wait-room').style.display = 'flex';
            document.getElementById('lobby-code-display').innerText = code;
            const startBtn = document.getElementById('start-btn');
            const waitText = document.getElementById('wait-text');
            if(isHost) {
                startBtn.style.display = 'block'; waitText.style.display = 'none';
            } else {
                startBtn.style.display = 'none'; waitText.style.display = 'block';
            }
        }

        function updateLobbyList() {
            const list = document.getElementById('player-list');
            const waitingMsg = document.getElementById('waiting-message');
            const startBtn = document.getElementById('start-btn');
            const readyBtn = document.getElementById('ready-btn');
            
            list.innerHTML = '';
            let count = 0; let allReady = true;
            
            for(const pid in window.opponentsData) {
                const p = window.opponentsData[pid];
                const li = document.createElement('li');
                
                // Show shirt color as icon
                const icon = document.createElement('span');
                icon.className = 'player-icon';
                const shirtC = (p.costume && p.costume.shirt) ? p.costume.shirt : '#888';
                icon.style.backgroundColor = shirtC;
                li.appendChild(icon);

                const nameSpan = document.createElement('span');
                const readyIcon = p.ready ? '‚úì ' : '';
                nameSpan.innerText = `${readyIcon}${p.username} ${p.isHost ? 'üëë' : ''}`;
                nameSpan.style.color = p.ready ? '#44cc44' : '#ffffff';
                li.appendChild(nameSpan);
                list.appendChild(li);
                count++;
                if (!p.ready) allReady = false;
            }
            
            document.getElementById('player-count').innerText = `${count} / 6 Players`;
            const myData = window.opponentsData[myId];
            if (myData && myData.ready) {
                readyBtn.innerText = '‚úó UNREADY'; readyBtn.style.background = '#cc4444';
            } else {
                readyBtn.innerText = '‚úì READY UP'; readyBtn.style.background = '#44cc44';
            }
            
            if (isHost) {
                if (count === 1) {
                    readyBtn.style.display = 'none'; startBtn.style.display = 'block'; startBtn.disabled = false;
                } else {
                    readyBtn.style.display = 'block'; startBtn.style.display = 'block'; startBtn.disabled = !allReady;
                }
            } else {
                readyBtn.style.display = 'block'; startBtn.style.display = 'none';
            }
            waitingMsg.style.display = (isHost && count === 1) ? 'block' : 'none';
        }

        function toggleReady() {
            if (!myId || !window.opponentsData[myId]) return;
            const newReadyState = !window.opponentsData[myId].ready;
            window.opponentsData[myId].ready = newReadyState;
            if (isHost) { updateLobbyList(); broadcastState(); }
            else if (hostConn && hostConn.open) { hostConn.send({ type: 'ready', ready: newReadyState }); updateLobbyList(); }
        }

        // --- COUNTDOWN SYSTEM ---
        function startCountdown(level) {
            if(isCountingDown) return;
            isCountingDown = true;
            document.getElementById('lobby-ui').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            window.startMultiplayerGame(level, false); 
            const overlay = document.getElementById('countdown-overlay');
            overlay.style.display = 'flex';
            let count = 3;
            overlay.textContent = count;
            overlay.classList.remove('go');
            playSoundEffect('countdown');
            const countInterval = setInterval(() => {
                count--;
                if(count > 0) {
                    overlay.textContent = count; playSoundEffect('countdown');
                } else {
                    overlay.textContent = 'GO!'; overlay.classList.add('go'); playSoundEffect('go');
                    window.gameActive = true; gameActive = true;
                    setTimeout(() => { overlay.style.display = 'none'; isCountingDown = false; }, 1000);
                    clearInterval(countInterval);
                }
            }, 1000);
        }

        window.hostStartGame = function() {
            if(!isHost || isCountingDown) return;
            const level = window.generateRandomLevelStructure(); 
            const msg = { type: 'start_game', level: level };
            connections.forEach(c => c.send(msg));
            startCountdown(level);
        }

        window.backToMenu = function() {
            if(peer) peer.destroy();
            peer = null; connections = []; hostConn = null; window.opponentsData = {};
            document.getElementById('win-screen').style.display = 'none';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('ping-indicator').style.display = 'none';
            document.getElementById('lobby-ui').style.display = 'flex';
            document.getElementById('main-menu').style.display = 'flex';
            document.getElementById('wait-room').style.display = 'none';
            document.getElementById('loading-overlay').style.display = 'none';
            window.gameActive = false; gameActive = false; isCountingDown = false;
            window.clearLevel(); window.changeMusicTrack();
        }

        setInterval(() => {
            if(!window.gameActive || !myId) return;
            if(window.playerBody) {
                myState = {
                    x: parseFloat(window.playerBody.position.x.toFixed(2)),
                    y: parseFloat(window.playerBody.position.y.toFixed(2)),
                    z: parseFloat(window.playerBody.position.z.toFixed(2)),
                    rot: parseFloat(window.playerMesh.rotation.y.toFixed(2)),
                    finished: window.hasFinished
                };
            }
            if(isHost) {
                if(window.opponentsData[myId]) Object.assign(window.opponentsData[myId], myState);
                broadcastState();
            } else if (hostConn && hostConn.open) {
                hostConn.send({ type: 'pos', state: myState });
            }
        }, 50);

        window.createLobby = createLobby;
        window.joinLobby = joinLobby;
        window.hostStartGame = hostStartGame;
        window.toggleReady = toggleReady;
        window.copyInviteLink = copyInviteLink;
        window.backToMenu = backToMenu;

        function waitForLibraries() {
            return new Promise((resolve) => {
                const statusDiv = document.getElementById('auth-status');
                statusDiv.innerText = 'Loading libraries...'; statusDiv.style.color = '#ffaa00';
                const checkLibraries = () => {
                    if (typeof THREE !== 'undefined' && typeof CANNON !== 'undefined' && typeof Peer !== 'undefined') {
                        statusDiv.innerText = 'Ready to Connect ‚úì'; statusDiv.style.color = '#44cc44'; resolve();
                    } else { setTimeout(checkLibraries, 100); }
                };
                checkLibraries();
            });
        }

        async function init() {
            await waitForLibraries();
            
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            if(code) { document.getElementById('code-input').value = code; document.getElementById('username-input').focus(); }

            // Init Preview
            initPreview();

            // Main Game Scene Init
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x6a0dad); 
            scene.fog = new THREE.FogExp2(0x6a0dad, 0.006);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.5); scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffaa00, 0.8);
            sun.position.set(50, 100, 50); sun.castShadow = true; scene.add(sun);
            const purpleLight = new THREE.PointLight(0xff00ff, 0.8, 200);
            purpleLight.position.set(50, 50, 50); scene.add(purpleLight);

            world = new CANNON.World();
            world.gravity.set(0, -30, 0); 
            world.broadphase = new CANNON.NaiveBroadphase();
            
            const defaultMaterial = new CANNON.Material('default');
            const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, { friction: 0.3, restitution: 0.1 });
            world.addContactMaterial(defaultContactMaterial);

            createBackgroundScenery(); 
            
            window.addEventListener('keydown', (e) => { 
                let key = e.key.toLowerCase(); if (key === ' ') key = 'space'; 
                if(keys.hasOwnProperty(key)) keys[key] = true; 
            });
            window.addEventListener('keyup', (e) => { 
                let key = e.key.toLowerCase(); if (key === ' ') key = 'space';
                if(keys.hasOwnProperty(key)) keys[key] = false; 
            });
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('click', () => {
                if (!audioCtx) initAudio();
                if (window.gameActive && !isPointerLocked && !isCountingDown) document.body.requestPointerLock();
            });
            document.addEventListener('pointerlockchange', () => { isPointerLocked = document.pointerLockElement === document.body; });
            document.addEventListener('mousemove', (e) => { if (isPointerLocked) cameraAngle += e.movementX * 0.002; });
            
            animate();
        }

        window.startMultiplayerGame = function(levelSegments, activate = true) {
            document.getElementById('win-screen').style.display = 'none';
            clearLevel(); createBackgroundScenery(); buildLevelFromSegments(levelSegments); 
            
            // Generate costume from HEX values since game logic now uses HEX
            const costumeHex = {
                skin: PALETTES.skin[myCostume.skin],
                hair: PALETTES.hair[myCostume.hair],
                shirt: PALETTES.shirt[myCostume.shirt],
                pants: PALETTES.pants[myCostume.pants],
                hairStyle: myCostume.hairStyle
            };
            
            createPlayer(costumeHex);
            
            if(activate) { window.gameActive = true; gameActive = true; }
            window.hasFinished = false; hasFinished = false;
            if (!audioCtx) initAudio();
            window.changeMusicTrack(); 
            if(activate) updateCommentary('start');
        }

        const musicTracks = [
            { name: "Funky Bean", tempo: 250, bass: [110, 110, 130, 146, 110, 110, 98, 98], melody: [440, 0, 523, 440, 0, 587, 523, 0], bassType: 'triangle', melodyType: 'square' },
            { name: "Hyper Space", tempo: 200, bass: [65, 0, 65, 0, 73, 0, 73, 0], melody: [523, 523, 784, 0, 659, 0, 523, 0], bassType: 'sawtooth', melodyType: 'sawtooth' },
            { name: "Retro Dash", tempo: 280, bass: [87, 87, 98, 98, 110, 110, 130, 0], melody: [698, 0, 659, 0, 587, 587, 523, 0], bassType: 'square', melodyType: 'triangle' }
        ];
        window.changeMusicTrack = function() { currentTrack = musicTracks[Math.floor(Math.random() * musicTracks.length)]; }
        currentTrack = musicTracks[0];

        function initAudio() {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                if(audioCtx.state === 'suspended') audioCtx.resume();
                startMusicLoop();
            } catch(e) { console.error("Audio init failed", e); }
        }

        function toggleMusic() {
            isMuted = !isMuted;
            if(isMuted && audioCtx) audioCtx.suspend();
            if(!isMuted && audioCtx) audioCtx.resume();
        }

        function playTone(freq, duration, type='sine', vol=0.1) {
            if (!audioCtx || isMuted) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + duration);
        }

        function startMusicLoop() {
            if(isPlayingMusic) return;
            isPlayingMusic = true;
            const loop = () => {
                if(!audioCtx || isMuted || audioCtx.state !== 'running') { setTimeout(loop, 250); return; }
                const track = currentTrack;
                playTone(track.bass[noteIndex % 8], 0.2, track.bassType, 0.15);
                if(track.melody[noteIndex % 8] !== 0) playTone(track.melody[noteIndex % 8], 0.1, track.melodyType, 0.05);
                if(noteIndex % 2 === 0) playTone(2000 + Math.random()*500, 0.05, 'sawtooth', 0.02);
                noteIndex++;
                setTimeout(loop, track.tempo);
            };
            loop();
        }

        function generateSkyboxTexture(theme) {
            const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 512;
            const ctx = canvas.getContext('2d'); const w = canvas.width; const h = canvas.height;
            if (theme === 0) {
                const grad = ctx.createLinearGradient(0, 0, 0, h); grad.addColorStop(0, '#000000'); grad.addColorStop(1, '#220033');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h); ctx.fillStyle = '#ffffff';
                for(let i=0; i<400; i++) { ctx.beginPath(); ctx.arc(Math.random()*w, Math.random()*h, Math.random()*1.5, 0, Math.PI*2); ctx.fill(); }
            } else if (theme === 1) {
                const grad = ctx.createLinearGradient(0, 0, 0, h); grad.addColorStop(0, '#00BFFF'); grad.addColorStop(1, '#FFFFFF');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
            } else if (theme === 2) {
                const grad = ctx.createLinearGradient(0, 0, 0, h); grad.addColorStop(0, '#4B0082'); grad.addColorStop(0.5, '#FF4500'); grad.addColorStop(1, '#FFD700');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
            } else {
                const grad = ctx.createLinearGradient(0, 0, 0, h); grad.addColorStop(0, '#000000'); grad.addColorStop(1, '#001133');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h); ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)'; ctx.lineWidth = 3;
                for(let i=0; i<w; i+=150) { ctx.beginPath(); ctx.moveTo(w/2, h/2); ctx.lineTo(i, h); ctx.stroke(); }
            }
            return new THREE.CanvasTexture(canvas);
        }

        function createBackgroundScenery() {
            backgroundObjects.forEach(obj => scene.remove(obj)); backgroundObjects = [];
            const theme = Math.floor(Math.random() * 4);
            if (theme === 0) scene.background = new THREE.Color(0x110022);
            else if (theme === 1) scene.background = new THREE.Color(0x87CEFA);
            else if (theme === 2) scene.background = new THREE.Color(0x4B0082);
            else scene.background = new THREE.Color(0x001133);
            const texture = generateSkyboxTexture(theme);
            const geo = new THREE.SphereGeometry(800, 60, 40);
            const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide, fog: false });
            const skybox = new THREE.Mesh(geo, mat); scene.add(skybox); backgroundObjects.push(skybox);
        }

        window.generateRandomLevelStructure = function() {
            const types = ['path', 'narrow', 'hammers', 'tilts', 'walls', 'ramp_up', 'ramp_down', 'shift_left', 'shift_right', 'split_hammers_walls', 'split_ramp_tunnel'];
            const length = 25 + Math.floor(Math.random() * 15); const level = ['start'];
            for(let i=0; i<length; i++) { level.push(types[Math.floor(Math.random() * types.length)]); }
            level.push('finish'); return level;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        async function updateCommentary(eventType) {
            if(!gameActive && eventType !== 'start') return;
            const now = Date.now();
            if(now - lastCommentaryTime < 8000 && eventType !== 'checkpoint') return;
            lastCommentaryTime = now;
            const boxText = document.getElementById('commentary-text');
            const phrases = COMMENTARY[eventType] || [`${eventType}!`];
            const randomPhrase = phrases[Math.floor(Math.random() * phrases.length)];
            boxText.innerText = randomPhrase;
            document.getElementById('commentary-box').style.opacity = 1;
            setTimeout(() => { document.getElementById('commentary-box').style.opacity = 0; }, 5000);
        }

        let levelObjects = [];
        let currentPos = { x: -5, y: -0.5, z: 0 };
        let levelMinY = -0.5;

        function createBox(w, h, d, x, y, z, color, mass=0, rotX=0, rotY=0, rotZ=0) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshPhongMaterial({ color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z); mesh.rotation.set(rotX, rotY, rotZ);
            mesh.castShadow = true; mesh.receiveShadow = true; scene.add(mesh);
            const shape = new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2));
            const body = new CANNON.Body({ mass: mass, material: world.defaultMaterial });
            body.addShape(shape); body.position.set(x, y, z);
            const q = new CANNON.Quaternion(); q.setFromEuler(rotX, rotY, rotZ); body.quaternion.copy(q);
            world.addBody(body);
            const obj = { mesh, body, type: 'static' }; levelObjects.push(obj); return obj;
        }

        window.clearLevel = function() {
            levelObjects.forEach(obj => { scene.remove(obj.mesh); world.removeBody(obj.body); });
            levelObjects = []; obstacles = []; prevObstacleStates = []; currentPos = { x: -5, y: -0.5, z: 0 }; levelMinY = -0.5;
            currentRespawnPos = { x: -5, y: 5, z: 0 }; checkpointPos = null; checkpointActivated = false; window.checkpointFlagMat = null;
            if(player) { scene.remove(player.mesh); world.removeBody(player.body); player = null; window.playerBody = null; window.playerMesh = null; }
            for(let uid in opponents) { scene.remove(opponents[uid].mesh); }
            opponents = {};
        }

        function createCheckpointVisual(x, y, z) {
            const poleGeo = new THREE.CylinderGeometry(0.5, 0.5, 10);
            const poleMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const pole = new THREE.Mesh(poleGeo, poleMat); pole.position.set(x, y + 5, z - 12); scene.add(pole);
            const dummyBody = new CANNON.Body({ mass: 0 }); levelObjects.push({ mesh: pole, body: dummyBody });
            const flagGeo = new THREE.BoxGeometry(4, 3, 0.5);
            const flagMat = new THREE.MeshPhongMaterial({ color: 0xff0000 }); 
            const flag = new THREE.Mesh(flagGeo, flagMat); flag.position.set(x + 2, y + 8, z - 12); scene.add(flag);
            levelObjects.push({ mesh: flag, body: dummyBody }); window.checkpointFlagMat = flagMat;
        }

        function buildLevelFromSegments(segments) {
            currentPos = { x: -5, y: -0.5, z: 0 }; levelMinY = -0.5;
            const midIndex = Math.floor(segments.length / 2);
            segments.forEach((seg, index) => {
                const baseColor = index % 2 === 0 ? 0xdddddd : 0xcccccc;
                if (index === midIndex) {
                    checkpointPos = { x: currentPos.x + 10, y: currentPos.y + 2, z: currentPos.z }; 
                    createCheckpointVisual(currentPos.x + 10, currentPos.y, currentPos.z);
                    createBox(25, 1, 25, currentPos.x + 10, currentPos.y - 0.2, currentPos.z, 0x66ff66);
                }
                switch(seg) {
                    case 'start': createBox(15, 1, 20, currentPos.x, currentPos.y, currentPos.z, 0x44cc44); currentPos.x += 15; break;
                    case 'path': createBox(30, 1, 10, currentPos.x + 15, currentPos.y, currentPos.z, baseColor); currentPos.x += 30; break;
                    case 'narrow': createBox(20, 1, 2, currentPos.x + 10, currentPos.y, currentPos.z, 0xffaa00); currentPos.x += 20; break;
                    case 'ramp_up': { const rampLen = 30; const rise = 10; const angle = Math.atan2(rise, rampLen); const hyp = Math.sqrt(rampLen*rampLen + rise*rise); createBox(hyp, 1, 10, currentPos.x + rampLen/2, currentPos.y + rise/2, currentPos.z, 0xff00ff, 0, 0, 0, angle); currentPos.x += rampLen; currentPos.y += rise; break; }
                    case 'ramp_down': { const rampLenD = 30; const drop = 10; const angleD = -Math.atan2(drop, rampLenD); const hypD = Math.sqrt(rampLenD*rampLenD + drop*drop); createBox(hypD, 1, 10, currentPos.x + rampLenD/2, currentPos.y - drop/2, currentPos.z, 0x00ffff, 0, 0, 0, angleD); currentPos.x += rampLenD; currentPos.y -= drop; break; }
                    case 'shift_left': createBox(Math.sqrt(800), 1, 10, currentPos.x + 10, currentPos.y, currentPos.z - 10, 0xffff00, 0, 0, -Math.PI/4, 0); currentPos.x += 20; currentPos.z -= 20; break;
                    case 'shift_right': createBox(Math.sqrt(800), 1, 10, currentPos.x + 10, currentPos.y, currentPos.z + 10, 0xffff00, 0, 0, Math.PI/4, 0); currentPos.x += 20; currentPos.z += 20; break;
                    case 'walls': createBox(25, 1, 10, currentPos.x + 12.5, currentPos.y, currentPos.z, baseColor); createBox(1, 4, 10, currentPos.x + 8, currentPos.y + 2, currentPos.z, 0x5555ff); createBox(1, 4, 10, currentPos.x + 16, currentPos.y + 2, currentPos.z, 0x5555ff); currentPos.x += 25; break;
                    case 'hammers': { createBox(25, 1, 10, currentPos.x + 12.5, currentPos.y, currentPos.z, 0x888888); const hX = currentPos.x + 12.5; const hY = currentPos.y; const hZ = currentPos.z; createBox(1, 6, 1, hX, hY + 3, hZ, 0x222222); const hammerHead = createBox(8, 1, 1, hX, hY + 6, hZ, 0xff2222, 10); hammerHead.body.type = CANNON.Body.KINEMATIC; obstacles.push({ ...hammerHead, type: 'spinner', speed: 3 }); currentPos.x += 25; break; }
                    case 'tilts': { for(let i=0; i<2; i++) { const p = createBox(8, 0.5, 8, currentPos.x + 8 + (i*10), currentPos.y + 0.5, currentPos.z, 0x33aaff, 10); p.body.type = CANNON.Body.KINEMATIC; obstacles.push({ ...p, type: 'tilt', speed: 1.5, offset: i }); } currentPos.x += 25; break; }
                    case 'split_hammers_walls': { createBox(40, 1, 8, currentPos.x + 20, currentPos.y, currentPos.z - 8, baseColor); const h1 = createBox(8, 1, 1, currentPos.x + 10, currentPos.y + 6, currentPos.z - 8, 0xff2222, 10); h1.body.type = CANNON.Body.KINEMATIC; obstacles.push({ ...h1, type: 'spinner', speed: 4 }); const h2 = createBox(8, 1, 1, currentPos.x + 30, currentPos.y + 6, currentPos.z - 8, 0xff2222, 10); h2.body.type = CANNON.Body.KINEMATIC; obstacles.push({ ...h2, type: 'spinner', speed: -4 }); createBox(40, 1, 8, currentPos.x + 20, currentPos.y, currentPos.z + 8, baseColor); createBox(1, 4, 8, currentPos.x + 10, currentPos.y + 2, currentPos.z + 8, 0x5555ff); createBox(1, 4, 8, currentPos.x + 20, currentPos.y + 2, currentPos.z + 8, 0x5555ff); createBox(1, 4, 8, currentPos.x + 30, currentPos.y + 2, currentPos.z + 8, 0x5555ff); currentPos.x += 40; break; }
                    case 'split_ramp_tunnel': { const riseH = 8; const angleH = Math.atan2(riseH, 20); const hypH = Math.sqrt(20*20 + riseH*riseH); createBox(hypH, 1, 8, currentPos.x + 10, currentPos.y + riseH/2, currentPos.z - 8, 0xff00ff, 0, 0, 0, angleH); createBox(10, 1, 8, currentPos.x + 25, currentPos.y + riseH, currentPos.z - 8, 0xff00ff); createBox(hypH, 1, 8, currentPos.x + 40, currentPos.y + riseH/2, currentPos.z - 8, 0xff00ff, 0, 0, 0, -angleH); createBox(50, 1, 8, currentPos.x + 25, currentPos.y, currentPos.z + 8, baseColor); createBox(50, 1, 8, currentPos.x + 25, currentPos.y + 5, currentPos.z + 8, 0x555555); currentPos.x += 50; break; }
                    case 'finish': { finishLineX = currentPos.x; createBox(20, 1, 20, currentPos.x + 10, currentPos.y, currentPos.z, 0xffd700); const arch = createBox(2, 8, 10, currentPos.x, currentPos.y + 4.5, currentPos.z, 0xffd700); arch.mesh.material.transparent = true; arch.mesh.material.opacity = 0.5; arch.body.collisionFilterGroup = 0; break; }
                }
                if(currentPos.y < levelMinY) levelMinY = currentPos.y;
            });
        }

        function createFaceTexture(skinColorHex) {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128; const ctx = canvas.getContext('2d');
            ctx.fillStyle = skinColorHex; ctx.fillRect(0, 0, 128, 128); ctx.fillStyle = '#000000';
            const eyeY = 50; const eyeXOffset = 20 + Math.random() * 15; const eyeSize = 8 + Math.random() * 10;
            ctx.beginPath(); ctx.arc(64 - eyeXOffset, eyeY, eyeSize, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(64 + eyeXOffset, eyeY, eyeSize, 0, Math.PI * 2); ctx.fill();
            ctx.lineWidth = 6; ctx.strokeStyle = '#000000'; ctx.beginPath();
            const mouthType = Math.floor(Math.random() * 4);
            if (mouthType === 0) ctx.arc(64, 80, 20, 0, Math.PI, false);
            else if (mouthType === 1) ctx.arc(64, 100, 20, Math.PI, 0, false);
            else if (mouthType === 2) ctx.arc(64, 90, 15, 0, Math.PI * 2);
            else { ctx.moveTo(44, 90); ctx.lineTo(84, 90); }
            ctx.stroke(); return new THREE.CanvasTexture(canvas);
        }

        function createNameSprite(name) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Reduced alpha background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
            ctx.beginPath(); ctx.roundRect(10, 10, 492, 108, 20); ctx.fill();
            
            ctx.font = 'bold 50px Arial'; ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(name, canvas.width / 2, canvas.height / 2);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false, depthWrite: false });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(6, 1.5, 1); sprite.renderOrder = 999;
            return sprite;
        }

        function createHumanoid(costume, name) {
            // Default fallbacks
            const skinC = costume.skin || '#ffccaa';
            const hairC = costume.hair || '#442200';
            const shirtC = costume.shirt || '#ff0000';
            const pantsC = costume.pants || '#0000ff';
            const hairStyle = costume.hairStyle || 0;

            const group = new THREE.Group();

            // Head (Skin)
            const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const skinMat = new THREE.MeshPhongMaterial({ color: skinC });
            const faceTexture = createFaceTexture(skinC); 
            const faceMat = new THREE.MeshPhongMaterial({ color: 0xffffff, map: faceTexture }); // Use white base so texture color shows true
            const headMaterials = [skinMat, skinMat, skinMat, skinMat, faceMat, skinMat];
            const head = new THREE.Mesh(headGeo, headMaterials); 
            head.position.y = 0.85; head.castShadow = true; group.add(head);

            // Hair (Custom Color & Style)
            const hairMat = new THREE.MeshPhongMaterial({ color: hairC });
            
            if (hairStyle === 0) { // Standard
                const hairTopGeo = new THREE.BoxGeometry(0.55, 0.15, 0.55);
                const hairTop = new THREE.Mesh(hairTopGeo, hairMat);
                hairTop.position.y = 1.125; hairTop.castShadow = true; group.add(hairTop);
                
                const hairBackGeo = new THREE.BoxGeometry(0.55, 0.4, 0.15);
                const hairBack = new THREE.Mesh(hairBackGeo, hairMat);
                hairBack.position.set(0, 0.85, -0.22); hairBack.castShadow = true; group.add(hairBack);
            } 
            else if (hairStyle === 1) { // Spiky
                const spikeGeo = new THREE.ConeGeometry(0.1, 0.3, 4);
                // Center spike
                const spike1 = new THREE.Mesh(spikeGeo, hairMat);
                spike1.position.set(0, 1.25, 0); spike1.castShadow = true; group.add(spike1);
                // Left spike
                const spike2 = new THREE.Mesh(spikeGeo, hairMat);
                spike2.position.set(-0.15, 1.2, 0); spike2.rotation.z = 0.3; spike2.castShadow = true; group.add(spike2);
                // Right spike
                const spike3 = new THREE.Mesh(spikeGeo, hairMat);
                spike3.position.set(0.15, 1.2, 0); spike3.rotation.z = -0.3; spike3.castShadow = true; group.add(spike3);
                // Base
                const baseGeo = new THREE.BoxGeometry(0.52, 0.05, 0.52);
                const base = new THREE.Mesh(baseGeo, hairMat);
                base.position.y = 1.1; base.castShadow = true; group.add(base);
            }
            else if (hairStyle === 2) { // Mohawk
                const mohawkGeo = new THREE.BoxGeometry(0.15, 0.4, 0.6);
                const mohawk = new THREE.Mesh(mohawkGeo, hairMat);
                mohawk.position.set(0, 1.2, 0); mohawk.castShadow = true; group.add(mohawk);
            }
            else if (hairStyle === 3) { // Bob
                const topGeo = new THREE.BoxGeometry(0.6, 0.15, 0.6);
                const top = new THREE.Mesh(topGeo, hairMat);
                top.position.y = 1.125; top.castShadow = true; group.add(top);
                
                const sideLGeo = new THREE.BoxGeometry(0.1, 0.5, 0.5);
                const sideL = new THREE.Mesh(sideLGeo, hairMat);
                sideL.position.set(-0.28, 0.9, 0); sideL.castShadow = true; group.add(sideL);
                
                const sideRGeo = new THREE.BoxGeometry(0.1, 0.5, 0.5);
                const sideR = new THREE.Mesh(sideRGeo, hairMat);
                sideR.position.set(0.28, 0.9, 0); sideR.castShadow = true; group.add(sideR);
                
                const backGeo = new THREE.BoxGeometry(0.6, 0.5, 0.1);
                const back = new THREE.Mesh(backGeo, hairMat);
                back.position.set(0, 0.9, -0.28); back.castShadow = true; group.add(back);
            }
            // Style 4 is Bald (no mesh added)

            // Body (Shirt)
            const bodyGeo = new THREE.BoxGeometry(0.6, 0.7, 0.35); 
            const bodyMat = new THREE.MeshPhongMaterial({ color: shirtC }); 
            const body = new THREE.Mesh(bodyGeo, bodyMat); 
            body.position.y = 0.2; body.castShadow = true; group.add(body);

            // Arms (Skin) - could be shirt color for long sleeves, but let's keep as skin for now
            const armGeo = new THREE.BoxGeometry(0.2, 0.7, 0.2); 
            const armMat = new THREE.MeshPhongMaterial({ color: skinC });

            const armL = new THREE.Mesh(armGeo, armMat); armL.position.set(-0.45, 0.2, 0); armL.name = "armL"; armL.castShadow = true; group.add(armL);
            const armR = new THREE.Mesh(armGeo, armMat); armR.position.set(0.45, 0.2, 0); armR.name = "armR"; armR.castShadow = true; group.add(armR);

            // Legs (Pants)
            const legGeo = new THREE.BoxGeometry(0.22, 0.8, 0.22); 
            const legMat = new THREE.MeshPhongMaterial({ color: pantsC }); 
            const legL = new THREE.Mesh(legGeo, legMat); legL.position.set(-0.2, -0.6, 0); legL.name = "legL"; legL.castShadow = true; group.add(legL);
            const legR = new THREE.Mesh(legGeo, legMat); legR.position.set(0.2, -0.6, 0); legR.name = "legR"; legR.castShadow = true; group.add(legR);
            
            if (name) {
                const nameSprite = createNameSprite(name);
                nameSprite.position.y = 2.8; // Raised higher to clear mohawks/spikes
                nameSprite.name = "nameSprite";
                group.add(nameSprite);
            }
            return group;
        }

        function createPlayer(costumeOverride) {
            const costumeToUse = costumeOverride || myCostume; // Note: myCostume are indices, we need hex if this isn't overridden
            
            // If not overridden (solo play or something), we need to convert myCostume indices to hex
            let finalCostume = costumeOverride;
            if(!finalCostume) {
                finalCostume = {
                    skin: PALETTES.skin[myCostume.skin],
                    hair: PALETTES.hair[myCostume.hair],
                    shirt: PALETTES.shirt[myCostume.shirt],
                    pants: PALETTES.pants[myCostume.pants],
                    hairStyle: myCostume.hairStyle
                };
            }

            const mesh = createHumanoid(finalCostume, myUsername); 
            scene.add(mesh); playerMesh = mesh; window.playerMesh = mesh;
            const shape = new CANNON.Sphere(0.6); 
            playerBody = new CANNON.Body({ mass: 1, fixedRotation: true, material: world.defaultMaterial });
            playerBody.addShape(shape); playerBody.position.set(-5, 2, 0); playerBody.linearDamping = 0.0; 
            world.addBody(playerBody);
            player = { mesh, body: playerBody, isPlayer: true }; 
            window.playerBody = playerBody;
            prevPlayerPos.x = playerBody.position.x; prevPlayerPos.y = playerBody.position.y; prevPlayerPos.z = playerBody.position.z;
        }

        function updatePhysics() {
            world.step(fixedTimeStep);
            let isGrounded = false;
            for(let i = 0; i < world.contacts.length; i++) {
                const c = world.contacts[i];
                if(c.bi === playerBody || c.bj === playerBody) {
                    if(c.bi === playerBody) { if(c.ni.y < -0.5) isGrounded = true; } else { if(c.ni.y > 0.5) isGrounded = true; }
                    if(gameActive) {
                        const now = Date.now();
                        const relVel = c.bi === playerBody ? c.bi.velocity.length() : c.bj.velocity.length();
                        if(relVel > 25 && now - lastCollisionSound > 500) { playSoundEffect('collision'); lastCollisionSound = now; }
                    }
                }
            }
            if (isGrounded) lastGroundedTime = Date.now();
            const time = Date.now() * 0.001;
            obstacles.forEach(obs => {
                if(obs.type === 'spinner') obs.body.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), time * obs.speed);
                else if(obs.type === 'tilt') obs.body.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.sin(time * obs.speed + obs.offset) * 0.5);
                obs.mesh.position.copy(obs.body.position); obs.mesh.quaternion.copy(obs.body.quaternion);
            });
            if(gameActive || !gameActive) { 
                if(playerBody && playerBody.position.y < levelMinY - 30) {
                    playerBody.position.set(currentRespawnPos.x, currentRespawnPos.y, currentRespawnPos.z);
                    playerBody.velocity.set(0, 0, 0); 
                    if(gameActive) { playerMomentum = 30; if(checkpointActivated) updateCommentary('fall'); else updateCommentary('fall'); }
                }
            }
            if(gameActive) {
                if(checkpointPos && !checkpointActivated && playerBody.position.x > checkpointPos.x) {
                    checkpointActivated = true; currentRespawnPos = { x: checkpointPos.x, y: checkpointPos.y + 10, z: checkpointPos.z };
                    if(window.checkpointFlagMat) window.checkpointFlagMat.color.setHex(0x00ff00);
                    playTone(880, 0.1, 'sine', 0.2); setTimeout(() => playTone(1100, 0.2, 'sine', 0.2), 100);
                    updateCommentary('checkpoint');
                }
                for (const uid in window.opponentsData) {
                    const data = window.opponentsData[uid]; if(uid === myId) continue; 
                    if (!opponents[uid]) {
                        // Pass costume data
                        const mesh = createHumanoid(data.costume || {}, data.username); 
                        scene.add(mesh);
                        opponents[uid] = { mesh: mesh, lastPos: new THREE.Vector3(data.x, data.y, data.z) };
                    }
                    const opp = opponents[uid]; const currentPos = new THREE.Vector3(data.x, data.y, data.z);
                    const speed = currentPos.distanceTo(opp.lastPos) * 60; opp.lastPos.copy(currentPos);
                    opp.mesh.position.lerp(new THREE.Vector3(data.x, data.y - 0.1, data.z), 0.2); opp.mesh.rotation.y = data.rot;
                    const armL = opp.mesh.getObjectByName('armL'); const armR = opp.mesh.getObjectByName('armR');
                    const legL = opp.mesh.getObjectByName('legL'); const legR = opp.mesh.getObjectByName('legR');
                    if(speed > 0.5) {
                        const runTime = Date.now() * 0.015;
                        if(armL) armL.rotation.x = Math.sin(runTime) * 0.8; if(armR) armR.rotation.x = -Math.sin(runTime) * 0.8;
                        if(legL) legL.rotation.x = -Math.sin(runTime) * 0.8; if(legR) legR.rotation.x = Math.sin(runTime) * 0.8;
                    } else {
                        if(armL) armL.rotation.x = 0; if(armR) armR.rotation.x = 0; if(legL) legL.rotation.x = 0; if(legR) legR.rotation.x = 0;
                    }
                }
                for (const uid in opponents) { if (!window.opponentsData[uid]) { scene.remove(opponents[uid].mesh); delete opponents[uid]; } }
                
                const baseSpeed = 30; const maxSpeed = 50; const acceleration = 0.15; const deceleration = 0.5;
                if (keys.w) playerMomentum = Math.min(playerMomentum + acceleration, maxSpeed);
                else playerMomentum = Math.max(playerMomentum - deceleration, baseSpeed);
                const pct = ((playerMomentum - baseSpeed) / (maxSpeed - baseSpeed)) * 100;
                document.getElementById('speed-bar').style.width = `${pct}%`;
                
                const force = new CANNON.Vec3(0, 0, 0);
                const fwdX = Math.cos(cameraAngle); const fwdZ = Math.sin(cameraAngle);
                const rightX = -Math.sin(cameraAngle); const rightZ = Math.cos(cameraAngle);
                if(keys.w) { force.x += fwdX * playerMomentum; force.z += fwdZ * playerMomentum; }
                if(keys.s) { force.x -= fwdX * (playerMomentum * 0.6); force.z -= fwdZ * (playerMomentum * 0.6); }
                if(keys.a) { force.x -= rightX * (playerMomentum * 0.8); force.z -= rightZ * (playerMomentum * 0.8); }
                if(keys.d) { force.x += rightX * (playerMomentum * 0.8); force.z += rightZ * (playerMomentum * 0.8); }
                playerBody.velocity.x = force.x * 0.5; playerBody.velocity.z = force.z * 0.5;
                if(keys.w && Math.abs(playerBody.velocity.y) > 0.5) { playerBody.velocity.x += fwdX * 0.2; playerBody.velocity.z += fwdZ * 0.2; }
                if(keys.space && (Date.now() - lastGroundedTime < 200)) { lastGroundedTime = 0; playerBody.velocity.y = 20; playSoundEffect('jump'); }
                checkFinish();
            }
        }
        
        function checkFinish() {
            if(!hasFinished && playerBody.position.x > finishLineX) {
                hasFinished = true; 
                window.hasFinished = true; 
                playSoundEffect('finish');
                showEndScreen(); 
                updateCommentary('finish');
            }
            
            let myX = playerBody.position.x; 
            let countAhead = 0;
            for(const uid in window.opponentsData) { 
                if(window.opponentsData[uid].x > myX) countAhead++; 
            }
            document.getElementById('rank').innerText = `Rank: ${countAhead + 1}`;
        }
        
        function showEndScreen() {
            window.gameActive = false; 
            gameActive = false;
            document.exitPointerLock();
            
            const winScreen = document.getElementById('win-screen');
            const leaderboardDiv = document.getElementById('final-leaderboard');
            const controlsDiv = document.getElementById('end-screen-controls');
            
            leaderboardDiv.innerHTML = ''; 
            controlsDiv.innerHTML = '';
            
            let allPlayers = [];
            if (window.playerBody) allPlayers.push({ 
                username: myUsername + " (You)", 
                x: window.playerBody.position.x, 
                finished: window.hasFinished, 
                isLocal: true 
            });
            
            for (const uid in window.opponentsData) {
                const p = window.opponentsData[uid]; 
                if(uid === myId) continue;
                allPlayers.push({ 
                    username: p.username, 
                    x: p.x, 
                    finished: p.finished, 
                    isLocal: false 
                });
            }
            
            allPlayers.sort((a, b) => { 
                if (a.finished && !b.finished) return -1; 
                if (!a.finished && b.finished) return 1; 
                return b.x - a.x; 
            });
            
            allPlayers.forEach((p, index) => {
                const row = document.createElement('div'); 
                row.className = 'leaderboard-row';
                row.style.color = p.isLocal ? '#ffff00' : 'white'; 
                row.style.fontWeight = p.isLocal ? 'bold' : 'normal';
                const status = p.finished ? '<span style="color:#44cc44">FINISHED</span>' : Math.floor(p.x) + 'm';
                row.innerHTML = `<span>#${index+1} ${p.username}</span><span>${status}</span>`;
                leaderboardDiv.appendChild(row);
            });
            
            const menuBtn = document.createElement('button'); 
            menuBtn.innerText = "BACK TO MENU"; 
            menuBtn.onclick = window.backToMenu; 
            menuBtn.style.marginRight = "10px"; 
            controlsDiv.appendChild(menuBtn);
            
            if (isHost) {
                const nextBtn = document.createElement('button'); 
                nextBtn.innerText = "START NEXT LEVEL"; 
                nextBtn.style.backgroundColor = "#00ffff"; 
                nextBtn.style.color = "#000"; 
                nextBtn.onclick = window.hostStartGame; 
                controlsDiv.appendChild(nextBtn);
            } else {
                const waitText = document.createElement('p'); 
                waitText.innerText = "Waiting for host to start next level..."; 
                waitText.style.fontSize = "0.9em"; 
                waitText.style.color = "#aaa"; 
                waitText.style.marginTop = "10px"; 
                controlsDiv.appendChild(waitText);
            }
            
            winScreen.style.display = 'block';
        }

        function animate() {
            requestAnimationFrame(animate); 
            
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastPhysicsTime) / 1000;
            lastPhysicsTime = currentTime;
            
            const clampedDelta = Math.min(deltaTime, 0.1);
            accumulator += clampedDelta;
            
            while (accumulator >= fixedTimeStep) {
                if (playerBody) {
                    prevPlayerPos.x = playerBody.position.x;
                    prevPlayerPos.y = playerBody.position.y;
                    prevPlayerPos.z = playerBody.position.z;
                }
                obstacles.forEach((obs, i) => {
                    if (!prevObstacleStates[i]) {
                        prevObstacleStates[i] = {};
                    }
                    const s = prevObstacleStates[i];
                    s.px = obs.body.position.x; s.py = obs.body.position.y; s.pz = obs.body.position.z;
                    s.qx = obs.body.quaternion.x; s.qy = obs.body.quaternion.y;
                    s.qz = obs.body.quaternion.z; s.qw = obs.body.quaternion.w;
                });
                updatePhysics();
                accumulator -= fixedTimeStep;
            }
            
            const alpha = accumulator / fixedTimeStep;
            
            obstacles.forEach((obs, i) => {
                if (prevObstacleStates[i]) {
                    const prev = prevObstacleStates[i];
                    obs.mesh.position.set(
                        prev.px + (obs.body.position.x - prev.px) * alpha,
                        prev.py + (obs.body.position.y - prev.py) * alpha,
                        prev.pz + (obs.body.position.z - prev.pz) * alpha
                    );
                    obs.mesh.quaternion.set(prev.qx, prev.qy, prev.qz, prev.qw);
                    obs.mesh.quaternion.slerp(
                        new THREE.Quaternion(obs.body.quaternion.x, obs.body.quaternion.y, obs.body.quaternion.z, obs.body.quaternion.w),
                        alpha
                    );
                }
            });
            
            if (player) {
                player.mesh.position.set(
                    prevPlayerPos.x + (player.body.position.x - prevPlayerPos.x) * alpha,
                    prevPlayerPos.y + (player.body.position.y - prevPlayerPos.y) * alpha - 0.1,
                    prevPlayerPos.z + (player.body.position.z - prevPlayerPos.z) * alpha
                );
                
                // Animation Logic moved here from updatePhysics
                const vel = player.body.velocity; 
                const speed = Math.sqrt(vel.x*vel.x + vel.z*vel.z);
                if(speed > 0.5) player.mesh.rotation.y = Math.atan2(vel.x, vel.z); 
                
                const armL = player.mesh.getObjectByName('armL'); 
                const armR = player.mesh.getObjectByName('armR');
                const legL = player.mesh.getObjectByName('legL'); 
                const legR = player.mesh.getObjectByName('legR');
                
                if(speed > 1) {
                    const runTime = Date.now() * 0.015;
                    if(armL) armL.rotation.x = Math.sin(runTime) * 0.8; 
                    if(armR) armR.rotation.x = -Math.sin(runTime) * 0.8;
                    if(legL) legL.rotation.x = -Math.sin(runTime) * 0.8; 
                    if(legR) legR.rotation.x = Math.sin(runTime) * 0.8;
                } else {
                    if(armL) armL.rotation.x = 0; 
                    if(armR) armR.rotation.x = 0; 
                    if(legL) legL.rotation.x = 0; 
                    if(legR) legR.rotation.x = 0;
                }
            }
            
            if(playerBody) {
                const targetX = prevPlayerPos.x + (playerBody.position.x - prevPlayerPos.x) * alpha;
                const targetY = prevPlayerPos.y + (playerBody.position.y - prevPlayerPos.y) * alpha;
                const targetZ = prevPlayerPos.z + (playerBody.position.z - prevPlayerPos.z) * alpha;
                const radius = 14; 
                const camHeight = 10;
                const camX = targetX - radius * Math.cos(cameraAngle); 
                const camZ = targetZ - radius * Math.sin(cameraAngle);
                
                const lerpFactor = 1 - Math.pow(CAMERA_SMOOTHING_BASE, clampedDelta * 60);
                camera.position.lerp(new THREE.Vector3(camX, targetY + camHeight, camZ), lerpFactor);
                camera.lookAt(camera.position.x + radius * Math.cos(cameraAngle), camera.position.y - camHeight + 2, camera.position.z + radius * Math.sin(cameraAngle));
            }
            
            // Make name sprites face camera
            if (playerMesh) {
                const nameSprite = playerMesh.getObjectByName('nameSprite');
                if (nameSprite) nameSprite.lookAt(camera.position);
            }
            for (const uid in opponents) {
                const nameSprite = opponents[uid].mesh.getObjectByName('nameSprite');
                if (nameSprite) nameSprite.lookAt(camera.position);
            }
            
            if (backgroundObjects.length > 0) backgroundObjects[0].position.copy(camera.position);
            renderer.render(scene, camera);
        }

        window.addEventListener('load', () => { init(); });
    </script>
</body>
</html>
