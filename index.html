<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tumble Dudes - Flow Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <!-- PeerJS for P2P Networking -->
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #222; }
        
        /* Lobby UI Styles */
        #lobby-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #6a0dad, #222);
            display: flex;
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; color: white;
        }

        .panel {
            background: rgba(0,0,0,0.85); 
            padding: 25px; 
            border-radius: 20px;
            border: 2px solid #ff00ff; 
            text-align: center; 
            width: 95%; 
            max-width: 700px; /* Wider panel for side-by-side layout */
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            box-sizing: border-box;
            max-height: 98vh;
            overflow-y: auto;
        }

        input[type="text"] {
            width: 100%; padding: 12px; margin: 0; background: #333;
            border: 1px solid #555; color: white; border-radius: 8px; box-sizing: border-box;
            text-transform: uppercase; text-align: center; letter-spacing: 2px;
        }

        /* Compact Character Creator Styles */
        #character-creator {
            width: 100%;
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: row; /* Horizontal layout */
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }
        
        .cc-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1;
        }

        .cc-column-center {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #char-preview-container {
            width: 160px;
            height: 160px;
            background: rgba(0,0,0,0.3);
            border-radius: 50%;
            overflow: hidden;
            border: 3px solid rgba(255,255,255,0.1);
            position: relative;
            cursor: grab;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }

        #char-preview-container:active {
            cursor: grabbing;
        }
        
        #preview-canvas-target { width: 100%; height: 100%; }

        .creator-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0,0,0,0.3);
            padding: 8px 12px;
            border-radius: 6px;
        }
        
        .creator-row label {
            font-size: 0.75em;
            color: #aaa;
            text-transform: uppercase;
            font-weight: bold;
            text-align: left;
        }
        
        .selector-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .arrow-btn {
            background: rgba(255,255,255,0.1);
            border: none; color: white; width: 20px; height: 20px;
            border-radius: 4px; cursor: pointer; font-size: 0.7em;
            display: flex; align-items: center; justify-content: center;
            transition: background 0.2s;
        }
        .arrow-btn:hover { background: rgba(255,255,255,0.3); }

        .color-display {
            width: 30px; height: 18px; border-radius: 3px;
            border: 1px solid rgba(255,255,255,0.3);
            font-size: 0.7em; line-height: 18px; color: #fff; text-shadow: 1px 1px 1px #000;
        }

        /* Action Buttons */
        .action-row {
            display: flex;
            width: 100%;
            gap: 20px;
            margin-top: 10px;
            align-items: flex-start;
        }

        .action-col {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .separator-vert {
            width: 1px;
            background: #444;
            align-self: stretch;
        }

        button.btn-primary {
            width: 100%; padding: 12px; background: #ff00ff; color: white;
            border: none; border-radius: 8px; font-weight: bold; cursor: pointer;
            transition: 0.2s; font-size: 1em;
        }
        button.btn-primary:hover { background: #d400d4; transform: scale(1.02); }
        button.btn-primary:disabled { background: #555; cursor: not-allowed; transform: none; }

        button.btn-secondary {
            background: rgba(255, 255, 255, 0.1); 
            border: 1px solid #555; 
            color: #ddd;
            padding: 10px 16px; /* Slightly bigger padding for better touch */
            margin-top: 15px; /* More spacing from top elements */
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }
        button.btn-secondary:hover { border-color: white; color: white; background: rgba(255,255,255,0.2); }

        .join-group {
            display: flex;
            gap: 5px;
        }
        .join-group input {
            flex: 1;
            margin: 0;
            font-size: 0.9em;
            padding: 10px;
        }
        .join-group button {
            width: auto;
            padding: 0 20px;
            margin: 0;
        }

        #player-list {
            list-style: none; padding: 0; margin: 20px 0; text-align: left;
            width: 100%; 
            max-height: 150px; overflow-y: auto;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }
        #player-list li {
            padding: 10px; border-bottom: 1px solid #444; font-size: 1.1em;
            display: flex; align-items: center; gap: 10px;
        }
        
        .player-icon {
            width: 20px; height: 20px; border-radius: 4px;
            display: inline-block; border: 2px solid white;
            position: relative;
        }

        #code-display {
            font-size: 2.5em; 
            font-family: monospace; color: #00ffff;
            margin: 10px 0; letter-spacing: 5px;
            font-weight: bold;
        }

        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 200; color: #ff00ff;
            display: none; align-items: center; justify-content: center;
            font-size: 1.5em; flex-direction: column; gap: 20px;
        }

        /* Game UI - Full Screen Container */
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            color: white; pointer-events: none; z-index: 10;
            display: none; 
        }

        #hud-stats {
            position: absolute; top: 20px; left: 20px;
            display: flex; flex-direction: column; gap: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #speed-meter {
            width: 200px; height: 20px; background: rgba(0,0,0,0.5);
            border: 2px solid white; border-radius: 10px; overflow: hidden;
            margin-top: 5px;
        }
        #speed-bar {
            width: 0%; height: 100%; background: linear-gradient(90deg, #ffff00, #ff0000);
            transition: width 0.1s;
        }
        
        #controls-hint {
            position: absolute; bottom: 20px; right: 20px;
            background: rgba(0,0,0,0.6); padding: 15px;
            border-radius: 8px; color: #ccc; font-size: 0.9em;
            pointer-events: none; border: 1px solid rgba(255,255,255,0.1);
            display: flex; flex-direction: column; gap: 6px;
        }
        #controls-hint .row { display: flex; justify-content: space-between; align-items: center; width: 130px; }
        #controls-hint b { 
            color: #fff; background: rgba(255,255,255,0.15); 
            padding: 3px 6px; border-radius: 4px; 
            font-family: monospace; font-size: 0.9em;
            border-bottom: 2px solid rgba(0,0,0,0.5);
        }
        
        /* Ping indicator */
        #ping-indicator {
            position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.6);
            padding: 8px 12px; border-radius: 6px; color: white; font-size: 0.9em;
            display: none; align-items: center; gap: 8px;
        }
        .ping-dot { width: 8px; height: 8px; border-radius: 50%; animation: pulse 2s infinite; }
        .ping-good { background: #44cc44; } .ping-medium { background: #ffaa00; } .ping-bad { background: #ff4444; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        
        /* Notification */
        #notification-area {
            position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
            z-index: 150; display: flex; flex-direction: column; gap: 10px; pointer-events: none;
        }
        .notification {
            background: rgba(255, 68, 68, 0.9); color: white; padding: 12px 20px;
            border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideIn 0.3s, slideOut 0.3s 2.7s; min-width: 250px; text-align: center;
        }
        @keyframes slideIn { from { transform: translateY(-20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-20px); opacity: 0; } }
        
        /* Countdown overlay */
        #countdown-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7); z-index: 110;
            display: none; align-items: center; justify-content: center;
            color: white; font-size: 8em; font-weight: bold; text-shadow: 0 0 20px #ff00ff;
        }
        #countdown-overlay.go { color: #44cc44; text-shadow: 0 0 20px #44cc44; }
        
        #win-screen {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(30, 30, 30, 0.95); padding: 40px; border-radius: 20px;
            text-align: center; color: white; box-shadow: 0 0 50px rgba(0,0,0,0.5); z-index: 20;
            width: 400px; border: 2px solid #ff00ff;
        }
        #final-leaderboard {
            width: 100%; margin: 20px auto; background: rgba(0,0,0,0.3);
            border-radius: 10px; padding: 10px; max-height: 200px;
            overflow-y: auto; box-sizing: border-box;
        }
        .leaderboard-row {
            display: flex; justify-content: space-between; padding: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 1.1em;
        }
        .leaderboard-row:last-child { border-bottom: none; }
        #end-screen-controls { display: flex; justify-content: center; flex-wrap: wrap; gap: 10px; }
        #end-screen-controls button {
            background: #ff00ff; color: white; border: none; padding: 10px 20px;
            font-size: 1rem; border-radius: 10px; cursor: pointer; transition: transform 0.1s;
        }
        #end-screen-controls button:hover { background: #d400d4; transform: scale(1.05); }

        .mute-btn {
            position: absolute; bottom: 20px; left: 20px; z-index: 90;
            background: rgba(0,0,0,0.5); padding: 5px 10px; font-size: 0.8rem;
            pointer-events: auto !important; color: white; border: 1px solid white; border-radius: 4px;
        }
        
        #invite-btn {
            background: linear-gradient(135deg, #00ffff, #0088ff) !important;
            border: none !important; color: white !important;
            padding: 10px 20px !important; margin: 15px 0 !important;
            font-size: 1em !important; font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3); animation: glow 2s infinite;
        }
        #invite-btn:hover { transform: scale(1.05) !important; box-shadow: 0 6px 20px rgba(0, 255, 255, 0.5) !important; }
        @keyframes glow {
            0%, 100% { box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 4px 25px rgba(0, 255, 255, 0.6); }
        }
        #waiting-message { font-size: 1.1em; color: #ffaa00; margin: 15px 0; font-style: italic; }
        
        @media (max-width: 650px) {
            #character-creator { flex-direction: column; }
            .panel { width: 90%; }
            .action-row { flex-direction: column; gap: 15px; }
            .separator-vert { width: 100%; height: 1px; }
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div>Connecting to Cloud...</div>
        <div style="font-size: 0.5em; color: #888;">v9.2 Flow Edition</div>
    </div>
    
    <div id="notification-area"></div>
    <div id="countdown-overlay"></div>

    <!-- Lobby UI -->
    <div id="lobby-ui">
        <h1 style="margin-bottom: 0; text-shadow: 0 0 10px #ff00ff;">TUMBLE DUDES</h1>
        
        <div id="auth-status" style="margin-bottom: 10px; color: #00ffff; font-size: 0.9em;">Ready to Connect</div>

        <!-- Main Menu -->
        <div id="main-menu" class="panel">
            <input type="text" id="username-input" placeholder="ENTER USERNAME" maxlength="12">
            
            <!-- Character Creation UI -->
            <div id="character-creator">
                <!-- Left Column: Body Options -->
                <div class="cc-column">
                    <div class="creator-row">
                        <label>Skin</label>
                        <div class="selector-control">
                            <button class="arrow-btn" onclick="cycleOption('skin', -1)">‚óÄ</button>
                            <div id="swatch-skin" class="color-display"></div>
                            <button class="arrow-btn" onclick="cycleOption('skin', 1)">‚ñ∂</button>
                        </div>
                    </div>
                    <div class="creator-row">
                        <label>Hair</label>
                        <div class="selector-control">
                            <button class="arrow-btn" onclick="cycleOption('hair', -1)">‚óÄ</button>
                            <div id="swatch-hair" class="color-display"></div>
                            <button class="arrow-btn" onclick="cycleOption('hair', 1)">‚ñ∂</button>
                        </div>
                    </div>
                    <!-- New Hair Style Selector -->
                    <div class="creator-row">
                        <label>Style</label>
                        <div class="selector-control">
                            <button class="arrow-btn" onclick="cycleOption('hairStyle', -1)">‚óÄ</button>
                            <div id="text-hairStyle" class="color-display" style="width: 50px; font-size: 0.6em;">STD</div>
                            <button class="arrow-btn" onclick="cycleOption('hairStyle', 1)">‚ñ∂</button>
                        </div>
                    </div>
                </div>

                <!-- Center Column: Preview -->
                <div class="cc-column-center">
                    <div id="char-preview-container">
                        <!-- ThreeJS Canvas will be injected here -->
                    </div>
                    <button class="btn-secondary" onclick="randomizeCharacter()">üé≤ Randomize</button>
                </div>

                <!-- Right Column: Clothing Options -->
                <div class="cc-column">
                    <div class="creator-row">
                        <label>Shirt</label>
                        <div class="selector-control">
                            <button class="arrow-btn" onclick="cycleOption('shirt', -1)">‚óÄ</button>
                            <div id="swatch-shirt" class="color-display"></div>
                            <button class="arrow-btn" onclick="cycleOption('shirt', 1)">‚ñ∂</button>
                        </div>
                    </div>
                    <div class="creator-row">
                        <label>Pants</label>
                        <div class="selector-control">
                            <button class="arrow-btn" onclick="cycleOption('pants', -1)">‚óÄ</button>
                            <div id="swatch-pants" class="color-display"></div>
                            <button class="arrow-btn" onclick="cycleOption('pants', 1)">‚ñ∂</button>
                        </div>
                    </div>
                </div>
            </div>

            <div style="border-top: 1px solid #444; width: 100%; margin: 5px 0;"></div>

            <!-- Action Controls -->
            <div class="action-row">
                <div class="action-col">
                    <div style="font-size:0.8em; color:#888; text-transform:uppercase; letter-spacing:1px;">Start New</div>
                    <button class="btn-primary" onclick="createLobby()">HOST GAME</button>
                </div>
                
                <div class="separator-vert"></div>
                
                <div class="action-col" style="flex: 1.5;">
                    <div style="font-size:0.8em; color:#888; text-transform:uppercase; letter-spacing:1px;">Join Existing</div>
                    <div class="join-group">
                        <input type="text" id="code-input" placeholder="HOST CODE" style="background: rgba(0,0,0,0.3);">
                        <button class="btn-primary" onclick="joinLobby()">JOIN</button>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 15px; font-size: 0.7em; color: #666;">
                v9.2 - Flow Edition
            </div>
        </div>

        <!-- Wait Room -->
        <div id="wait-room" class="panel" style="display: none;">
            <h3 style="margin: 0; color: #ff00ff;">LOBBY CODE</h3>
            <div id="code-display"><span id="lobby-code-display">??????</span></div>
            <button id="invite-btn" class="btn-secondary" onclick="copyInviteLink()">üîó SHARE INVITE LINK</button>
            <div id="waiting-message" style="display: none;">‚è≥ Waiting for other players to join...</div>
            <div id="player-count">1 / 6 Players</div>
            <ul id="player-list">
                <!-- Players go here -->
            </ul>
            <button id="ready-btn" class="btn-primary" onclick="toggleReady()">‚úì READY UP</button>
            <button id="start-btn" class="btn-primary" onclick="hostStartGame()" style="display: none;">START RACE</button>
            <p id="wait-text" style="font-size: 0.8em; color: #aaa; margin-top: 10px;">Waiting for host...</p>
            <button class="btn-secondary" onclick="backToMenu()">Cancel</button>
        </div>
    </div>

    <!-- Game UI -->
    <div id="ui">
        <div id="hud-stats">
            <h1 style="margin:0;">TUMBLE DUDES</h1>
            <div id="rank">Rank: -- / --</div>
            <div id="speed-meter"><div id="speed-bar"></div></div>
        </div>
        
        <div id="controls-hint">
            <div class="row"><b>WASD</b> <span>Move</span></div>
            <div class="row"><b>SPACE</b> <span>Jump</span></div>
            <div class="row"><b>SHIFT</b> <span>Dash</span></div>
            <div class="row"><b>MOUSE</b> <span>Look</span></div>
        </div>
    </div>
    
    <div id="ping-indicator">
        <div class="ping-dot ping-good"></div>
        <span id="ping-text">-- ms</span>
    </div>

    <button class="mute-btn" onclick="toggleMusic()">üéµ Toggle Music</button>

    <div id="win-screen">
        <h2 id="win-text" style="color: #44cc44; margin-top:0;">FINISHED!</h2>
        <div id="final-leaderboard">
            <!-- Leaderboard Items Injected JS -->
        </div>
        <div id="end-screen-controls">
            <!-- Buttons injected JS -->
        </div>
    </div>

    <script>
        // --- COLOR PALETTES & OPTIONS ---
        const PALETTES = {
            skin: ['#ffccaa', '#8d5524', '#c68642', '#e0ac69', '#f1c27d', '#ffdbac', '#5c3a21', '#9eff9e', '#9ecaff', '#ca9eff'],
            hair: ['#442200', '#000000', '#e6be8a', '#8d5524', '#ff0000', '#aaaaaa', '#ffffff', '#00ff00', '#0000ff', '#ff00ff'],
            shirt: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#00ffff', '#ff00ff', '#ffffff', '#000000', '#ff8800', '#8800ff'],
            pants: ['#0000ff', '#000000', '#555555', '#ffffff', '#654321', '#004400', '#440000', '#ffcc00', '#00ffff', '#ff00ff']
        };

        const HAIR_STYLES = ['Standard', 'Spiky', 'Mohawk', 'Bob', 'Bald'];

        let myCostume = {
            skin: 0, // Indices now
            hair: 0,
            shirt: 0,
            pants: 0,
            hairStyle: 0
        };

        // --- PREVIEW VARIABLES ---
        let previewScene, previewCamera, previewRenderer, previewMesh;
        let isPreviewInit = false;

        function initPreview() {
            if(isPreviewInit) return;
            const container = document.getElementById('char-preview-container');
            const w = container.clientWidth;
            const h = container.clientHeight;

            previewScene = new THREE.Scene();
            previewScene.background = new THREE.Color(0x333333); // Dark grey background for preview

            previewCamera = new THREE.PerspectiveCamera(50, w / h, 0.1, 100);
            previewCamera.position.set(0, 1.2, 3);
            previewCamera.lookAt(0, 1, 0);

            previewRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            previewRenderer.setSize(w, h);
            previewRenderer.setClearColor(0x000000, 0); // Transparent
            container.appendChild(previewRenderer.domElement);

            // Lighting for preview
            const amb = new THREE.AmbientLight(0xffffff, 0.6);
            previewScene.add(amb);
            const dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(2, 5, 5);
            previewScene.add(dir);

            updatePreviewCharacter();
            animatePreview();
            isPreviewInit = true;
            
            // Mouse/Touch Rotation Control
            let isDragging = false;
            let previousMouseX = 0;
            
            container.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMouseX = e.clientX;
            });
            
            window.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            window.addEventListener('mousemove', (e) => {
                if(isDragging && previewMesh) {
                    const deltaX = e.clientX - previousMouseX;
                    previewMesh.rotation.y += deltaX * 0.01;
                    previousMouseX = e.clientX;
                }
            });
            
            // Initial UI Update
            updateSwatch('skin');
            updateSwatch('hair');
            updateSwatch('shirt');
            updateSwatch('pants');
            updateSwatch('hairStyle');
        }

        function updatePreviewCharacter() {
            if(previewMesh) {
                previewScene.remove(previewMesh);
            }
            // Get hex codes
            const costumeData = {
                skin: PALETTES.skin[myCostume.skin],
                hair: PALETTES.hair[myCostume.hair],
                shirt: PALETTES.shirt[myCostume.shirt],
                pants: PALETTES.pants[myCostume.pants],
                hairStyle: myCostume.hairStyle
            };
            
            previewMesh = createHumanoid(costumeData, null); // No name for preview
            previewMesh.position.set(0, 0, 0);
            previewScene.add(previewMesh);
        }

        function animatePreview() {
            requestAnimationFrame(animatePreview);
            // No auto-rotation anymore
            if(previewRenderer) {
                previewRenderer.render(previewScene, previewCamera);
            }
        }

        function cycleOption(type, dir) {
            let len;
            if(type === 'hairStyle') len = HAIR_STYLES.length;
            else len = PALETTES[type].length;
            
            myCostume[type] = (myCostume[type] + dir + len) % len;
            updateSwatch(type);
            updatePreviewCharacter();
        }

        function updateSwatch(type) {
            if(type === 'hairStyle') {
                document.getElementById('text-hairStyle').innerText = HAIR_STYLES[myCostume.hairStyle].substring(0,4).toUpperCase();
                return;
            }
            const color = PALETTES[type][myCostume[type]];
            document.getElementById(`swatch-${type}`).style.backgroundColor = color;
        }

        function randomizeCharacter() {
            ['skin', 'hair', 'shirt', 'pants'].forEach(type => {
                myCostume[type] = Math.floor(Math.random() * PALETTES[type].length);
                updateSwatch(type);
            });
            myCostume.hairStyle = Math.floor(Math.random() * HAIR_STYLES.length);
            updateSwatch('hairStyle');
            updatePreviewCharacter();
        }

        // --- PEERJS CONFIG ---
        let peer = null;
        let connections = [];
        let hostConn = null;
        
        let myId = null;
        let myUsername = "Bean";
        let isHost = false;
        
        // Ping tracking
        let lastPingTime = 0;
        let currentPing = 0;
        let pingHistory = [];
        
        // Game State Sync
        window.opponentsData = {};
        let myState = { x: 0, y: 0, z: 0, rot: 0, finished: false };

        // --- GAME VARS ---
        let scene, camera, renderer, world;
        let player, playerBody, playerMesh; 
        let opponents = {};
        let obstacles = [];
        let gameActive = false;
        let finishLinePos = new THREE.Vector3();
        // Commentary vars removed
        let playerMomentum = 20; 
        let hasFinished = false;
        
        // Dash Vars
        let dashVector = { x: 0, z: 0 };
        let canAirDash = true;
        let lastDashTime = 0;
        const DASH_COOLDOWN = 1000;
        
        // Checkpoint System
        let currentRespawnPos = { x: 0, y: 5, z: 0 };
        let checkpointPos = null;
        let checkpointActivated = false;
        window.checkpointFlagMat = null; 

        // Jump Vars
        let lastGroundedTime = 0;
        let backgroundObjects = [];
        let cameraAngle = 0;
        let isPointerLocked = false;
        let audioCtx;
        let isMuted = false;
        let noteIndex = 0;
        let isPlayingMusic = false;
        let currentTrack = null;
        const keys = { w: false, a: false, s: false, d: false, space: false };
        
        // Countdown state
        let isCountingDown = false;
        
        // Sound effect cooldowns
        let lastCollisionSound = 0;

        // Fixed timestep
        let lastPhysicsTime = performance.now();
        let accumulator = 0;
        const fixedTimeStep = 1/60; 
        const CAMERA_SMOOTHING_BASE = 0.9;
        let prevPlayerPos = { x: 0, y: 0, z: 0 };
        let prevObstacleStates = [];

        // Global Shadow Variables
        let sunLight;
        let playerShadow;
        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);

        // --- SOUND EFFECTS ---
        function playSoundEffect(type) {
            if (!audioCtx || isMuted) return;
            switch(type) {
                case 'jump': playTone(400, 0.1, 'sine', 0.15); setTimeout(() => playTone(600, 0.08, 'sine', 0.1), 50); break;
                case 'collision': playTone(100, 0.2, 'sawtooth', 0.2); break;
                case 'finish': playTone(523, 0.15, 'sine', 0.2); setTimeout(() => playTone(659, 0.15, 'sine', 0.2), 150); setTimeout(() => playTone(784, 0.3, 'sine', 0.2), 300); break;
                case 'countdown': playTone(800, 0.1, 'square', 0.15); break;
                case 'go': playTone(1000, 0.2, 'sine', 0.2); setTimeout(() => playTone(1200, 0.3, 'sine', 0.2), 100); break;
                case 'dash': playTone(300, 0.1, 'sawtooth', 0.2); setTimeout(() => playTone(600, 0.2, 'sine', 0.1), 50); break;
            }
        }

        // --- NOTIFICATION SYSTEM ---
        function showNotification(message, duration = 3000) {
            const notifArea = document.getElementById('notification-area');
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;
            notifArea.appendChild(notif);
            setTimeout(() => { notif.remove(); }, duration);
        }

        // --- NETWORK FUNCTIONS ---
        function createLobby() {
            if (typeof Peer === 'undefined') { alert('PeerJS library not loaded yet.'); return; }
            
            const username = document.getElementById('username-input').value || "Host Dude";
            myUsername = username;
            isHost = true;
            
            const code = Math.floor(1000 + Math.random() * 9000).toString();
            const peerId = "tumble-" + code;

            initPeer(peerId, code);
        }

        function joinLobby() {
            if (typeof Peer === 'undefined') { alert('PeerJS library not loaded yet.'); return; }
            
            const username = document.getElementById('username-input').value || "Guest Dude";
            myUsername = username;
            isHost = false;
            
            const code = document.getElementById('code-input').value;
            if(!code) { alert("Enter code!"); return; }
            
            initPeer(null, code);
        }

        function copyInviteLink() {
            const code = document.getElementById('lobby-code-display').innerText;
            if(!code || code === "??????") return;
            const baseUrl = window.location.href.split('?')[0];
            const url = baseUrl + '?code=' + code;
            navigator.clipboard.writeText(url).then(() => {
                const btn = document.getElementById('invite-btn');
                const orig = btn.innerText;
                btn.innerText = "‚úÖ LINK COPIED!";
                btn.style.background = "linear-gradient(135deg, #44cc44, #228822)";
                setTimeout(() => { btn.innerText = orig; btn.style.background = ""; }, 2000);
            }).catch(err => { alert("Invite Link: " + url); });
        }

        function initPeer(customId, lobbyCode) {
            document.getElementById('loading-overlay').style.display = 'flex';
            
            const connectionTimeout = setTimeout(() => {
                if(peer && !peer.id) {
                    document.getElementById('loading-overlay').style.display = 'none';
                    alert(`Connection timeout! Check firewall settings.`);
                    if(peer) peer.destroy();
                    peer = null;
                    backToMenu();
                }
            }, 15000);
            
            peer = new Peer(customId, {
                host: '0.peerjs.com', secure: true, port: 443, path: '/',
                config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' }] },
                debug: 1
            });

            peer.on('open', (id) => {
                clearTimeout(connectionTimeout);
                myId = id;
                document.getElementById('loading-overlay').style.display = 'none';
                
                // Construct the costume object with HEX values for network transmission
                const costumeToSend = {
                    skin: PALETTES.skin[myCostume.skin],
                    hair: PALETTES.hair[myCostume.hair],
                    shirt: PALETTES.shirt[myCostume.shirt],
                    pants: PALETTES.pants[myCostume.pants],
                    hairStyle: myCostume.hairStyle
                };
                
                if(isHost) {
                    enterLobbyUI(lobbyCode);
                    window.opponentsData[myId] = { username: myUsername, isHost: true, costume: costumeToSend, ready: false };
                    updateLobbyList();
                    startPingLoop();
                } else {
                    const hostId = "tumble-" + lobbyCode;
                    hostConn = peer.connect(hostId);
                    
                    hostConn.on('open', () => {
                        console.log("Connected to Host!");
                        hostConn.send({ type: 'join', username: myUsername, costume: costumeToSend });
                        enterLobbyUI(lobbyCode);
                        startPingLoop();
                    });

                    hostConn.on('data', handleDataFromHost);
                    hostConn.on('close', () => { showNotification("Host disconnected!"); setTimeout(() => backToMenu(), 2000); });
                    hostConn.on('error', (err) => { alert("Connection Error: " + err); backToMenu(); });
                }
            });

            peer.on('connection', (conn) => {
                if(!isHost) return;
                conn.on('open', () => {
                    connections.push(conn);
                    conn.send({ type: 'state_update', players: window.opponentsData });
                });
                conn.on('data', (data) => handleDataFromClient(data, conn.peer));
                conn.on('close', () => {
                    if(window.opponentsData[conn.peer]) showNotification(`${window.opponentsData[conn.peer].username} disconnected`);
                    delete window.opponentsData[conn.peer];
                    connections = connections.filter(c => c.peer !== conn.peer);
                    updateLobbyList();
                    broadcastState();
                });
            });

            peer.on('error', (err) => {
                clearTimeout(connectionTimeout);
                document.getElementById('loading-overlay').style.display = 'none';
                console.error('Peer error:', err);
                alert("Network Error: " + (err.type || err.message));
                backToMenu();
            });
        }

        // --- PING SYSTEM ---
        function startPingLoop() {
            setInterval(() => {
                if(!gameActive) return;
                lastPingTime = Date.now();
                if(isHost) {
                    connections.forEach(c => { c.send({ type: 'ping', timestamp: Date.now() }); });
                } else if(hostConn && hostConn.open) {
                    hostConn.send({ type: 'pong', timestamp: Date.now() });
                }
            }, 2000);
        }
        
        function updatePingDisplay() {
            if(!gameActive) return;
            const pingIndicator = document.getElementById('ping-indicator');
            const pingText = document.getElementById('ping-text');
            const pingDot = pingIndicator.querySelector('.ping-dot');
            pingIndicator.style.display = 'flex';
            pingText.textContent = `${currentPing} ms`;
            pingDot.className = 'ping-dot';
            if(currentPing < 100) pingDot.classList.add('ping-good');
            else if(currentPing < 200) pingDot.classList.add('ping-medium');
            else pingDot.classList.add('ping-bad');
        }

        // --- HOST LOGIC ---
        function handleDataFromClient(data, clientId) {
            if(data.type === 'join') {
                if(Object.keys(window.opponentsData).length >= 6) return;
                
                const costume = data.costume || { skin:'#ffccaa', hair:'#000000', shirt:'#888888', pants:'#333333', hairStyle: 0 };
                
                window.opponentsData[clientId] = { 
                    username: data.username, isHost: false, costume: costume, ready: false,
                    x: -5, y: 5, z: 0, rot: 0, finished: false
                };
                
                for (const pid in window.opponentsData) window.opponentsData[pid].ready = false;
                
                updateLobbyList();
                broadcastState();
            } else if (data.type === 'pos') {
                if(window.opponentsData[clientId]) Object.assign(window.opponentsData[clientId], data.state);
            } else if (data.type === 'ready') {
                if(window.opponentsData[clientId]) {
                    window.opponentsData[clientId].ready = data.ready;
                    updateLobbyList();
                    broadcastState();
                }
            } else if (data.type === 'pong') {
                // Keep-alive/ping
            }
        }

        function broadcastState() {
            const msg = { type: 'state_update', players: window.opponentsData };
            connections.forEach(c => c.send(msg));
        }

        // --- CLIENT LOGIC ---
        function handleDataFromHost(data) {
            if (data.type === 'state_update') {
                window.opponentsData = data.players;
                updateLobbyList();
            } else if (data.type === 'start_game') {
                startCountdown(data.level);
            } else if (data.type === 'ping') {
                const rtt = Date.now() - data.timestamp;
                currentPing = rtt;
                updatePingDisplay();
                if(hostConn && hostConn.open) hostConn.send({ type: 'pong', timestamp: data.timestamp });
            }
        }

        // --- UI FUNCS ---
        function enterLobbyUI(code) {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('wait-room').style.display = 'flex';
            document.getElementById('lobby-code-display').innerText = code;
            const startBtn = document.getElementById('start-btn');
            const waitText = document.getElementById('wait-text');
            if(isHost) {
                startBtn.style.display = 'block'; waitText.style.display = 'none';
            } else {
                startBtn.style.display = 'none'; waitText.style.display = 'block';
            }
        }

        function updateLobbyList() {
            const list = document.getElementById('player-list');
            const waitingMsg = document.getElementById('waiting-message');
            const startBtn = document.getElementById('start-btn');
            const readyBtn = document.getElementById('ready-btn');
            
            list.innerHTML = '';
            let count = 0; let allReady = true;
            
            for(const pid in window.opponentsData) {
                const p = window.opponentsData[pid];
                const li = document.createElement('li');
                
                // Show shirt color as icon
                const icon = document.createElement('span');
                icon.className = 'player-icon';
                const shirtC = (p.costume && p.costume.shirt) ? p.costume.shirt : '#888';
                icon.style.backgroundColor = shirtC;
                li.appendChild(icon);

                const nameSpan = document.createElement('span');
                const readyIcon = p.ready ? '‚úì ' : '';
                nameSpan.innerText = `${readyIcon}${p.username} ${p.isHost ? 'üëë' : ''}`;
                nameSpan.style.color = p.ready ? '#44cc44' : '#ffffff';
                li.appendChild(nameSpan);
                list.appendChild(li);
                count++;
                if (!p.ready) allReady = false;
            }
            
            document.getElementById('player-count').innerText = `${count} / 6 Players`;
            const myData = window.opponentsData[myId];
            if (myData && myData.ready) {
                readyBtn.innerText = '‚úó UNREADY'; readyBtn.style.background = '#cc4444';
            } else {
                readyBtn.innerText = '‚úì READY UP'; readyBtn.style.background = '#44cc44';
            }
            
            if (isHost) {
                if (count === 1) {
                    readyBtn.style.display = 'none'; startBtn.style.display = 'block'; startBtn.disabled = false;
                } else {
                    readyBtn.style.display = 'block'; startBtn.style.display = 'block'; startBtn.disabled = !allReady;
                }
            } else {
                readyBtn.style.display = 'block'; startBtn.style.display = 'none';
            }
            waitingMsg.style.display = (isHost && count === 1) ? 'block' : 'none';
        }

        function toggleReady() {
            if (!myId || !window.opponentsData[myId]) return;
            const newReadyState = !window.opponentsData[myId].ready;
            window.opponentsData[myId].ready = newReadyState;
            if (isHost) { updateLobbyList(); broadcastState(); }
            else if (hostConn && hostConn.open) { hostConn.send({ type: 'ready', ready: newReadyState }); updateLobbyList(); }
        }

        // --- COUNTDOWN SYSTEM ---
        function startCountdown(level) {
            if(isCountingDown) return;
            isCountingDown = true;
            document.getElementById('lobby-ui').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            window.startMultiplayerGame(level, false); 
            const overlay = document.getElementById('countdown-overlay');
            overlay.style.display = 'flex';
            let count = 3;
            overlay.textContent = count;
            overlay.classList.remove('go');
            playSoundEffect('countdown');
            const countInterval = setInterval(() => {
                count--;
                if(count > 0) {
                    overlay.textContent = count; playSoundEffect('countdown');
                } else {
                    overlay.textContent = 'GO!'; overlay.classList.add('go'); playSoundEffect('go');
                    window.gameActive = true; gameActive = true;
                    setTimeout(() => { overlay.style.display = 'none'; isCountingDown = false; }, 1000);
                    clearInterval(countInterval);
                }
            }, 1000);
        }

        window.hostStartGame = function() {
            if(!isHost || isCountingDown) return;
            const level = window.generateRandomLevelStructure(); 
            const msg = { type: 'start_game', level: level };
            connections.forEach(c => c.send(msg));
            startCountdown(level);
        }

        window.backToMenu = function() {
            if(peer) peer.destroy();
            peer = null; connections = []; hostConn = null; window.opponentsData = {};
            document.getElementById('win-screen').style.display = 'none';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('ping-indicator').style.display = 'none';
            document.getElementById('lobby-ui').style.display = 'flex';
            document.getElementById('main-menu').style.display = 'flex';
            document.getElementById('wait-room').style.display = 'none';
            document.getElementById('loading-overlay').style.display = 'none';
            window.gameActive = false; gameActive = false; isCountingDown = false;
            window.clearLevel(); window.changeMusicTrack();
        }

        setInterval(() => {
            if(!window.gameActive || !myId) return;
            if(window.playerBody) {
                myState = {
                    x: parseFloat(window.playerBody.position.x.toFixed(2)),
                    y: parseFloat(window.playerBody.position.y.toFixed(2)),
                    z: parseFloat(window.playerBody.position.z.toFixed(2)),
                    rot: parseFloat(window.playerMesh.rotation.y.toFixed(2)),
                    finished: window.hasFinished
                };
            }
            if(isHost) {
                if(window.opponentsData[myId]) Object.assign(window.opponentsData[myId], myState);
                broadcastState();
            } else if (hostConn && hostConn.open) {
                hostConn.send({ type: 'pos', state: myState });
            }
        }, 50);

        window.createLobby = createLobby;
        window.joinLobby = joinLobby;
        window.hostStartGame = hostStartGame;
        window.toggleReady = toggleReady;
        window.copyInviteLink = copyInviteLink;
        window.backToMenu = backToMenu;

        function waitForLibraries() {
            return new Promise((resolve) => {
                const statusDiv = document.getElementById('auth-status');
                statusDiv.innerText = 'Loading libraries...'; statusDiv.style.color = '#ffaa00';
                const checkLibraries = () => {
                    if (typeof THREE !== 'undefined' && typeof CANNON !== 'undefined' && typeof Peer !== 'undefined') {
                        statusDiv.innerText = 'Ready to Connect ‚úì'; statusDiv.style.color = '#44cc44'; resolve();
                    } else { setTimeout(checkLibraries, 100); }
                };
                checkLibraries();
            });
        }

        function createShadowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(0, 0, 0, 0.6)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        async function init() {
            await waitForLibraries();
            
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            if(code) { document.getElementById('code-input').value = code; document.getElementById('username-input').focus(); }

            // Init Preview
            initPreview();

            // Main Game Scene Init
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x6a0dad); 
            scene.fog = new THREE.FogExp2(0x6a0dad, 0.006);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.5); scene.add(ambient);
            
            // Replaced static sun with dynamic global var
            sunLight = new THREE.DirectionalLight(0xffaa00, 0.8);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            // Optimize shadow map for gameplay
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            const d = 40;
            sunLight.shadow.camera.left = -d;
            sunLight.shadow.camera.right = d;
            sunLight.shadow.camera.top = d;
            sunLight.shadow.camera.bottom = -d;
            scene.add(sunLight);

            // Create Blob Shadow
            const shadowGeo = new THREE.PlaneGeometry(1.2, 1.2);
            const shadowMat = new THREE.MeshBasicMaterial({ 
                map: createShadowTexture(), 
                transparent: true, 
                opacity: 0.6,
                depthWrite: false
            });
            playerShadow = new THREE.Mesh(shadowGeo, shadowMat);
            playerShadow.rotation.x = -Math.PI / 2;
            playerShadow.visible = false;
            scene.add(playerShadow);

            const purpleLight = new THREE.PointLight(0xff00ff, 0.8, 200);
            purpleLight.position.set(50, 50, 50); scene.add(purpleLight);

            world = new CANNON.World();
            world.gravity.set(0, -30, 0); 
            world.broadphase = new CANNON.NaiveBroadphase();
            
            const defaultMaterial = new CANNON.Material('default');
            const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, { friction: 0.7, restitution: 0.3 });
            world.addContactMaterial(defaultContactMaterial);

            createBackgroundScenery(); 
            
            window.addEventListener('keydown', (e) => { 
                let key = e.key.toLowerCase(); if (key === ' ') key = 'space'; 
                if (key === 'shift') attemptDash();
                if(keys.hasOwnProperty(key)) keys[key] = true; 
            });
            window.addEventListener('keyup', (e) => { 
                let key = e.key.toLowerCase(); if (key === ' ') key = 'space';
                if(keys.hasOwnProperty(key)) keys[key] = false; 
            });
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('click', () => {
                if (!audioCtx) initAudio();
                if (window.gameActive && !isPointerLocked && !isCountingDown) document.body.requestPointerLock();
            });
            document.addEventListener('pointerlockchange', () => { isPointerLocked = document.pointerLockElement === document.body; });
            document.addEventListener('mousemove', (e) => { if (isPointerLocked) cameraAngle += e.movementX * 0.002; });
            
            animate();
        }
        
        function attemptDash() {
            if (!gameActive || !playerBody) return;
            const now = Date.now();
            if (now - lastDashTime < DASH_COOLDOWN) return;

            // Check conditions
            const isGrounded = (now - lastGroundedTime < 200);

            if (!isGrounded && !canAirDash) return;

            // Perform Dash
            lastDashTime = now;
            if (!isGrounded) canAirDash = false;

            let dx = 0, dz = 0;
            // Calculate direction based on keys pressed relative to camera
            const fwdX = Math.cos(cameraAngle); const fwdZ = Math.sin(cameraAngle);
            const rightX = -Math.sin(cameraAngle); const rightZ = Math.cos(cameraAngle);

            let hasInput = false;
            if(keys.w) { dx += fwdX; dz += fwdZ; hasInput = true; }
            if(keys.s) { dx -= fwdX; dz -= fwdZ; hasInput = true; }
            if(keys.a) { dx -= rightX; dz -= rightZ; hasInput = true; }
            if(keys.d) { dx += rightX; dz += rightZ; hasInput = true; }

            if (!hasInput) {
                // Dash forward if no keys
                dx = fwdX; dz = fwdZ;
            } else {
                // Normalize
                const len = Math.sqrt(dx*dx + dz*dz);
                dx /= len; dz /= len;
            }

            const DASH_SPEED = 60;
            dashVector.x = dx * DASH_SPEED;
            dashVector.z = dz * DASH_SPEED;

            // Vertical pop for air dash or ground dash to avoid friction
            playerBody.velocity.y = 5;

            playSoundEffect('dash');
        }

        window.startMultiplayerGame = function(levelSegments, activate = true) {
            document.getElementById('win-screen').style.display = 'none';
            clearLevel(); createBackgroundScenery(); buildLevelFromSegments(levelSegments); 
            
            // Generate costume from HEX values since game logic now uses HEX
            const costumeHex = {
                skin: PALETTES.skin[myCostume.skin],
                hair: PALETTES.hair[myCostume.hair],
                shirt: PALETTES.shirt[myCostume.shirt],
                pants: PALETTES.pants[myCostume.pants],
                hairStyle: myCostume.hairStyle
            };
            
            createPlayer(costumeHex);
            
            if(activate) { window.gameActive = true; gameActive = true; }
            window.hasFinished = false; hasFinished = false;
            if (!audioCtx) initAudio();
            window.changeMusicTrack(); 
            // Commentary call removed
        }

        const musicTracks = [
            { name: "Funky Bean", tempo: 250, bass: [110, 110, 130, 146, 110, 110, 98, 98], melody: [440, 0, 523, 440, 0, 587, 523, 0], bassType: 'triangle', melodyType: 'square' },
            { name: "Hyper Space", tempo: 200, bass: [65, 0, 65, 0, 73, 0, 73, 0], melody: [523, 523, 784, 0, 659, 0, 523, 0], bassType: 'sawtooth', melodyType: 'sawtooth' },
            { name: "Retro Dash", tempo: 280, bass: [87, 87, 98, 98, 110, 110, 130, 0], melody: [698, 0, 659, 0, 587, 587, 523, 0], bassType: 'square', melodyType: 'triangle' }
        ];
        window.changeMusicTrack = function() { currentTrack = musicTracks[Math.floor(Math.random() * musicTracks.length)]; }
        currentTrack = musicTracks[0];

        function initAudio() {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                if(audioCtx.state === 'suspended') audioCtx.resume();
                startMusicLoop();
            } catch(e) { console.error("Audio init failed", e); }
        }

        function toggleMusic() {
            isMuted = !isMuted;
            if(isMuted && audioCtx) audioCtx.suspend();
            if(!isMuted && audioCtx) audioCtx.resume();
        }

        function playTone(freq, duration, type='sine', vol=0.1) {
            if (!audioCtx || isMuted) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + duration);
        }

        function startMusicLoop() {
            if(isPlayingMusic) return;
            isPlayingMusic = true;
            const loop = () => {
                if(!audioCtx || isMuted || audioCtx.state !== 'running') { setTimeout(loop, 250); return; }
                const track = currentTrack;
                playTone(track.bass[noteIndex % 8], 0.2, track.bassType, 0.15);
                if(track.melody[noteIndex % 8] !== 0) playTone(track.melody[noteIndex % 8], 0.1, track.melodyType, 0.05);
                if(noteIndex % 2 === 0) playTone(2000 + Math.random()*500, 0.05, 'sawtooth', 0.02);
                noteIndex++;
                setTimeout(loop, track.tempo);
            };
            loop();
        }

        function generateSkyboxTexture(theme) {
            const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 512;
            const ctx = canvas.getContext('2d'); const w = canvas.width; const h = canvas.height;
            if (theme === 0) {
                const grad = ctx.createLinearGradient(0, 0, 0, h); grad.addColorStop(0, '#000000'); grad.addColorStop(1, '#220033');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h); ctx.fillStyle = '#ffffff';
                for(let i=0; i<400; i++) { ctx.beginPath(); ctx.arc(Math.random()*w, Math.random()*h, Math.random()*1.5, 0, Math.PI*2); ctx.fill(); }
            } else if (theme === 1) {
                const grad = ctx.createLinearGradient(0, 0, 0, h); grad.addColorStop(0, '#00BFFF'); grad.addColorStop(1, '#FFFFFF');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
            } else if (theme === 2) {
                const grad = ctx.createLinearGradient(0, 0, 0, h); grad.addColorStop(0, '#4B0082'); grad.addColorStop(0.5, '#FF4500'); grad.addColorStop(1, '#FFD700');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
            } else {
                const grad = ctx.createLinearGradient(0, 0, 0, h); grad.addColorStop(0, '#000000'); grad.addColorStop(1, '#001133');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h); ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)'; ctx.lineWidth = 3;
                for(let i=0; i<w; i+=150) { ctx.beginPath(); ctx.moveTo(w/2, h/2); ctx.lineTo(i, h); ctx.stroke(); }
            }
            return new THREE.CanvasTexture(canvas);
        }

        function createBackgroundScenery() {
            backgroundObjects.forEach(obj => scene.remove(obj)); backgroundObjects = [];
            const theme = Math.floor(Math.random() * 4);
            if (theme === 0) scene.background = new THREE.Color(0x110022);
            else if (theme === 1) scene.background = new THREE.Color(0x87CEFA);
            else if (theme === 2) scene.background = new THREE.Color(0x4B0082);
            else scene.background = new THREE.Color(0x001133);
            const texture = generateSkyboxTexture(theme);
            const geo = new THREE.SphereGeometry(800, 60, 40);
            const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide, fog: false });
            const skybox = new THREE.Mesh(geo, mat); scene.add(skybox); backgroundObjects.push(skybox);
        }

        // --- LEVEL THEME SYSTEM ---
        const LEVEL_THEMES = [
            { name: 'neon',    primary: 0xff00ff, secondary: 0x00ffff, accent: 0xffff00, floor1: 0x222244, floor2: 0x1a1a3a, wall: 0x8800ff },
            { name: 'lava',    primary: 0xff4400, secondary: 0xff8800, accent: 0xffcc00, floor1: 0x553333, floor2: 0x442222, wall: 0xcc2200 },
            { name: 'ice',     primary: 0x66ccff, secondary: 0xaaeeff, accent: 0xffffff, floor1: 0xbbddee, floor2: 0x99ccdd, wall: 0x4488aa },
            { name: 'jungle',  primary: 0x22cc44, secondary: 0x88ee44, accent: 0xddaa33, floor1: 0x445533, floor2: 0x334422, wall: 0x226622 },
            { name: 'cyber',   primary: 0x00ff88, secondary: 0xff0088, accent: 0x00aaff, floor1: 0x111111, floor2: 0x1a1a1a, wall: 0x00cc66 },
            { name: 'candy',   primary: 0xff66aa, secondary: 0x66ffcc, accent: 0xffee44, floor1: 0xffccdd, floor2: 0xeebbcc, wall: 0xff4488 },
            { name: 'desert',  primary: 0xddaa44, secondary: 0xcc8833, accent: 0xff6622, floor1: 0xccbb88, floor2: 0xbbaa77, wall: 0xaa7733 },
            { name: 'space',   primary: 0x6644ff, secondary: 0x44aaff, accent: 0xff44ff, floor1: 0x222233, floor2: 0x191928, wall: 0x5533cc }
        ];

        // --- REWORKED SMART GENERATOR LOGIC ---
        window.generateRandomLevelStructure = function() {
            const easy = ['path', 'walls', 'arch_jump', 'gap_jump', 'zigzag'];
            const medium = ['narrow', 'tilts', 'steps_up', 'steps_down', 'ramp_up', 'ramp_down', 'floating_islands', 'pillars', 's_curve', 'drop_ledges'];
            const hard = ['hammers', 'split_hammers_walls', 'split_ramp_tunnel', 'rotating_disc', 'moving_platforms', 'low_spinners', 'punch_wall', 'wave_platforms', 'bumper_alley', 'pendulum_gauntlet', 'spinner_corridor'];

            // Pick a random theme for this level
            const theme = LEVEL_THEMES[Math.floor(Math.random() * LEVEL_THEMES.length)];

            const level = ['start'];
            let segmentsSinceTurn = 0;
            let currentElevation = 0;
            let lastSegType = 'start';
            const usedRecently = [];

            // Level is divided into zones for variety
            const zoneCount = 4 + Math.floor(Math.random() * 3); // 4-6 zones
            const segmentsPerZone = 6 + Math.floor(Math.random() * 5); // 6-10 per zone

            for (let zone = 0; zone < zoneCount; zone++) {
                // Each zone has a rising difficulty curve
                const zoneDifficulty = zone / Math.max(zoneCount - 1, 1); // 0..1

                // Add a turn between zones (except before first zone)
                if (zone > 0) {
                    // Only add zone transition turn if the previous segment wasn't a turn
                    if (!lastSegType.includes('turn')) {
                        const turnDir = zone % 2 === 0 ? 'turn_left' : 'turn_right';
                        level.push(turnDir);
                    }
                    level.push('path');
                    segmentsSinceTurn = 0;
                    lastSegType = 'path';
                    usedRecently.length = 0;
                }

                for (let s = 0; s < segmentsPerZone; s++) {
                    const progress = s / segmentsPerZone; // 0..1 within zone
                    let next = 'path';

                    // Force turn after 4-6 straight segments (but never consecutive turns)
                    const turnThreshold = 4 + Math.floor(Math.random() * 3);
                    if (segmentsSinceTurn >= turnThreshold && !lastSegType.includes('ramp') && !lastSegType.includes('steps') && !lastSegType.includes('turn')) {
                        next = Math.random() > 0.5 ? 'turn_left' : 'turn_right';
                    }
                    // After a turn, always place a path buffer
                    else if (lastSegType === 'turn_left' || lastSegType === 'turn_right') {
                        next = 'path';
                        segmentsSinceTurn = 0;
                    }
                    else {
                        // Pick difficulty tier based on zone progress
                        const effectiveDiff = zoneDifficulty * 0.5 + progress * 0.5;
                        const r = Math.random();
                        let pool;

                        if (effectiveDiff < 0.33) {
                            pool = r < 0.5 ? medium : easy;
                        } else if (effectiveDiff < 0.66) {
                            pool = r < 0.6 ? hard : (r < 0.85 ? medium : easy);
                        } else {
                            pool = r < 0.75 ? hard : (r < 0.95 ? medium : easy);
                        }

                        // Pick from pool, avoid repeats of last 3 segments
                        let attempts = 0;
                        do {
                            next = pool[Math.floor(Math.random() * pool.length)];
                            attempts++;
                        } while (usedRecently.includes(next) && attempts < 10);
                    }

                    // Elevation control: don't go too high or too low
                    if ((next === 'ramp_up' || next === 'steps_up') && currentElevation >= 3) {
                        next = (Math.random() > 0.5) ? 'ramp_down' : 'steps_down';
                    }
                    if ((next === 'ramp_down' || next === 'steps_down' || next === 'drop_ledges') && currentElevation <= -2) {
                        next = (Math.random() > 0.5) ? 'ramp_up' : 'steps_up';
                    }
                    if (next === 'ramp_up' || next === 'steps_up') currentElevation++;
                    if (next === 'ramp_down' || next === 'steps_down' || next === 'drop_ledges') currentElevation--;

                    level.push(next);
                    lastSegType = next;
                    usedRecently.push(next);
                    if (usedRecently.length > 3) usedRecently.shift();
                    if (next !== 'turn_left' && next !== 'turn_right') segmentsSinceTurn++;
                    else segmentsSinceTurn = 0;
                }
            }

            // Bring elevation back to roughly 0 before finish
            while (currentElevation > 1) { level.push('ramp_down'); currentElevation--; }
            while (currentElevation < -1) { level.push('ramp_up'); currentElevation++; }

            level.push('finish');
            // Attach theme data to the array for buildLevelFromSegments to use
            level.theme = theme;
            return level;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // updateCommentary function removed

        let levelObjects = [];
        let currentPos = { x: -5, y: -0.5, z: 0 };
        let levelMinY = -0.5;

        // Base create functions used by the helper
        function createBox(w, h, d, x, y, z, color, mass=0, rotX=0, rotY=0, rotZ=0) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshPhongMaterial({ color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z); mesh.rotation.set(rotX, rotY, rotZ);
            mesh.castShadow = true; mesh.receiveShadow = true; scene.add(mesh);
            const shape = new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2));
            const body = new CANNON.Body({ mass: mass, material: world.defaultMaterial });
            body.addShape(shape); body.position.set(x, y, z);
            const q = new CANNON.Quaternion(); q.setFromEuler(rotX, rotY, rotZ); body.quaternion.copy(q);
            world.addBody(body);
            const obj = { mesh, body, type: 'static' }; levelObjects.push(obj); return obj;
        }

        function createCylinder(radiusTop, radiusBottom, height, x, y, z, color, mass=0, rotX=0, rotY=0, rotZ=0) {
            const segments = 16;
            const geo = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, segments);
            const mat = new THREE.MeshPhongMaterial({ color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z); mesh.rotation.set(rotX, rotY, rotZ);
            mesh.castShadow = true; mesh.receiveShadow = true; scene.add(mesh);
            const shape = new CANNON.Cylinder(radiusTop, radiusBottom, height, segments);
            // Cannon cylinders are oriented along Z, ThreeJS along Y
            const body = new CANNON.Body({ mass: mass, material: world.defaultMaterial });
            const qShape = new CANNON.Quaternion(); qShape.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
            body.addShape(shape, new CANNON.Vec3(0,0,0), qShape);
            
            body.position.set(x, y, z);
            const q = new CANNON.Quaternion(); q.setFromEuler(rotX, rotY, rotZ); body.quaternion.copy(q);
            world.addBody(body);
            const obj = { mesh, body, type: 'static' }; levelObjects.push(obj); return obj;
        }

        window.clearLevel = function() {
            levelObjects.forEach(obj => { scene.remove(obj.mesh); world.removeBody(obj.body); });
            levelObjects = []; obstacles = []; prevObstacleStates = []; currentPos = { x: -5, y: -0.5, z: 0 }; levelMinY = -0.5;
            currentRespawnPos = { x: 0, y: 5, z: 0 }; checkpointPos = null; checkpointActivated = false; window.checkpointFlagMat = null;
            if(player) { scene.remove(player.mesh); world.removeBody(player.body); player = null; window.playerBody = null; window.playerMesh = null; }
            if(playerShadow) playerShadow.visible = false;
            for(let uid in opponents) { scene.remove(opponents[uid].mesh); }
            opponents = {};
        }

        // Modified build logic using rotation
        function buildLevelFromSegments(segments) {
            currentPos = { x: -5, y: -0.5, z: 0 }; 
            levelMinY = -0.5;
            let currentAngle = 0; // 0 = +X, PI/2 = +Z, etc.

            // Helpers for relative placement
            // localX = distance along path, localZ = distance sideways (right is positive)
            function transform(localX, localY, localZ, localRotY = 0) {
                const ca = Math.cos(currentAngle);
                const sa = Math.sin(currentAngle);
                
                // Rotate offset
                const rx = localX * ca - localZ * sa;
                const rz = localX * sa + localZ * ca;
                
                return {
                    x: currentPos.x + rx,
                    y: currentPos.y + localY,
                    z: currentPos.z + rz,
                    rotY: localRotY + currentAngle
                };
            }

            function addBoxRelative(w, h, d, lx, ly, lz, color, mass=0, lRotX=0, lRotY=0, lRotZ=0) {
                const t = transform(lx, ly, lz, lRotY);
                return createBox(w, h, d, t.x, t.y, t.z, color, mass, lRotX, t.rotY, lRotZ);
            }

            // Special wrapper for ramps that handles the axis swap
            function addRamp(w, h, d, lx, ly, lz, color, slopeAngle) {
                const t = transform(lx, ly, lz, 0);
                // Rotate slope around Z then Y
                const qSlope = new CANNON.Quaternion();
                qSlope.setFromAxisAngle(new CANNON.Vec3(0,0,1), slopeAngle);
                const qTurn = new CANNON.Quaternion();
                qTurn.setFromAxisAngle(new CANNON.Vec3(0,1,0), -currentAngle);
                const qFinal = qTurn.mult(qSlope);
                
                // Create manual object to bypass Euler restrictions of createBox
                const geo = new THREE.BoxGeometry(w, h, d);
                const mat = new THREE.MeshPhongMaterial({ color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(t.x, t.y, t.z);
                mesh.quaternion.copy(qFinal);
                mesh.castShadow = true; mesh.receiveShadow = true; scene.add(mesh);
                
                const shape = new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2));
                const body = new CANNON.Body({ mass: 0, material: world.defaultMaterial });
                body.addShape(shape); body.position.set(t.x, t.y, t.z);
                body.quaternion.copy(qFinal);
                world.addBody(body);
                levelObjects.push({ mesh, body, type: 'static' });
            }

            const midIndex = Math.floor(segments.length / 2);

            // Resolve theme: use attached theme or pick a random one
            const theme = segments.theme || LEVEL_THEMES[Math.floor(Math.random() * LEVEL_THEMES.length)];

            segments.forEach((seg, index) => {
                const baseColor = index % 2 === 0 ? theme.floor1 : theme.floor2;
                
                // Checkpoint Logic
                if (index === midIndex) {
                    const ckPos = transform(10, 0, 0); // 10 units forward
                    checkpointPos = { x: ckPos.x, y: ckPos.y + 2, z: ckPos.z }; 
                    
                    // Visuals
                    const pPos = transform(10, 5, -12); // Pole
                    const fPos = transform(12, 8, -12); // Flag
                    
                    // Pole
                    const poleGeo = new THREE.CylinderGeometry(0.5, 0.5, 10);
                    const poleMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
                    const pole = new THREE.Mesh(poleGeo, poleMat); 
                    pole.position.set(pPos.x, pPos.y, pPos.z); scene.add(pole);
                    levelObjects.push({ mesh: pole, body: new CANNON.Body({mass:0}) });
                    
                    // Flag
                    const flagGeo = new THREE.BoxGeometry(4, 3, 0.5);
                    const flagMat = new THREE.MeshPhongMaterial({ color: 0xff0000 }); 
                    window.checkpointFlagMat = flagMat;
                    const flag = new THREE.Mesh(flagGeo, flagMat); 
                    flag.position.set(fPos.x, fPos.y, fPos.z); 
                    flag.rotation.y = currentAngle;
                    scene.add(flag);
                    levelObjects.push({ mesh: flag, body: new CANNON.Body({mass:0}) });

                    addBoxRelative(25, 1, 25, 10, -0.2, 0, 0x66ff66);
                }

                switch(seg) {
                    case 'start': 
                        addBoxRelative(15, 1, 20, 7.5, 0, 0, 0x44cc44); 
                        currentPos = transform(15, 0, 0);
                        break;
                        
                    case 'turn_left':
                        // Landing pad
                        addBoxRelative(20, 1, 20, 10, 0, 0, baseColor);
                        // Move cursor to center of pad
                        currentPos = transform(10, 0, 0);
                        // Rotate
                        currentAngle -= Math.PI/2;
                        // Move cursor out of pad in new direction
                        currentPos = transform(10, 0, 0);
                        break;

                    case 'turn_right':
                        addBoxRelative(20, 1, 20, 10, 0, 0, baseColor);
                        currentPos = transform(10, 0, 0);
                        currentAngle += Math.PI/2;
                        currentPos = transform(10, 0, 0);
                        break;

                    case 'path': 
                        addBoxRelative(30, 1, 10, 15, 0, 0, baseColor); 
                        currentPos = transform(30, 0, 0);
                        break;

                    case 'narrow': 
                        // Widened to 4 units for better flow
                        addBoxRelative(20, 1, 4, 10, 0, 0, theme.accent); 
                        currentPos = transform(20, 0, 0);
                        break;

                    case 'ramp_up': { 
                        const rampLen = 30; const rise = 10; 
                        const angle = Math.atan2(rise, rampLen); 
                        const hyp = Math.sqrt(rampLen*rampLen + rise*rise); 
                        addRamp(hyp, 1, 10, rampLen/2, rise/2, 0, theme.primary, angle);
                        currentPos = transform(rampLen, rise, 0);
                        break; 
                    }
                    case 'ramp_down': { 
                        const rampLenD = 30; const drop = 10; 
                        const angleD = -Math.atan2(drop, rampLenD); 
                        const hypD = Math.sqrt(rampLenD*rampLenD + drop*drop); 
                        addRamp(hypD, 1, 10, rampLenD/2, -drop/2, 0, theme.secondary, angleD);
                        currentPos = transform(rampLenD, -drop, 0);
                        break; 
                    }
                    
                    case 'walls': 
                        addBoxRelative(25, 1, 10, 12.5, 0, 0, baseColor);
                        addBoxRelative(1, 4, 10, 8, 2, 0, theme.wall);
                        addBoxRelative(1, 4, 10, 16, 2, 0, theme.wall);
                        currentPos = transform(25, 0, 0);
                        break;

                    case 'hammers': { 
                        addBoxRelative(25, 1, 10, 12.5, 0, 0, baseColor);
                        addBoxRelative(1, 6, 1, 12.5, 3, 0, theme.wall);
                        const t = transform(12.5, 6, 0);
                        const hammer = createBox(8, 1, 1, t.x, t.y, t.z, theme.primary, 10, 0, currentAngle, 0);
                        hammer.body.type = CANNON.Body.KINEMATIC; 
                        obstacles.push({ ...hammer, type: 'spinner', speed: 4 }); 
                        currentPos = transform(25, 0, 0);
                        break; 
                    }

                    case 'tilts': { 
                        for(let i=0; i<2; i++) { 
                            const t = transform(8 + (i*10), 0.5, 0);
                            const p = createBox(8, 0.5, 8, t.x, t.y, t.z, theme.secondary, 10, 0, currentAngle, 0); 
                            p.body.type = CANNON.Body.KINEMATIC; 
                            obstacles.push({ ...p, type: 'tilt', speed: 2, offset: i, levelAngle: currentAngle }); 
                        } 
                        currentPos = transform(25, 0, 0);
                        break; 
                    }

                    case 'split_hammers_walls': { 
                        // Safety Hub
                        addBoxRelative(5, 1, 20, 2.5, 0, 0, baseColor);
                        
                        // Left path
                        addBoxRelative(40, 1, 8, 25, 0, -8, baseColor); // Centered at 25 relative
                        // Right path
                        addBoxRelative(40, 1, 8, 25, 0, 8, baseColor);
                        
                        // Spinner Left
                        const t1 = transform(15, 6, -8);
                        const h1 = createBox(8, 1, 1, t1.x, t1.y, t1.z, theme.primary, 10, 0, currentAngle, 0);
                        h1.body.type = CANNON.Body.KINEMATIC;
                        obstacles.push({ ...h1, type: 'spinner', speed: 5 });
                        
                        // Spinner Left 2
                        const t2 = transform(35, 6, -8);
                        const h2 = createBox(8, 1, 1, t2.x, t2.y, t2.z, theme.primary, 10, 0, currentAngle, 0);
                        h2.body.type = CANNON.Body.KINEMATIC;
                        obstacles.push({ ...h2, type: 'spinner', speed: -5 });

                        // Walls Right
                        addBoxRelative(1, 4, 8, 15, 2, 8, theme.wall);
                        addBoxRelative(1, 4, 8, 25, 2, 8, theme.wall);
                        addBoxRelative(1, 4, 8, 35, 2, 8, theme.wall);
                        
                        currentPos = transform(45, 0, 0);
                        break; 
                    }

                    case 'split_ramp_tunnel': { 
                        // Safety Hub
                        addBoxRelative(5, 1, 20, 2.5, 0, 0, baseColor);
                        
                        // Left Ramp path
                        const riseH = 8; const angleH = Math.atan2(riseH, 20); const hypH = Math.sqrt(20*20 + riseH*riseH);
                        // Up
                        addRamp(hypH, 1, 8, 15, riseH/2, -8, theme.primary, angleH);
                        // Flat
                        addBoxRelative(10, 1, 8, 30, riseH, -8, theme.primary);
                        // Down
                        addRamp(hypH, 1, 8, 45, riseH/2, -8, theme.primary, -angleH);
                        
                        // Right Tunnel path
                        addBoxRelative(50, 1, 8, 30, 0, 8, baseColor);
                        addBoxRelative(50, 1, 8, 30, 5, 8, theme.wall);
                        
                        currentPos = transform(55, 0, 0);
                        break; 
                    }
                    
                    case 'rotating_disc': {
                        addBoxRelative(5, 1, 10, 2.5, 0, 0, baseColor);
                        const t = transform(15, 0, 0);
                        const disc = createCylinder(12, 12, 1, t.x, t.y, t.z, theme.accent, 100);
                        disc.body.type = CANNON.Body.KINEMATIC;
                        obstacles.push({ ...disc, type: 'rotating_disc', speed: 5 });
                        
                        addBoxRelative(5, 1, 10, 27.5, 0, 0, baseColor);
                        currentPos = transform(30, 0, 0);
                        break;
                    }

                    case 'moving_platforms': {
                        const startLocX = 8; // Closer start
                        for(let i=0; i<3; i++) {
                            const lx = startLocX + (i * 12);
                            const t = transform(lx, 0, 0);
                            const p = createBox(8, 1, 8, t.x, t.y, t.z, theme.primary, 100, 0, currentAngle, 0);
                            p.body.type = CANNON.Body.KINEMATIC;
                            // Pass angle so we know which way is "side"
                            obstacles.push({ ...p, type: 'moving_platform', speed: 3, offset: i * 2, initialPos: {x: t.x, y: t.y, z: t.z}, levelAngle: currentAngle });
                        }
                        currentPos = transform(44, 0, 0);
                        break;
                    }

                    case 'steps_up': {
                        for(let i=0; i<4; i++) {
                            addBoxRelative(5, 1 + i, 10, 2.5 + (i*5), (i * 0.5), 0, i % 2 === 0 ? theme.floor1 : theme.floor2);
                        }
                        currentPos = transform(20, 2.0, 0);
                        break;
                    }

                    case 'steps_down': {
                        for(let i=0; i<4; i++) {
                            const y = -(i+1)*0.5 - 2.0;
                            addBoxRelative(5, 4, 10, 2.5 + (i*5), y, 0, i % 2 === 0 ? theme.floor1 : theme.floor2);
                        }
                        currentPos = transform(20, -2.0, 0);
                        break;
                    }

                    case 'low_spinners': {
                         addBoxRelative(30, 1, 10, 15, 0, 0, baseColor);
                         for(let i=0; i<2; i++) {
                            const lx = 10 + (i*10);
                            addBoxRelative(1, 0.5, 1, lx, 0.5, 0, theme.wall);
                            const t = transform(lx, 0.75, 0);
                            const bar = createBox(8, 0.5, 0.5, t.x, t.y, t.z, theme.primary, 10, 0, currentAngle, 0);
                            bar.body.type = CANNON.Body.KINEMATIC;
                            obstacles.push({ ...bar, type: 'spinner', speed: 20 });
                         }
                         currentPos = transform(30, 0, 0);
                         break;
                    }

                    case 'arch_jump': {
                        addBoxRelative(10, 1, 10, 5, 0, 0, baseColor);
                        addBoxRelative(1, 10, 1, 15, 5, -4, theme.accent);
                        addBoxRelative(1, 10, 1, 15, 5, 4, theme.accent);
                        addBoxRelative(1, 1, 9, 15, 10, 0, theme.accent);
                        
                        addBoxRelative(10, 1, 10, 25, 0, 0, baseColor);
                        currentPos = transform(30, 0, 0);
                        break;
                    }

                    case 'punch_wall': {
                        addBoxRelative(20, 1, 12, 10, 0, 0, baseColor);
                        addBoxRelative(20, 5, 2, 10, 3, -5, theme.wall);
                        // Pistons (enlarged for more danger)
                        for(let i=0; i<3; i++) {
                            const lx = 5 + (i*5);
                            const t = transform(lx, 2.5, -4);
                            const p = createBox(3, 4, 6, t.x, t.y, t.z, theme.primary, 100, 0, currentAngle, 0);
                            p.body.type = CANNON.Body.KINEMATIC;
                            obstacles.push({ ...p, type: 'puncher', speed: 4, offset: i, initialPos: {x: t.x, y: t.y, z: t.z}, levelAngle: currentAngle });
                        }
                        currentPos = transform(20, 0, 0);
                        break;
                    }

                    // --- NEW SEGMENT TYPES ---

                    case 'gap_jump': {
                        // Platform, gap, platform - player must jump across an 8-unit gap
                        addBoxRelative(10, 1, 10, 5, 0, 0, baseColor);
                        addBoxRelative(10, 1, 10, 23, 0, 0, baseColor);
                        currentPos = transform(28, 0, 0);
                        break;
                    }

                    case 'zigzag': {
                        // Alternating offset platforms requiring lateral movement
                        const zigWidth = 5;
                        const zigLen = 8;
                        for (let i = 0; i < 4; i++) {
                            const offsetZ = (i % 2 === 0) ? -4 : 4;
                            addBoxRelative(zigLen, 1, zigWidth, 4 + i * zigLen, 0, offsetZ, i % 2 === 0 ? theme.primary : theme.secondary);
                        }
                        currentPos = transform(36, 0, 0);
                        break;
                    }

                    case 'floating_islands': {
                        // Small platforms with gaps - hop between them
                        // Each island 5x5, edge-to-edge gaps of ~6 units
                        addBoxRelative(5, 1, 5, 2.5, 0, 0, baseColor);
                        addBoxRelative(5, 1, 5, 13.5, 1, -3, theme.primary);
                        addBoxRelative(5, 1, 5, 24.5, 0.5, 2, theme.secondary);
                        addBoxRelative(5, 1, 5, 35.5, 0, -1, theme.primary);
                        addBoxRelative(8, 1, 10, 46, 0, 0, baseColor);
                        currentPos = transform(50, 0, 0);
                        break;
                    }

                    case 'pillars': {
                        // Narrow columns to hop between
                        addBoxRelative(4, 1, 10, 2, 0, 0, baseColor); // entry
                        for (let i = 0; i < 5; i++) {
                            const px = 8 + i * 6;
                            const py = Math.sin(i * 0.8) * 2; // gentle wave height
                            const pz = (i % 2 === 0 ? -2 : 2);
                            addBoxRelative(3, 3 + Math.abs(py), 3, px, -(3 + Math.abs(py))/2 + 0.5 + py, pz, theme.wall);
                        }
                        addBoxRelative(4, 1, 10, 40, 0, 0, baseColor); // exit
                        currentPos = transform(44, 0, 0);
                        break;
                    }

                    case 's_curve': {
                        // Curving path made from offset segments
                        const curveLen = 8;
                        const curveW = 6;
                        // Right curve
                        addBoxRelative(curveLen, 1, curveW, curveLen/2, 0, 3, theme.floor1);
                        addBoxRelative(curveLen, 1, curveW, curveLen + curveLen/2, 0, 5, theme.floor2);
                        // Left curve back
                        addBoxRelative(curveLen, 1, curveW, curveLen*2 + curveLen/2, 0, 2, theme.floor1);
                        addBoxRelative(curveLen, 1, curveW, curveLen*3 + curveLen/2, 0, -2, theme.floor2);
                        // Right curve back to center
                        addBoxRelative(curveLen, 1, curveW, curveLen*4 + curveLen/2, 0, -5, theme.floor1);
                        addBoxRelative(curveLen, 1, curveW, curveLen*5 + curveLen/2, 0, -2, theme.floor2);
                        // Side rails for guidance
                        addBoxRelative(curveLen*6, 0.5, 0.5, curveLen*3, 1, -9, theme.wall);
                        addBoxRelative(curveLen*6, 0.5, 0.5, curveLen*3, 1, 9, theme.wall);
                        currentPos = transform(curveLen*6, 0, 0);
                        break;
                    }

                    case 'drop_ledges': {
                        // Descending ledges to drop down - like reverse stairs but with gaps
                        addBoxRelative(6, 1, 10, 3, 0, 0, baseColor);
                        addBoxRelative(6, 1, 8, 12, -2, 2, theme.primary);
                        addBoxRelative(6, 1, 8, 21, -4, -2, theme.secondary);
                        addBoxRelative(6, 1, 8, 30, -6, 1, theme.primary);
                        addBoxRelative(8, 1, 10, 40, -6, 0, baseColor);
                        currentPos = transform(44, -6, 0);
                        break;
                    }

                    case 'wave_platforms': {
                        // Platforms that bob up and down in a wave pattern
                        addBoxRelative(5, 1, 10, 2.5, 0, 0, baseColor); // entry
                        for (let i = 0; i < 4; i++) {
                            const lx = 9 + i * 8;
                            const t = transform(lx, 0, 0);
                            const wp = createBox(6, 1, 8, t.x, t.y, t.z, theme.secondary, 100, 0, currentAngle, 0);
                            wp.body.type = CANNON.Body.KINEMATIC;
                            obstacles.push({ ...wp, type: 'wave_platform', speed: 2, offset: i * 1.5, initialPos: {x: t.x, y: t.y, z: t.z} });
                        }
                        addBoxRelative(5, 1, 10, 43, 0, 0, baseColor); // exit
                        currentPos = transform(48, 0, 0);
                        break;
                    }

                    case 'bumper_alley': {
                        // Corridor with spinning bumpers to dodge
                        addBoxRelative(40, 1, 12, 20, 0, 0, baseColor);
                        // Side walls
                        addBoxRelative(40, 3, 1, 20, 1.5, -6, theme.wall);
                        addBoxRelative(40, 3, 1, 20, 1.5, 6, theme.wall);
                        // Spinning bumpers at intervals
                        for (let i = 0; i < 3; i++) {
                            const lx = 10 + i * 10;
                            addBoxRelative(1, 4, 1, lx, 2, 0, theme.wall); // post
                            const t = transform(lx, 3.5, 0);
                            const bar = createBox(10, 0.8, 0.8, t.x, t.y, t.z, theme.primary, 10, 0, currentAngle, 0);
                            bar.body.type = CANNON.Body.KINEMATIC;
                            obstacles.push({ ...bar, type: 'spinner', speed: (i % 2 === 0 ? 5 : -5) });
                        }
                        currentPos = transform(40, 0, 0);
                        break;
                    }
                    
                    case 'pendulum_gauntlet': {
                        // Entry platform
                        addBoxRelative(5, 1, 12, 2.5, 0, 0, baseColor);
                        // Long corridor floor
                        addBoxRelative(35, 1, 12, 22.5, 0, 0, baseColor);
                        // Three pendulums sweeping across the path with staggered phases
                        for (let i = 0; i < 3; i++) {
                            const lx = 10 + i * 10;
                            // Overhead pivot post
                            addBoxRelative(1, 6, 1, lx, 3, 0, theme.wall);
                            // Pendulum arm - tall box that sweeps side to side
                            const t = transform(lx, 3, 0);
                            const pend = createBox(1, 6, 1, t.x, t.y, t.z, theme.primary, 10, 0, currentAngle, 0);
                            pend.body.type = CANNON.Body.KINEMATIC;
                            obstacles.push({ ...pend, type: 'pendulum', speed: 1.8, offset: i * 2.1, amplitude: 5, initialPos: { x: t.x, y: t.y, z: t.z }, levelAngle: currentAngle });
                        }
                        // Exit platform
                        addBoxRelative(5, 1, 12, 42.5, 0, 0, baseColor);
                        currentPos = transform(45, 0, 0);
                        break;
                    }

                    case 'spinner_corridor': {
                        // Narrow walled corridor with staggered low spinners
                        addBoxRelative(40, 1, 6, 20, 0, 0, baseColor);
                        // Side walls to enforce the narrow passage
                        addBoxRelative(40, 3, 1, 20, 1.5, -3, theme.wall);
                        addBoxRelative(40, 3, 1, 20, 1.5, 3, theme.wall);
                        // Staggered spinners at different lateral positions
                        for (let i = 0; i < 4; i++) {
                            const lx = 7 + i * 9;
                            const lz = (i % 2 === 0) ? -1.5 : 1.5;
                            addBoxRelative(1, 1, 1, lx, 0.5, lz, theme.wall); // post
                            const t = transform(lx, 1, lz);
                            const bar = createBox(5, 0.5, 0.5, t.x, t.y, t.z, theme.primary, 10, 0, currentAngle, 0);
                            bar.body.type = CANNON.Body.KINEMATIC;
                            obstacles.push({ ...bar, type: 'spinner', speed: (i % 2 === 0 ? 18 : -18) });
                        }
                        currentPos = transform(40, 0, 0);
                        break;
                    }

                    case 'finish': {
                        finishLinePos.copy(currentPos); // Approximate check
                        addBoxRelative(20, 1, 20, 10, 0, 0, 0xffd700);
                        // Arch
                        const t = transform(0, 4.5, 0); // Arch at start of pad
                        const arch = createBox(2, 8, 10, t.x, t.y, t.z, 0xffd700, 0, 0, currentAngle, 0);
                        arch.mesh.material.transparent = true; 
                        arch.mesh.material.opacity = 0.5; 
                        arch.body.collisionFilterGroup = 0; 
                        
                        // Set physics check to be plane collision or distance check
                        finishLinePos.set(t.x, t.y, t.z);
                        break; 
                    }
                }
                if(currentPos.y < levelMinY) levelMinY = currentPos.y;
            });
        }

        function createFaceTexture(skinColorHex) {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128; const ctx = canvas.getContext('2d');
            ctx.fillStyle = skinColorHex; ctx.fillRect(0, 0, 128, 128); ctx.fillStyle = '#000000';
            const eyeY = 50; const eyeXOffset = 20 + Math.random() * 15; const eyeSize = 8 + Math.random() * 10;
            ctx.beginPath(); ctx.arc(64 - eyeXOffset, eyeY, eyeSize, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(64 + eyeXOffset, eyeY, eyeSize, 0, Math.PI * 2); ctx.fill();
            ctx.lineWidth = 6; ctx.strokeStyle = '#000000'; ctx.beginPath();
            const mouthType = Math.floor(Math.random() * 4);
            if (mouthType === 0) ctx.arc(64, 80, 20, 0, Math.PI, false);
            else if (mouthType === 1) ctx.arc(64, 100, 20, Math.PI, 0, false);
            else if (mouthType === 2) ctx.arc(64, 90, 15, 0, Math.PI * 2);
            else { ctx.moveTo(44, 90); ctx.lineTo(84, 90); }
            ctx.stroke(); return new THREE.CanvasTexture(canvas);
        }

        function createNameSprite(name) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Reduced alpha background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
            ctx.beginPath(); ctx.roundRect(10, 10, 492, 108, 20); ctx.fill();
            
            ctx.font = 'bold 50px Arial'; ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(name, canvas.width / 2, canvas.height / 2);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false, depthWrite: false });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(6, 1.5, 1); sprite.renderOrder = 999;
            return sprite;
        }

        function createHumanoid(costume, name) {
            // Default fallbacks
            const skinC = costume.skin || '#ffccaa';
            const hairC = costume.hair || '#442200';
            const shirtC = costume.shirt || '#ff0000';
            const pantsC = costume.pants || '#0000ff';
            const hairStyle = costume.hairStyle || 0;

            const group = new THREE.Group();

            // Head (Skin)
            const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const skinMat = new THREE.MeshPhongMaterial({ color: skinC });
            const faceTexture = createFaceTexture(skinC); 
            const faceMat = new THREE.MeshPhongMaterial({ color: 0xffffff, map: faceTexture }); // Use white base so texture color shows true
            const headMaterials = [skinMat, skinMat, skinMat, skinMat, faceMat, skinMat];
            const head = new THREE.Mesh(headGeo, headMaterials); 
            head.position.y = 0.85; head.castShadow = true; group.add(head);

            // Hair (Custom Color & Style)
            const hairMat = new THREE.MeshPhongMaterial({ color: hairC });
            
            if (hairStyle === 0) { // Standard
                const hairTopGeo = new THREE.BoxGeometry(0.55, 0.15, 0.55);
                const hairTop = new THREE.Mesh(hairTopGeo, hairMat);
                hairTop.position.y = 1.125; hairTop.castShadow = true; group.add(hairTop);
                
                const hairBackGeo = new THREE.BoxGeometry(0.55, 0.4, 0.15);
                const hairBack = new THREE.Mesh(hairBackGeo, hairMat);
                hairBack.position.set(0, 0.85, -0.22); hairBack.castShadow = true; group.add(hairBack);
            } 
            else if (hairStyle === 1) { // Spiky
                const spikeGeo = new THREE.ConeGeometry(0.1, 0.3, 4);
                // Center spike
                const spike1 = new THREE.Mesh(spikeGeo, hairMat);
                spike1.position.set(0, 1.25, 0); spike1.castShadow = true; group.add(spike1);
                // Left spike
                const spike2 = new THREE.Mesh(spikeGeo, hairMat);
                spike2.position.set(-0.15, 1.2, 0); spike2.rotation.z = 0.3; spike2.castShadow = true; group.add(spike2);
                // Right spike
                const spike3 = new THREE.Mesh(spikeGeo, hairMat);
                spike3.position.set(0.15, 1.2, 0); spike3.rotation.z = -0.3; spike3.castShadow = true; group.add(spike3);
                // Base
                const baseGeo = new THREE.BoxGeometry(0.52, 0.05, 0.52);
                const base = new THREE.Mesh(baseGeo, hairMat);
                base.position.y = 1.1; base.castShadow = true; group.add(base);
            }
            else if (hairStyle === 2) { // Mohawk
                const mohawkGeo = new THREE.BoxGeometry(0.15, 0.4, 0.6);
                const mohawk = new THREE.Mesh(mohawkGeo, hairMat);
                mohawk.position.set(0, 1.2, 0); mohawk.castShadow = true; group.add(mohawk);
            }
            else if (hairStyle === 3) { // Bob
                const topGeo = new THREE.BoxGeometry(0.6, 0.15, 0.6);
                const top = new THREE.Mesh(topGeo, hairMat);
                top.position.y = 1.125; top.castShadow = true; group.add(top);
                
                const sideLGeo = new THREE.BoxGeometry(0.1, 0.5, 0.5);
                const sideL = new THREE.Mesh(sideLGeo, hairMat);
                sideL.position.set(-0.28, 0.9, 0); sideL.castShadow = true; group.add(sideL);
                
                const sideRGeo = new THREE.BoxGeometry(0.1, 0.5, 0.5);
                const sideR = new THREE.Mesh(sideRGeo, hairMat);
                sideR.position.set(0.28, 0.9, 0); sideR.castShadow = true; group.add(sideR);
                
                const backGeo = new THREE.BoxGeometry(0.6, 0.5, 0.1);
                const back = new THREE.Mesh(backGeo, hairMat);
                back.position.set(0, 0.9, -0.28); back.castShadow = true; group.add(back);
            }
            // Style 4 is Bald (no mesh added)

            // Body (Shirt)
            const bodyGeo = new THREE.BoxGeometry(0.6, 0.7, 0.35); 
            const bodyMat = new THREE.MeshPhongMaterial({ color: shirtC }); 
            const body = new THREE.Mesh(bodyGeo, bodyMat); 
            body.position.y = 0.2; body.castShadow = true; group.add(body);

            // Arms (Skin) - could be shirt color for long sleeves, but let's keep as skin for now
            const armGeo = new THREE.BoxGeometry(0.2, 0.7, 0.2); 
            const armMat = new THREE.MeshPhongMaterial({ color: skinC });

            const armL = new THREE.Mesh(armGeo, armMat); armL.position.set(-0.45, 0.2, 0); armL.name = "armL"; armL.castShadow = true; group.add(armL);
            const armR = new THREE.Mesh(armGeo, armMat); armR.position.set(0.45, 0.2, 0); armR.name = "armR"; armR.castShadow = true; group.add(armR);

            // Legs (Pants)
            const legGeo = new THREE.BoxGeometry(0.22, 0.8, 0.22); 
            const legMat = new THREE.MeshPhongMaterial({ color: pantsC }); 
            const legL = new THREE.Mesh(legGeo, legMat); legL.position.set(-0.2, -0.6, 0); legL.name = "legL"; legL.castShadow = true; group.add(legL);
            const legR = new THREE.Mesh(legGeo, legMat); legR.position.set(0.2, -0.6, 0); legR.name = "legR"; legR.castShadow = true; group.add(legR);
            
            if (name) {
                const nameSprite = createNameSprite(name);
                nameSprite.position.y = 2.8; // Raised higher to clear mohawks/spikes
                nameSprite.name = "nameSprite";
                group.add(nameSprite);
            }
            return group;
        }

        function createPlayer(costumeOverride) {
            const costumeToUse = costumeOverride || myCostume; // Note: myCostume are indices, we need hex if this isn't overridden
            
            // If not overridden (solo play or something), we need to convert myCostume indices to hex
            let finalCostume = costumeOverride;
            if(!finalCostume) {
                finalCostume = {
                    skin: PALETTES.skin[myCostume.skin],
                    hair: PALETTES.hair[myCostume.hair],
                    shirt: PALETTES.shirt[myCostume.shirt],
                    pants: PALETTES.pants[myCostume.pants],
                    hairStyle: myCostume.hairStyle
                };
            }

            const mesh = createHumanoid(finalCostume, myUsername); 
            scene.add(mesh); playerMesh = mesh; window.playerMesh = mesh;
            const shape = new CANNON.Sphere(0.6); 
            playerBody = new CANNON.Body({ mass: 1, fixedRotation: true, material: world.defaultMaterial });
            playerBody.addShape(shape); playerBody.position.set(0, 2, 0); playerBody.linearDamping = 0.0; 
            world.addBody(playerBody);
            player = { mesh, body: playerBody, isPlayer: true }; 
            window.playerBody = playerBody;
            prevPlayerPos.x = playerBody.position.x; prevPlayerPos.y = playerBody.position.y; prevPlayerPos.z = playerBody.position.z;
        }

        function updatePhysics() {
            world.step(fixedTimeStep);
            let isGrounded = false;
            for(let i = 0; i < world.contacts.length; i++) {
                const c = world.contacts[i];
                if(c.bi === playerBody || c.bj === playerBody) {
                    if(c.bi === playerBody) { if(c.ni.y < -0.5) isGrounded = true; } else { if(c.ni.y > 0.5) isGrounded = true; }
                    if(gameActive) {
                        const now = Date.now();
                        const relVel = c.bi === playerBody ? c.bi.velocity.length() : c.bj.velocity.length();
                        if(relVel > 25 && now - lastCollisionSound > 500) { playSoundEffect('collision'); lastCollisionSound = now; }
                    }
                }
            }
            if (isGrounded) {
                lastGroundedTime = Date.now();
                canAirDash = true; // Reset air dash
            }
            const time = Date.now() * 0.001;
            
            // --- UPDATED OBSTACLE LOGIC FOR ROTATED WORLDS ---
            obstacles.forEach(obs => {
                if(obs.type === 'spinner') {
                    // Y-axis rotation is safe regardless of world rotation
                    obs.body.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), time * obs.speed);
                    obs.body.angularVelocity.set(0, obs.speed, 0); 
                }
                else if(obs.type === 'tilt') {
                    // Tilt needs to respect level angle. 
                    // Forward vector based on stored levelAngle
                    const ax = Math.cos(obs.levelAngle);
                    const az = Math.sin(obs.levelAngle);
                    const forward = new CANNON.Vec3(ax, 0, az);
                    
                    const angle = Math.sin(time * obs.speed + obs.offset) * 0.5;
                    obs.body.quaternion.setFromAxisAngle(forward, angle);
                    
                    const omega = 0.5 * obs.speed * Math.cos(time * obs.speed + obs.offset);
                    obs.body.angularVelocity.set(forward.x * omega, 0, forward.z * omega);
                }
                else if (obs.type === 'rotating_disc') {
                    obs.body.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), time * obs.speed);
                    obs.body.angularVelocity.set(0, obs.speed, 0);
                }
                else if (obs.type === 'moving_platform') {
                    // Move perpendicular to level direction (side to side)
                    // Side vector is (-sin, 0, cos) relative to levelAngle
                    const sx = -Math.sin(obs.levelAngle);
                    const sz = Math.cos(obs.levelAngle);
                    
                    const offset = Math.sin(time * obs.speed + obs.offset) * 8;
                    
                    obs.body.position.set(
                        obs.initialPos.x + sx * offset, 
                        obs.initialPos.y, 
                        obs.initialPos.z + sz * offset
                    );
                    
                    // Velocity for friction
                    const vMag = 8 * obs.speed * Math.cos(time * obs.speed + obs.offset);
                    obs.body.velocity.set(sx * vMag, 0, sz * vMag);
                }
                else if (obs.type === 'puncher') {
                     const sx = -Math.sin(obs.levelAngle);
                     const sz = Math.cos(obs.levelAngle);
                     
                     const pOffset = Math.sin(time * obs.speed + obs.offset) * 3;
                     const dist = Math.abs(pOffset);
                     
                     obs.body.position.set(
                        obs.initialPos.x + sx * dist,
                        obs.initialPos.y,
                        obs.initialPos.z + sz * dist
                     );
                }
                else if (obs.type === 'wave_platform') {
                     // Vertical bobbing motion
                     const yOffset = Math.sin(time * obs.speed + obs.offset) * 3;
                     obs.body.position.set(
                        obs.initialPos.x,
                        obs.initialPos.y + yOffset,
                        obs.initialPos.z
                     );
                     obs.body.velocity.set(0, 3 * obs.speed * Math.cos(time * obs.speed + obs.offset), 0);
                }
                else if (obs.type === 'pendulum') {
                     // Sweeps side-to-side across the path
                     const sx = -Math.sin(obs.levelAngle);
                     const sz = Math.cos(obs.levelAngle);
                     const swingOffset = Math.sin(time * obs.speed + obs.offset) * obs.amplitude;
                     obs.body.position.set(
                        obs.initialPos.x + sx * swingOffset,
                        obs.initialPos.y,
                        obs.initialPos.z + sz * swingOffset
                     );
                     const vMag = obs.amplitude * obs.speed * Math.cos(time * obs.speed + obs.offset);
                     obs.body.velocity.set(sx * vMag, 0, sz * vMag);
                }

                obs.mesh.position.copy(obs.body.position); 
                obs.mesh.quaternion.copy(obs.body.quaternion);
            });

            if(gameActive || !gameActive) { 
                if(playerBody && playerBody.position.y < levelMinY - 30) {
                    playerBody.position.set(currentRespawnPos.x, currentRespawnPos.y, currentRespawnPos.z);
                    playerBody.velocity.set(0, 0, 0); 
                    if(gameActive) { playerMomentum = 30; } 
                }
            }
            if(gameActive) {
                // Checkpoint check needs to happen using Distance now, since X isn't always increasing
                if(checkpointPos && !checkpointActivated) {
                    // Check dist < 10
                    const dx = playerBody.position.x - checkpointPos.x;
                    const dz = playerBody.position.z - checkpointPos.z;
                    if(Math.sqrt(dx*dx + dz*dz) < 15) {
                        checkpointActivated = true; 
                        currentRespawnPos = { x: checkpointPos.x, y: checkpointPos.y + 10, z: checkpointPos.z };
                        if(window.checkpointFlagMat) window.checkpointFlagMat.color.setHex(0x00ff00);
                        playTone(880, 0.1, 'sine', 0.2); setTimeout(() => playTone(1100, 0.2, 'sine', 0.2), 100);
                    }
                }
                
                for (const uid in window.opponentsData) {
                    const data = window.opponentsData[uid]; if(uid === myId) continue; 
                    if (!opponents[uid]) {
                        // Pass costume data
                        const mesh = createHumanoid(data.costume || {}, data.username); 
                        scene.add(mesh);
                        opponents[uid] = { mesh: mesh, lastPos: new THREE.Vector3(data.x, data.y, data.z) };
                    }
                    const opp = opponents[uid]; const currentPos = new THREE.Vector3(data.x, data.y, data.z);
                    const speed = currentPos.distanceTo(opp.lastPos) * 60; opp.lastPos.copy(currentPos);
                    opp.mesh.position.lerp(new THREE.Vector3(data.x, data.y - 0.1, data.z), 0.2); opp.mesh.rotation.y = data.rot;
                    const armL = opp.mesh.getObjectByName('armL'); const armR = opp.mesh.getObjectByName('armR');
                    const legL = opp.mesh.getObjectByName('legL'); const legR = opp.mesh.getObjectByName('legR');
                    if(speed > 0.5) {
                        const runTime = Date.now() * 0.015;
                        if(armL) armL.rotation.x = Math.sin(runTime) * 0.8; if(armR) armR.rotation.x = -Math.sin(runTime) * 0.8;
                        if(legL) legL.rotation.x = -Math.sin(runTime) * 0.8; if(legR) legR.rotation.x = Math.sin(runTime) * 0.8;
                    } else {
                        if(armL) armL.rotation.x = 0; if(armR) armR.rotation.x = 0; if(legL) legL.rotation.x = 0; if(legR) legR.rotation.x = 0;
                    }
                }
                for (const uid in opponents) { if (!window.opponentsData[uid]) { scene.remove(opponents[uid].mesh); delete opponents[uid]; } }
                
                const baseSpeed = 30; const maxSpeed = 50; const acceleration = 0.15; const deceleration = 0.5;
                if (keys.w) playerMomentum = Math.min(playerMomentum + acceleration, maxSpeed);
                else playerMomentum = Math.max(playerMomentum - deceleration, baseSpeed);
                const pct = ((playerMomentum - baseSpeed) / (maxSpeed - baseSpeed)) * 100;
                document.getElementById('speed-bar').style.width = `${pct}%`;
                
                const force = new CANNON.Vec3(0, 0, 0);
                const fwdX = Math.cos(cameraAngle); const fwdZ = Math.sin(cameraAngle);
                const rightX = -Math.sin(cameraAngle); const rightZ = Math.cos(cameraAngle);
                if(keys.w) { force.x += fwdX * playerMomentum; force.z += fwdZ * playerMomentum; }
                if(keys.s) { force.x -= fwdX * (playerMomentum * 0.6); force.z -= fwdZ * (playerMomentum * 0.6); }
                if(keys.a) { force.x -= rightX * (playerMomentum * 0.8); force.z -= rightZ * (playerMomentum * 0.8); }
                if(keys.d) { force.x += rightX * (playerMomentum * 0.8); force.z += rightZ * (playerMomentum * 0.8); }
                
                // --- DASH VECTOR INTEGRATION ---
                // Add dash vector to velocity, then decay dash vector
                playerBody.velocity.x = (force.x * 0.5) + dashVector.x;
                playerBody.velocity.z = (force.z * 0.5) + dashVector.z;
                
                dashVector.x *= 0.85; 
                dashVector.z *= 0.85;
                if(Math.abs(dashVector.x) < 0.1) dashVector.x = 0;
                if(Math.abs(dashVector.z) < 0.1) dashVector.z = 0;

                if(keys.w && Math.abs(playerBody.velocity.y) > 0.5) { playerBody.velocity.x += fwdX * 0.2; playerBody.velocity.z += fwdZ * 0.2; }
                if(keys.space && (Date.now() - lastGroundedTime < 200)) { lastGroundedTime = 0; playerBody.velocity.y = 20; playSoundEffect('jump'); }
                checkFinish();
            }
        }
        
        function checkFinish() {
            // Updated to check distance to finish arch because we might approach from any angle
            if(!hasFinished) {
                const dist = playerBody.position.distanceTo(finishLinePos);
                if(dist < 5) {
                    hasFinished = true; 
                    window.hasFinished = true; 
                    playSoundEffect('finish');
                    showEndScreen(); 
                }
            }
            
            // Rank calculation is tricky on a non-linear map without pathfinding.
            // Simplified: "Distance from start" isn't enough because path winds.
            // We can check "Distance to finish"?
            // If we know finishLinePos, rank is sorted by distance to finish (ascending).
            
            let myDist = playerBody.position.distanceTo(finishLinePos);
            let countAhead = 0;
            
            // Check opponents
            for(const uid in window.opponentsData) { 
                const p = window.opponentsData[uid];
                // Simple distance check
                const pDist = Math.sqrt(
                    Math.pow(p.x - finishLinePos.x, 2) + 
                    Math.pow(p.y - finishLinePos.y, 2) + 
                    Math.pow(p.z - finishLinePos.z, 2)
                );
                
                if (p.finished) {
                    // If they finished and I haven't, they are ahead.
                    if (!hasFinished) countAhead++;
                    // If we both finished, we need finish times, but we don't track that yet.
                    // Assume they are ahead if they finished.
                } else if (!hasFinished && pDist < myDist) {
                    countAhead++;
                }
            }
            document.getElementById('rank').innerText = `Rank: ${countAhead + 1}`;
        }
        
        function showEndScreen() {
            window.gameActive = false; 
            gameActive = false;
            document.exitPointerLock();
            
            const winScreen = document.getElementById('win-screen');
            const leaderboardDiv = document.getElementById('final-leaderboard');
            const controlsDiv = document.getElementById('end-screen-controls');
            
            leaderboardDiv.innerHTML = ''; 
            controlsDiv.innerHTML = '';
            
            let allPlayers = [];
            // Calc current distances for end screen
            const finishPos = finishLinePos;
            
            if (window.playerBody) allPlayers.push({ 
                username: myUsername + " (You)", 
                dist: window.playerBody.position.distanceTo(finishPos), 
                finished: window.hasFinished, 
                isLocal: true 
            });
            
            for (const uid in window.opponentsData) {
                const p = window.opponentsData[uid]; 
                if(uid === myId) continue;
                const pDist = Math.sqrt(Math.pow(p.x - finishPos.x, 2) + Math.pow(p.z - finishPos.z, 2));
                allPlayers.push({ 
                    username: p.username, 
                    dist: pDist, 
                    finished: p.finished, 
                    isLocal: false 
                });
            }
            
            allPlayers.sort((a, b) => { 
                if (a.finished && !b.finished) return -1; 
                if (!a.finished && b.finished) return 1; 
                return a.dist - b.dist; // Lower distance is better
            });
            
            allPlayers.forEach((p, index) => {
                const row = document.createElement('div'); 
                row.className = 'leaderboard-row';
                row.style.color = p.isLocal ? '#ffff00' : 'white'; 
                row.style.fontWeight = p.isLocal ? 'bold' : 'normal';
                const status = p.finished ? '<span style="color:#44cc44">FINISHED</span>' : Math.floor(p.dist) + 'm left';
                row.innerHTML = `<span>#${index+1} ${p.username}</span><span>${status}</span>`;
                leaderboardDiv.appendChild(row);
            });
            
            const menuBtn = document.createElement('button'); 
            menuBtn.innerText = "BACK TO MENU"; 
            menuBtn.onclick = window.backToMenu; 
            menuBtn.style.marginRight = "10px"; 
            controlsDiv.appendChild(menuBtn);
            
            if (isHost) {
                const nextBtn = document.createElement('button'); 
                nextBtn.innerText = "START NEXT LEVEL"; 
                nextBtn.style.backgroundColor = "#00ffff"; 
                nextBtn.style.color = "#000"; 
                nextBtn.onclick = window.hostStartGame; 
                controlsDiv.appendChild(nextBtn);
            } else {
                const waitText = document.createElement('p'); 
                waitText.innerText = "Waiting for host to start next level..."; 
                waitText.style.fontSize = "0.9em"; 
                waitText.style.color = "#aaa"; 
                waitText.style.marginTop = "10px"; 
                controlsDiv.appendChild(waitText);
            }
            
            winScreen.style.display = 'block';
        }

        function animate() {
            requestAnimationFrame(animate); 
            
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastPhysicsTime) / 1000;
            lastPhysicsTime = currentTime;
            
            const clampedDelta = Math.min(deltaTime, 0.1);
            accumulator += clampedDelta;
            
            while (accumulator >= fixedTimeStep) {
                if (playerBody) {
                    prevPlayerPos.x = playerBody.position.x;
                    prevPlayerPos.y = playerBody.position.y;
                    prevPlayerPos.z = playerBody.position.z;
                }
                obstacles.forEach((obs, i) => {
                    if (!prevObstacleStates[i]) {
                        prevObstacleStates[i] = {};
                    }
                    const s = prevObstacleStates[i];
                    s.px = obs.body.position.x; s.py = obs.body.position.y; s.pz = obs.body.position.z;
                    s.qx = obs.body.quaternion.x; s.qy = obs.body.quaternion.y;
                    s.qz = obs.body.quaternion.z; s.qw = obs.body.quaternion.w;
                });
                updatePhysics();
                accumulator -= fixedTimeStep;
            }
            
            const alpha = accumulator / fixedTimeStep;
            
            obstacles.forEach((obs, i) => {
                if (prevObstacleStates[i]) {
                    const prev = prevObstacleStates[i];
                    obs.mesh.position.set(
                        prev.px + (obs.body.position.x - prev.px) * alpha,
                        prev.py + (obs.body.position.y - prev.py) * alpha,
                        prev.pz + (obs.body.position.z - prev.pz) * alpha
                    );
                    obs.mesh.quaternion.set(prev.qx, prev.qy, prev.qz, prev.qw);
                    obs.mesh.quaternion.slerp(
                        new THREE.Quaternion(obs.body.quaternion.x, obs.body.quaternion.y, obs.body.quaternion.z, obs.body.quaternion.w),
                        alpha
                    );
                }
            });
            
            if (player) {
                player.mesh.position.set(
                    prevPlayerPos.x + (player.body.position.x - prevPlayerPos.x) * alpha,
                    prevPlayerPos.y + (player.body.position.y - prevPlayerPos.y) * alpha - 0.1,
                    prevPlayerPos.z + (player.body.position.z - prevPlayerPos.z) * alpha
                );
                
                // Animation Logic moved here from updatePhysics
                const vel = player.body.velocity; 
                const speed = Math.sqrt(vel.x*vel.x + vel.z*vel.z);
                if(speed > 0.5) player.mesh.rotation.y = Math.atan2(vel.x, vel.z); 
                
                const armL = player.mesh.getObjectByName('armL'); 
                const armR = player.mesh.getObjectByName('armR');
                const legL = player.mesh.getObjectByName('legL'); 
                const legR = player.mesh.getObjectByName('legR');
                
                if(speed > 1) {
                    const runTime = Date.now() * 0.015;
                    if(armL) armL.rotation.x = Math.sin(runTime) * 0.8; 
                    if(armR) armR.rotation.x = -Math.sin(runTime) * 0.8;
                    if(legL) legL.rotation.x = -Math.sin(runTime) * 0.8; 
                    if(legR) legR.rotation.x = Math.sin(runTime) * 0.8;
                } else {
                    if(armL) armL.rotation.x = 0; 
                    if(armR) armR.rotation.x = 0; 
                    if(legL) legL.rotation.x = 0; 
                    if(legR) legR.rotation.x = 0;
                }
            }
            
            if(playerBody) {
                // Update Sun Position to follow player for better shadows
                sunLight.position.x = playerBody.position.x + 20;
                sunLight.position.y = playerBody.position.y + 50;
                sunLight.position.z = playerBody.position.z + 20;
                sunLight.target.position.copy(playerBody.position);
                sunLight.target.updateMatrixWorld();

                // Update Blob Shadow Position
                if(playerMesh && playerShadow) {
                    raycaster.set(playerMesh.position, downVector);
                    const intersectable = levelObjects.map(o => o.mesh);
                    const intersects = raycaster.intersectObjects(intersectable);
                    
                    if(intersects.length > 0) {
                        playerShadow.position.copy(intersects[0].point);
                        playerShadow.position.y += 0.05; // Lift slightly to avoid z-fighting
                        playerShadow.visible = true;
                        
                        // Scale/Fade based on distance
                        const dist = playerMesh.position.y - playerShadow.position.y;
                        const scale = Math.max(0.5, 1.5 - dist * 0.1);
                        playerShadow.scale.set(scale, scale, 1);
                        playerShadow.material.opacity = Math.max(0, 0.6 - dist * 0.05);
                    } else {
                        playerShadow.visible = false;
                    }
                }

                const targetX = prevPlayerPos.x + (playerBody.position.x - prevPlayerPos.x) * alpha;
                const targetY = prevPlayerPos.y + (playerBody.position.y - prevPlayerPos.y) * alpha;
                const targetZ = prevPlayerPos.z + (playerBody.position.z - prevPlayerPos.z) * alpha;
                const radius = 14; 
                const camHeight = 10;
                const camX = targetX - radius * Math.cos(cameraAngle); 
                const camZ = targetZ - radius * Math.sin(cameraAngle);
                
                const lerpFactor = 1 - Math.pow(CAMERA_SMOOTHING_BASE, clampedDelta * 60);
                camera.position.lerp(new THREE.Vector3(camX, targetY + camHeight, camZ), lerpFactor);
                camera.lookAt(camera.position.x + radius * Math.cos(cameraAngle), camera.position.y - camHeight + 2, camera.position.z + radius * Math.sin(cameraAngle));
            }
            
            // Make name sprites face camera
            if (playerMesh) {
                const nameSprite = playerMesh.getObjectByName('nameSprite');
                if (nameSprite) nameSprite.lookAt(camera.position);
            }
            for (const uid in opponents) {
                const nameSprite = opponents[uid].mesh.getObjectByName('nameSprite');
                if (nameSprite) nameSprite.lookAt(camera.position);
            }
            
            if (backgroundObjects.length > 0) backgroundObjects[0].position.copy(camera.position);
            renderer.render(scene, camera);
        }

        window.addEventListener('load', () => { init(); });
    </script>
</body>
</html>
