<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tumble Dudes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <!-- PeerJS for P2P Networking (Replaces Firebase) -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #222; }
        
        /* Lobby UI Styles */
        #lobby-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #6a0dad, #222);
            display: flex; /* Default flex */
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; color: white;
        }

        .panel {
            background: rgba(0,0,0,0.85); 
            padding: 30px; 
            border-radius: 20px;
            border: 2px solid #ff00ff; 
            text-align: center; 
            width: 90%; 
            max-width: 400px;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            box-sizing: border-box;
        }

        input {
            width: 100%; padding: 12px; margin: 10px 0; background: #333;
            border: 1px solid #555; color: white; border-radius: 8px; box-sizing: border-box;
            text-transform: uppercase; text-align: center; letter-spacing: 2px;
        }

        button.btn-primary {
            width: 100%; padding: 12px; background: #ff00ff; color: white;
            border: none; border-radius: 8px; font-weight: bold; cursor: pointer;
            margin-top: 10px; transition: 0.2s;
        }
        button.btn-primary:hover { background: #d400d4; transform: scale(1.02); }
        button.btn-primary:disabled { background: #555; cursor: not-allowed; transform: none; }

        button.btn-secondary {
            background: transparent; 
            border: 1px solid #777; 
            color: #aaa;
            padding: 8px 16px;
            margin-top: 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        button.btn-secondary:hover { border-color: white; color: white; }

        #player-list {
            list-style: none; padding: 0; margin: 20px 0; text-align: left;
            width: 100%; 
            max-height: 150px; overflow-y: auto;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }
        #player-list li {
            padding: 10px; border-bottom: 1px solid #444; font-size: 1.1em;
        }

        #code-display {
            font-size: 2.5em; 
            font-family: monospace; color: #00ffff;
            margin: 10px 0; letter-spacing: 5px;
            font-weight: bold;
        }

        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 200; color: #ff00ff;
            display: none; align-items: center; justify-content: center;
            font-size: 1.5em;
        }

        /* Game UI */
        #ui {
            position: absolute; top: 20px; left: 20px; color: white; pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8); z-index: 10;
            display: none; 
            flex-direction: column; gap: 10px;
        }

        #speed-meter {
            width: 200px; height: 20px; background: rgba(0,0,0,0.5);
            border: 2px solid white; border-radius: 10px; overflow: hidden;
            margin-top: 5px;
        }
        #speed-bar {
            width: 0%; height: 100%; background: linear-gradient(90deg, #ffff00, #ff0000);
            transition: width 0.1s;
        }

        #commentary-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            border-left: 4px solid #ff00ff;
            max-width: 400px;
            font-style: italic;
            font-size: 1.1rem;
            color: #fff;
            margin-top: 10px;
            transition: opacity 0.5s;
            opacity: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #win-screen {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(30, 30, 30, 0.95); padding: 40px; border-radius: 20px;
            text-align: center; color: white; box-shadow: 0 0 50px rgba(0,0,0,0.5); z-index: 20;
            width: 400px; border: 2px solid #ff00ff;
        }

        #final-leaderboard {
            width: 100%;
            margin: 20px auto;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            box-sizing: border-box;
        }
        .leaderboard-row {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 1.1em;
        }
        .leaderboard-row:last-child {
            border-bottom: none;
        }

        #end-screen-controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        #end-screen-controls button {
            background: #ff00ff; color: white; border: none; padding: 10px 20px;
            font-size: 1rem; border-radius: 10px; cursor: pointer;
            transition: transform 0.1s;
        }
        #end-screen-controls button:hover { background: #d400d4; transform: scale(1.05); }

        .mute-btn {
            position: absolute; bottom: 20px; left: 20px; z-index: 90;
            background: rgba(0,0,0,0.5); padding: 5px 10px; font-size: 0.8rem;
            pointer-events: auto !important; color: white; border: 1px solid white; border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">Connecting to Cloud...</div>

    <!-- Lobby UI -->
    <div id="lobby-ui">
        <h1 style="margin-bottom: 0;">TUMBLE DUDES</h1>
        <p style="color: #ccc; margin-top: 5px;">P2P Multiplayer (Free & Unlimited)</p>
        
        <div id="auth-status" style="margin-bottom: 20px; color: #00ffff;">Ready to Connect</div>

        <!-- Main Menu -->
        <div id="main-menu" class="panel">
            <input type="text" id="username-input" placeholder="USERNAME" maxlength="10">
            <div style="border-top: 1px solid #444; width: 100%; margin: 20px 0;"></div>
            <button class="btn-primary" onclick="createLobby()">HOST GAME</button>
            <div style="margin: 15px 0; color: #aaa;">- OR -</div>
            <input type="text" id="code-input" placeholder="ENTER HOST CODE">
            <button class="btn-primary" onclick="joinLobby()">JOIN GAME</button>
            <div style="margin-top: 10px; font-size: 0.7em; color: #666;">v4.0 (P2P Update)</div>
        </div>

        <!-- Wait Room -->
        <div id="wait-room" class="panel" style="display: none;">
            <h3 style="margin: 0; color: #ff00ff;">LOBBY CODE</h3>
            <div id="code-display"><span id="lobby-code-display">??????</span></div>
            <div id="player-count">1 / 6 Players</div>
            <ul id="player-list">
                <!-- Players go here -->
            </ul>
            <button id="start-btn" class="btn-primary" onclick="hostStartGame()">START RACE (ANYTIME)</button>
            <p id="wait-text" style="font-size: 0.8em; color: #aaa; margin-top: 10px;">Waiting for host...</p>
            <button class="btn-secondary" onclick="backToMenu()">Cancel</button>
        </div>
    </div>

    <!-- Game UI -->
    <div id="ui">
        <div>
            <h1 style="margin:0;">TUMBLE DUDES</h1>
            <div id="rank">Rank: -- / --</div>
            <div id="speed-meter"><div id="speed-bar"></div></div>
        </div>
        <div id="commentary-box">
            <span id="commentary-wave">ðŸ”Š</span>
            <span id="commentary-text">waiting for sportscaster...</span>
        </div>
    </div>

    <button class="mute-btn" onclick="toggleMusic()">ðŸŽµ Toggle Music</button>

    <div id="win-screen">
        <h2 id="win-text" style="color: #44cc44; margin-top:0;">FINISHED!</h2>
        <div id="final-leaderboard">
            <!-- Leaderboard Items Injected JS -->
        </div>
        <div id="end-screen-controls">
            <!-- Buttons injected JS -->
        </div>
    </div>

    <script>
        // --- PEERJS CONFIG ---
        // PeerJS allows direct browser-to-browser connection. No Firebase quotas.
        let peer = null;
        let connections = []; // For Host: Array of DataConnection
        let hostConn = null;  // For Client: Connection to Host
        
        let myId = null;
        let myUsername = "Bean";
        let isHost = false;
        
        // Game State Sync
        window.opponentsData = {}; // { peerId: { username, x, y, z, rot, finished } }
        let myState = { x: 0, y: 0, z: 0, rot: 0, finished: false };

        // --- GAME VARS ---
        let scene, camera, renderer, world;
        let player, playerBody, playerMesh; 
        let opponents = {}; // Visual Meshes
        let obstacles = [];
        let gameActive = false;
        let finishLineX = 0;
        let lastCommentaryTime = 0;
        let playerMomentum = 20; 
        let hasFinished = false;
        
        // Checkpoint System
        let currentRespawnPos = { x: -5, y: 5, z: 0 };
        let checkpointPos = null;
        let checkpointActivated = false;
        window.checkpointFlagMat = null; 

        // Jump Vars
        let lastGroundedTime = 0;
        let backgroundObjects = [];
        let cameraAngle = 0;
        let isPointerLocked = false;
        let audioCtx;
        let isMuted = false;
        let noteIndex = 0;
        let isPlayingMusic = false;
        let currentTrack = null;
        const keys = { w: false, a: false, s: false, d: false, space: false };

        // --- NETWORK FUNCTIONS ---

        function createLobby() {
            const username = document.getElementById('username-input').value || "Host Dude";
            myUsername = username;
            isHost = true;
            
            // Random 4-digit code
            const code = Math.floor(1000 + Math.random() * 9000).toString();
            // Prefix to make unique on public server
            const peerId = "tumble-" + code;

            initPeer(peerId, code);
        }

        function joinLobby() {
            const username = document.getElementById('username-input').value || "Guest Dude";
            myUsername = username;
            isHost = false;
            
            const code = document.getElementById('code-input').value;
            if(!code) { alert("Enter code!"); return; }
            
            // Client doesn't need specific ID, let server assign
            initPeer(null, code);
        }

        function initPeer(customId, lobbyCode) {
            document.getElementById('loading-overlay').style.display = 'flex';
            
            // Using public PeerJS server (Free, no reliability guarantee, but usually fine)
            // Or host your own simple peer server on Render/Heroku if this gets busy
            peer = new Peer(customId, {
                debug: 2
            });

            peer.on('open', (id) => {
                myId = id;
                document.getElementById('loading-overlay').style.display = 'none';
                
                if(isHost) {
                    enterLobbyUI(lobbyCode);
                    // Add self to opponentsData for local display
                    window.opponentsData[myId] = { username: myUsername, isHost: true };
                    updateLobbyList();
                } else {
                    // Connect to Host
                    const hostId = "tumble-" + lobbyCode;
                    hostConn = peer.connect(hostId);
                    
                    hostConn.on('open', () => {
                        console.log("Connected to Host!");
                        // Send handshake
                        hostConn.send({ type: 'join', username: myUsername });
                        enterLobbyUI(lobbyCode);
                    });

                    hostConn.on('data', handleDataFromHost);
                    hostConn.on('close', () => { alert("Host disconnected!"); backToMenu(); });
                    hostConn.on('error', (err) => { alert("Connection Error: " + err); backToMenu(); });
                }
            });

            peer.on('connection', (conn) => {
                // Only Host receives connections
                if(!isHost) return;

                conn.on('open', () => {
                    connections.push(conn);
                    // Send current players to new guy
                    conn.send({ type: 'state_update', players: window.opponentsData });
                });

                conn.on('data', (data) => handleDataFromClient(data, conn.peer));
                
                conn.on('close', () => {
                    // Remove player
                    delete window.opponentsData[conn.peer];
                    connections = connections.filter(c => c.peer !== conn.peer);
                    updateLobbyList();
                    broadcastState(); // Tell everyone they left
                });
            });

            peer.on('error', (err) => {
                document.getElementById('loading-overlay').style.display = 'none';
                if(err.type === 'unavailable-id') {
                    alert("Lobby Code already taken. Try again.");
                } else {
                    alert("Network Error: " + err.type);
                }
                backToMenu();
            });
        }

        // --- HOST LOGIC ---
        function handleDataFromClient(data, clientId) {
            if(data.type === 'join') {
                if(Object.keys(window.opponentsData).length >= 6) return; // Full
                window.opponentsData[clientId] = { 
                    username: data.username, 
                    isHost: false,
                    // Init physics state
                    x: -5, y: 5, z: 0, rot: 0, finished: false
                };
                updateLobbyList();
                broadcastState(); // Sync everyone
            } else if (data.type === 'pos') {
                // Update player position in source of truth
                if(window.opponentsData[clientId]) {
                    Object.assign(window.opponentsData[clientId], data.state);
                }
            }
        }

        function broadcastState() {
            // Send full player list to everyone
            const msg = { type: 'state_update', players: window.opponentsData };
            connections.forEach(c => c.send(msg));
        }

        // --- CLIENT LOGIC ---
        function handleDataFromHost(data) {
            if (data.type === 'state_update') {
                // Update local copy of everyone else
                window.opponentsData = data.players;
                updateLobbyList(); // Refresh UI if in lobby
            } else if (data.type === 'start_game') {
                window.startMultiplayerGame(data.level);
                document.getElementById('ui').style.display = 'block'; 
                document.getElementById('lobby-ui').style.display = 'none';
            }
        }

        // --- UI FUNCS ---
        function enterLobbyUI(code) {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('wait-room').style.display = 'flex';
            document.getElementById('lobby-code-display').innerText = code;
            
            const startBtn = document.getElementById('start-btn');
            const waitText = document.getElementById('wait-text');

            if(isHost) {
                startBtn.style.display = 'block';
                waitText.style.display = 'none';
            } else {
                startBtn.style.display = 'none';
                waitText.style.display = 'block';
            }
        }

        function updateLobbyList() {
            const list = document.getElementById('player-list');
            list.innerHTML = '';
            let count = 0;
            for(const pid in window.opponentsData) {
                const p = window.opponentsData[pid];
                const li = document.createElement('li');
                li.innerText = `${p.username} ${p.isHost ? 'ðŸ‘‘' : ''}`;
                list.appendChild(li);
                count++;
            }
            document.getElementById('player-count').innerText = `${count} / 6 Players`;
        }

        window.hostStartGame = function() {
            if(!isHost) return;
            const level = window.generateRandomLevelStructure(); 
            // Broadcast Start
            const msg = { type: 'start_game', level: level };
            connections.forEach(c => c.send(msg));
            // Start Local
            window.startMultiplayerGame(level);
            document.getElementById('ui').style.display = 'block'; 
            document.getElementById('lobby-ui').style.display = 'none';
        }

        window.backToMenu = function() {
            if(peer) peer.destroy();
            peer = null;
            connections = [];
            hostConn = null;
            window.opponentsData = {};
            
            // UI Reset
            document.getElementById('win-screen').style.display = 'none';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('lobby-ui').style.display = 'flex';
            document.getElementById('main-menu').style.display = 'flex';
            document.getElementById('wait-room').style.display = 'none';
            document.getElementById('loading-overlay').style.display = 'none';
            
            window.gameActive = false;
            window.clearLevel();
            window.changeMusicTrack();
        }

        // --- NETWORK LOOP ---
        // Host broadcasts state ~20 times/sec
        // Client sends state ~20 times/sec
        setInterval(() => {
            if(!window.gameActive || !myId) return;
            
            // 1. Prepare my data
            if(window.playerBody) {
                myState = {
                    x: parseFloat(window.playerBody.position.x.toFixed(2)),
                    y: parseFloat(window.playerBody.position.y.toFixed(2)),
                    z: parseFloat(window.playerBody.position.z.toFixed(2)),
                    rot: parseFloat(window.playerMesh.rotation.y.toFixed(2)),
                    finished: window.hasFinished
                };
            }

            if(isHost) {
                // Host updates their own record in the truth source
                if(window.opponentsData[myId]) Object.assign(window.opponentsData[myId], myState);
                // Broadcast Truth
                broadcastState();
            } else if (hostConn && hostConn.open) {
                // Client sends pos to host
                hostConn.send({ type: 'pos', state: myState });
            }
        }, 50); // 50ms = 20 ticks/sec

        // --- EXPOSE GLOBALS ---
        window.createLobby = createLobby;
        window.joinLobby = joinLobby;
        window.hostStartGame = hostStartGame;

        // --- GAME INIT ---
        function init() {
            if (typeof THREE === 'undefined' || typeof CANNON === 'undefined') {
                console.error("Libraries not loaded.");
                return;
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x6a0dad); 
            scene.fog = new THREE.FogExp2(0x6a0dad, 0.006);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);
            
            const sun = new THREE.DirectionalLight(0xffaa00, 0.8);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            scene.add(sun);

            const purpleLight = new THREE.PointLight(0xff00ff, 0.8, 200);
            purpleLight.position.set(50, 50, 50);
            scene.add(purpleLight);

            world = new CANNON.World();
            world.gravity.set(0, -30, 0); 
            world.broadphase = new CANNON.NaiveBroadphase();
            
            const defaultMaterial = new CANNON.Material('default');
            const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
                friction: 0.3,
                restitution: 0.1,
            });
            world.addContactMaterial(defaultContactMaterial);

            createBackgroundScenery(); 
            
            window.addEventListener('keydown', (e) => { 
                let key = e.key.toLowerCase();
                if (key === ' ') key = 'space'; 
                if(keys.hasOwnProperty(key)) keys[key] = true; 
            });
            window.addEventListener('keyup', (e) => { 
                let key = e.key.toLowerCase();
                if (key === ' ') key = 'space';
                if(keys.hasOwnProperty(key)) keys[key] = false; 
            });
            window.addEventListener('resize', onWindowResize);

            document.addEventListener('click', () => {
                if (!audioCtx) initAudio();
                if (window.gameActive && !isPointerLocked) {
                    document.body.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === document.body;
            });

            document.addEventListener('mousemove', (e) => {
                if (isPointerLocked) {
                    cameraAngle += e.movementX * 0.002;
                }
            });
            
            animate();
        }

        window.startMultiplayerGame = function(levelSegments) {
            document.getElementById('win-screen').style.display = 'none';
            clearLevel();
            createBackgroundScenery(); 
            buildLevelFromSegments(levelSegments);
            createPlayer();
            window.gameActive = true;
            gameActive = true;
            window.hasFinished = false;
            hasFinished = false;
            
            if (!audioCtx) initAudio();
            window.changeMusicTrack(); 
            updateCommentary('start');
        }

        // --- Audio System ---
        const musicTracks = [
            { name: "Funky Bean", tempo: 250, bass: [110, 110, 130, 146, 110, 110, 98, 98], melody: [440, 0, 523, 440, 0, 587, 523, 0], bassType: 'triangle', melodyType: 'square' },
            { name: "Hyper Space", tempo: 200, bass: [65, 0, 65, 0, 73, 0, 73, 0], melody: [523, 523, 784, 0, 659, 0, 523, 0], bassType: 'sawtooth', melodyType: 'sawtooth' },
            { name: "Retro Dash", tempo: 280, bass: [87, 87, 98, 98, 110, 110, 130, 0], melody: [698, 0, 659, 0, 587, 587, 523, 0], bassType: 'square', melodyType: 'triangle' }
        ];
        window.changeMusicTrack = function() {
            currentTrack = musicTracks[Math.floor(Math.random() * musicTracks.length)];
        }
        currentTrack = musicTracks[0];

        function initAudio() {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                if(audioCtx.state === 'suspended') audioCtx.resume();
                startMusicLoop();
            } catch(e) { console.error("Audio init failed", e); }
        }

        function toggleMusic() {
            isMuted = !isMuted;
            if(isMuted && audioCtx) audioCtx.suspend();
            if(!isMuted && audioCtx) audioCtx.resume();
        }

        function playTone(freq, duration, type='sine', vol=0.1) {
            if (!audioCtx || isMuted) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function startMusicLoop() {
            if(isPlayingMusic) return;
            isPlayingMusic = true;
            const loop = () => {
                if(!audioCtx || isMuted || audioCtx.state !== 'running') { setTimeout(loop, 250); return; }
                const track = currentTrack;
                playTone(track.bass[noteIndex % 8], 0.2, track.bassType, 0.15);
                if(track.melody[noteIndex % 8] !== 0) playTone(track.melody[noteIndex % 8], 0.1, track.melodyType, 0.05);
                if(noteIndex % 2 === 0) playTone(2000 + Math.random()*500, 0.05, 'sawtooth', 0.02);
                noteIndex++;
                setTimeout(loop, track.tempo);
            };
            loop();
        }

        async function playPCM(base64Data) {
            // Simplified: No key = no speech. Use Web Speech API if you want free speech later.
        }

        // --- Visuals & Level ---

        function generateSkyboxTexture(theme) {
            const canvas = document.createElement('canvas');
            canvas.width = 4096; canvas.height = 2048;
            const ctx = canvas.getContext('2d');
            const w = canvas.width; const h = canvas.height;

            if (theme === 0) { // Neon Space
                const grad = ctx.createLinearGradient(0, 0, 0, h);
                grad.addColorStop(0, '#000000'); grad.addColorStop(1, '#220033');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
                ctx.fillStyle = '#ffffff';
                for(let i=0; i<800; i++) { ctx.beginPath(); ctx.arc(Math.random()*w, Math.random()*h, Math.random()*2, 0, Math.PI*2); ctx.fill(); }
            } else if (theme === 1) { // Sunny Day
                const grad = ctx.createLinearGradient(0, 0, 0, h);
                grad.addColorStop(0, '#00BFFF'); grad.addColorStop(1, '#FFFFFF');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
            } else if (theme === 2) { // Sunset
                const grad = ctx.createLinearGradient(0, 0, 0, h);
                grad.addColorStop(0, '#4B0082'); grad.addColorStop(0.5, '#FF4500'); grad.addColorStop(1, '#FFD700');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
            } else { // Cyber
                const grad = ctx.createLinearGradient(0, 0, 0, h);
                grad.addColorStop(0, '#000000'); grad.addColorStop(1, '#001133');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)'; ctx.lineWidth = 3;
                for(let i=0; i<w; i+=150) { ctx.beginPath(); ctx.moveTo(w/2, h/2); ctx.lineTo(i, h); ctx.stroke(); }
            }
            return new THREE.CanvasTexture(canvas);
        }

        function createBackgroundScenery() {
            backgroundObjects.forEach(obj => scene.remove(obj));
            backgroundObjects = [];
            const theme = Math.floor(Math.random() * 4);
            const texture = generateSkyboxTexture(theme);
            const geo = new THREE.SphereGeometry(800, 60, 40);
            const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide, fog: false });
            const skybox = new THREE.Mesh(geo, mat);
            scene.add(skybox);
            backgroundObjects.push(skybox);
        }

        window.generateRandomLevelStructure = function() {
            const types = ['path', 'narrow', 'hammers', 'tilts', 'walls', 'ramp_up', 'ramp_down', 'shift_left', 'shift_right', 'split_hammers_walls', 'split_ramp_tunnel'];
            const length = 25 + Math.floor(Math.random() * 15); 
            const level = ['start'];
            for(let i=0; i<length; i++) {
                level.push(types[Math.floor(Math.random() * types.length)]);
            }
            level.push('finish');
            return level;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        async function updateCommentary(eventType) {
            if(!gameActive) return;
            const now = Date.now();
            if(now - lastCommentaryTime < 8000 && eventType !== 'checkpoint') return;
            lastCommentaryTime = now;
            const boxText = document.getElementById('commentary-text');
            boxText.innerText = `ðŸŽ™ï¸ "${eventType.toUpperCase()}"`;
            document.getElementById('commentary-box').style.opacity = 1;
        }

        // --- Level System ---
        let levelObjects = [];
        let currentPos = { x: -5, y: -0.5, z: 0 };

        function createBox(w, h, d, x, y, z, color, mass=0, rotX=0, rotY=0, rotZ=0) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshPhongMaterial({ color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.rotation.set(rotX, rotY, rotZ);
            mesh.castShadow = true; mesh.receiveShadow = true;
            scene.add(mesh);
            const shape = new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2));
            const body = new CANNON.Body({ mass: mass, material: world.defaultMaterial });
            body.addShape(shape); body.position.set(x, y, z);
            const q = new CANNON.Quaternion(); q.setFromEuler(rotX, rotY, rotZ); body.quaternion.copy(q);
            world.addBody(body);
            const obj = { mesh, body, type: 'static' };
            levelObjects.push(obj);
            return obj;
        }

        window.clearLevel = function() {
            levelObjects.forEach(obj => { scene.remove(obj.mesh); world.removeBody(obj.body); });
            levelObjects = []; obstacles = []; currentPos = { x: -5, y: -0.5, z: 0 };
            currentRespawnPos = { x: -5, y: 5, z: 0 }; checkpointPos = null; checkpointActivated = false; window.checkpointFlagMat = null;
            if(player) { scene.remove(player.mesh); world.removeBody(player.body); player = null; window.playerBody = null; window.playerMesh = null; }
            for(let uid in opponents) { scene.remove(opponents[uid].mesh); }
            opponents = {};
        }

        function createCheckpointVisual(x, y, z) {
            const poleGeo = new THREE.CylinderGeometry(0.5, 0.5, 10);
            const poleMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const pole = new THREE.Mesh(poleGeo, poleMat); pole.position.set(x, y + 5, z - 12); scene.add(pole);
            const dummyBody = new CANNON.Body({ mass: 0 }); 
            levelObjects.push({ mesh: pole, body: dummyBody });
            const flagGeo = new THREE.BoxGeometry(4, 3, 0.5);
            const flagMat = new THREE.MeshPhongMaterial({ color: 0xff0000 }); 
            const flag = new THREE.Mesh(flagGeo, flagMat); flag.position.set(x + 2, y + 8, z - 12); scene.add(flag);
            levelObjects.push({ mesh: flag, body: dummyBody });
            window.checkpointFlagMat = flagMat;
        }

        function buildLevelFromSegments(segments) {
            currentPos = { x: -5, y: -0.5, z: 0 };
            const midIndex = Math.floor(segments.length / 2);
            segments.forEach((seg, index) => {
                const baseColor = index % 2 === 0 ? 0xdddddd : 0xcccccc;
                if (index === midIndex) {
                    checkpointPos = { x: currentPos.x + 10, y: currentPos.y + 2, z: currentPos.z }; 
                    createCheckpointVisual(currentPos.x + 10, currentPos.y, currentPos.z);
                    createBox(25, 1, 25, currentPos.x + 10, currentPos.y - 0.2, currentPos.z, 0x66ff66);
                }
                switch(seg) {
                    case 'start': createBox(15, 1, 20, currentPos.x, currentPos.y, currentPos.z, 0x44cc44); currentPos.x += 15; break;
                    case 'path': createBox(30, 1, 10, currentPos.x + 15, currentPos.y, currentPos.z, baseColor); currentPos.x += 30; break;
                    case 'narrow': createBox(20, 1, 2, currentPos.x + 10, currentPos.y, currentPos.z, 0xffaa00); currentPos.x += 20; break;
                    case 'ramp_up': { const rampLen = 30; const rise = 10; const angle = Math.atan2(rise, rampLen); const hyp = Math.sqrt(rampLen*rampLen + rise*rise); createBox(hyp, 1, 10, currentPos.x + rampLen/2, currentPos.y + rise/2, currentPos.z, 0xff00ff, 0, 0, 0, angle); currentPos.x += rampLen; currentPos.y += rise; break; }
                    case 'ramp_down': { const rampLenD = 30; const drop = 10; const angleD = -Math.atan2(drop, rampLenD); const hypD = Math.sqrt(rampLenD*rampLenD + drop*drop); createBox(hypD, 1, 10, currentPos.x + rampLenD/2, currentPos.y - drop/2, currentPos.z, 0x00ffff, 0, 0, 0, angleD); currentPos.x += rampLenD; currentPos.y -= drop; break; }
                    case 'shift_left': createBox(Math.sqrt(800), 1, 10, currentPos.x + 10, currentPos.y, currentPos.z - 10, 0xffff00, 0, 0, -Math.PI/4, 0); currentPos.x += 20; currentPos.z -= 20; break;
                    case 'shift_right': createBox(Math.sqrt(800), 1, 10, currentPos.x + 10, currentPos.y, currentPos.z + 10, 0xffff00, 0, 0, Math.PI/4, 0); currentPos.x += 20; currentPos.z += 20; break;
                    case 'walls': createBox(25, 1, 10, currentPos.x + 12.5, currentPos.y, currentPos.z, baseColor); createBox(1, 4, 10, currentPos.x + 8, currentPos.y + 2, currentPos.z, 0x5555ff); createBox(1, 4, 10, currentPos.x + 16, currentPos.y + 2, currentPos.z, 0x5555ff); currentPos.x += 25; break;
                    case 'hammers': { createBox(25, 1, 10, currentPos.x + 12.5, currentPos.y, currentPos.z, 0x888888); const hX = currentPos.x + 12.5; const hY = currentPos.y; const hZ = currentPos.z; createBox(1, 6, 1, hX, hY + 3, hZ, 0x222222); const hammerHead = createBox(8, 1, 1, hX, hY + 6, hZ, 0xff2222, 10); hammerHead.body.type = CANNON.Body.KINEMATIC; obstacles.push({ ...hammerHead, type: 'spinner', speed: 3 }); currentPos.x += 25; break; }
                    case 'tilts': { for(let i=0; i<2; i++) { const p = createBox(8, 0.5, 8, currentPos.x + 8 + (i*10), currentPos.y + 0.5, currentPos.z, 0x33aaff, 10); p.body.type = CANNON.Body.KINEMATIC; obstacles.push({ ...p, type: 'tilt', speed: 1.5, offset: i }); } currentPos.x += 25; break; }
                    case 'split_hammers_walls': { createBox(40, 1, 8, currentPos.x + 20, currentPos.y, currentPos.z - 8, baseColor); const h1 = createBox(8, 1, 1, currentPos.x + 10, currentPos.y + 6, currentPos.z - 8, 0xff2222, 10); h1.body.type = CANNON.Body.KINEMATIC; obstacles.push({ ...h1, type: 'spinner', speed: 4 }); const h2 = createBox(8, 1, 1, currentPos.x + 30, currentPos.y + 6, currentPos.z - 8, 0xff2222, 10); h2.body.type = CANNON.Body.KINEMATIC; obstacles.push({ ...h2, type: 'spinner', speed: -4 }); createBox(40, 1, 8, currentPos.x + 20, currentPos.y, currentPos.z + 8, baseColor); createBox(1, 4, 8, currentPos.x + 10, currentPos.y + 2, currentPos.z + 8, 0x5555ff); createBox(1, 4, 8, currentPos.x + 20, currentPos.y + 2, currentPos.z + 8, 0x5555ff); createBox(1, 4, 8, currentPos.x + 30, currentPos.y + 2, currentPos.z + 8, 0x5555ff); currentPos.x += 40; break; }
                    case 'split_ramp_tunnel': { const riseH = 8; const angleH = Math.atan2(riseH, 20); const hypH = Math.sqrt(20*20 + riseH*riseH); createBox(hypH, 1, 8, currentPos.x + 10, currentPos.y + riseH/2, currentPos.z - 8, 0xff00ff, 0, 0, 0, angleH); createBox(10, 1, 8, currentPos.x + 25, currentPos.y + riseH, currentPos.z - 8, 0xff00ff); createBox(hypH, 1, 8, currentPos.x + 40, currentPos.y + riseH/2, currentPos.z - 8, 0xff00ff, 0, 0, 0, -angleH); createBox(50, 1, 8, currentPos.x + 25, currentPos.y, currentPos.z + 8, baseColor); createBox(50, 1, 8, currentPos.x + 25, currentPos.y + 5, currentPos.z + 8, 0x555555); currentPos.x += 50; break; }
                    case 'finish': { finishLineX = currentPos.x; createBox(20, 1, 20, currentPos.x + 10, currentPos.y, currentPos.z, 0xffd700); const arch = createBox(2, 8, 10, currentPos.x, currentPos.y + 4.5, currentPos.z, 0xffd700); arch.mesh.material.transparent = true; arch.mesh.material.opacity = 0.5; arch.body.collisionFilterGroup = 0; break; }
                }
            });
        }

        // --- Actors ---
        function createFaceTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128; const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffccaa'; ctx.fillRect(0, 0, 128, 128); ctx.fillStyle = '#000000';
            const eyeY = 50; const eyeXOffset = 20 + Math.random() * 15; const eyeSize = 8 + Math.random() * 10;
            ctx.beginPath(); ctx.arc(64 - eyeXOffset, eyeY, eyeSize, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(64 + eyeXOffset, eyeY, eyeSize, 0, Math.PI * 2); ctx.fill();
            ctx.lineWidth = 6; ctx.strokeStyle = '#000000'; ctx.beginPath();
            const mouthType = Math.floor(Math.random() * 4);
            if (mouthType === 0) ctx.arc(64, 80, 20, 0, Math.PI, false);
            else if (mouthType === 1) ctx.arc(64, 100, 20, Math.PI, 0, false);
            else if (mouthType === 2) ctx.arc(64, 90, 15, 0, Math.PI * 2);
            else { ctx.moveTo(44, 90); ctx.lineTo(84, 90); }
            ctx.stroke(); return new THREE.CanvasTexture(canvas);
        }

        function createHumanoid(color) {
            const group = new THREE.Group();
            const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const skinMat = new THREE.MeshPhongMaterial({ color: 0xffccaa }); 
            const faceTexture = createFaceTexture(); const faceMat = new THREE.MeshPhongMaterial({ color: 0xffccaa, map: faceTexture });
            const headMaterials = [skinMat, skinMat, skinMat, skinMat, faceMat, skinMat];
            const head = new THREE.Mesh(headGeo, headMaterials); head.position.y = 0.85; head.castShadow = true; group.add(head);
            const bodyGeo = new THREE.BoxGeometry(0.6, 0.7, 0.35); const bodyMat = new THREE.MeshPhongMaterial({ color: color }); 
            const body = new THREE.Mesh(bodyGeo, bodyMat); body.position.y = 0.2; body.castShadow = true; group.add(body);
            const armGeo = new THREE.BoxGeometry(0.2, 0.7, 0.2); const armMat = new THREE.MeshPhongMaterial({ color: 0xffccaa });
            const armL = new THREE.Mesh(armGeo, armMat); armL.position.set(-0.45, 0.2, 0); armL.name = "armL"; armL.castShadow = true; group.add(armL);
            const armR = new THREE.Mesh(armGeo, armMat); armR.position.set(0.45, 0.2, 0); armR.name = "armR"; armR.castShadow = true; group.add(armR);
            const legGeo = new THREE.BoxGeometry(0.22, 0.8, 0.22); const legMat = new THREE.MeshPhongMaterial({ color: 0x333333 }); 
            const legL = new THREE.Mesh(legGeo, legMat); legL.position.set(-0.2, -0.6, 0); legL.name = "legL"; legL.castShadow = true; group.add(legL);
            const legR = new THREE.Mesh(legGeo, legMat); legR.position.set(0.2, -0.6, 0); legR.name = "legR"; legR.castShadow = true; group.add(legR);
            return group;
        }

        function createPlayer() {
            const mesh = createHumanoid(0x00ff00); scene.add(mesh); playerMesh = mesh; window.playerMesh = mesh;
            const shape = new CANNON.Sphere(0.6); playerBody = new CANNON.Body({ mass: 1, fixedRotation: true, material: world.defaultMaterial });
            playerBody.addShape(shape); playerBody.position.set(-5, 5, 0); playerBody.linearDamping = 0.0; world.addBody(playerBody);
            player = { mesh, body: playerBody, isPlayer: true }; window.playerBody = playerBody;
        }

        function updatePhysics() {
            world.step(1/60);
            let isGrounded = false;
            for(let i = 0; i < world.contacts.length; i++) {
                const c = world.contacts[i];
                if(c.bi === playerBody || c.bj === playerBody) {
                    if(c.bi === playerBody) { if(c.ni.y < -0.5) isGrounded = true; } 
                    else { if(c.ni.y > 0.5) isGrounded = true; }
                }
            }
            if (isGrounded) lastGroundedTime = Date.now();
            const time = Date.now() * 0.001;
            obstacles.forEach(obs => {
                if(obs.type === 'spinner') obs.body.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), time * obs.speed);
                else if(obs.type === 'tilt') obs.body.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.sin(time * obs.speed + obs.offset) * 0.5);
                obs.mesh.position.copy(obs.body.position); obs.mesh.quaternion.copy(obs.body.quaternion);
            });

            if(gameActive) {
                // Checkpoint
                if(checkpointPos && !checkpointActivated && playerBody.position.x > checkpointPos.x) {
                    checkpointActivated = true; currentRespawnPos = { x: checkpointPos.x, y: checkpointPos.y + 10, z: checkpointPos.z };
                    if(window.checkpointFlagMat) window.checkpointFlagMat.color.setHex(0x00ff00);
                    playTone(880, 0.1, 'sine', 0.2); setTimeout(() => playTone(1100, 0.2, 'sine', 0.2), 100);
                    updateCommentary('checkpoint');
                }

                // Update Opponents
                for (const uid in window.opponentsData) {
                    const data = window.opponentsData[uid];
                    if(uid === myId) continue; 
                    if (!opponents[uid]) {
                        const mesh = createHumanoid(0xff0000); scene.add(mesh);
                        opponents[uid] = { mesh: mesh, lastPos: new THREE.Vector3(data.x, data.y, data.z) };
                    }
                    const opp = opponents[uid];
                    const currentPos = new THREE.Vector3(data.x, data.y, data.z);
                    const speed = currentPos.distanceTo(opp.lastPos) * 60; 
                    opp.lastPos.copy(currentPos);
                    opp.mesh.position.lerp(new THREE.Vector3(data.x, data.y - 0.1, data.z), 0.2); // Faster lerp for P2P
                    opp.mesh.rotation.y = data.rot;
                    // Anim
                    const armL = opp.mesh.getObjectByName('armL'); const armR = opp.mesh.getObjectByName('armR');
                    const legL = opp.mesh.getObjectByName('legL'); const legR = opp.mesh.getObjectByName('legR');
                    if(speed > 0.5) {
                        const runTime = Date.now() * 0.015;
                        if(armL) armL.rotation.x = Math.sin(runTime) * 0.8; if(armR) armR.rotation.x = -Math.sin(runTime) * 0.8;
                        if(legL) legL.rotation.x = -Math.sin(runTime) * 0.8; if(legR) legR.rotation.x = Math.sin(runTime) * 0.8;
                    } else {
                        if(armL) armL.rotation.x = 0; if(armR) armR.rotation.x = 0; if(legL) legL.rotation.x = 0; if(legR) legR.rotation.x = 0;
                    }
                }
                // Cleanup
                for (const uid in opponents) { if (!window.opponentsData[uid]) { scene.remove(opponents[uid].mesh); delete opponents[uid]; } }

                // Player Controls
                const baseSpeed = 30; const maxSpeed = 50; const acceleration = 0.15; const deceleration = 0.5;
                if (keys.w) playerMomentum = Math.min(playerMomentum + acceleration, maxSpeed);
                else playerMomentum = Math.max(playerMomentum - deceleration, baseSpeed);
                const pct = ((playerMomentum - baseSpeed) / (maxSpeed - baseSpeed)) * 100;
                document.getElementById('speed-bar').style.width = `${pct}%`;
                const force = new CANNON.Vec3(0, 0, 0);
                const fwdX = Math.cos(cameraAngle); const fwdZ = Math.sin(cameraAngle);
                const rightX = -Math.sin(cameraAngle); const rightZ = Math.cos(cameraAngle);
                if(keys.w) { force.x += fwdX * playerMomentum; force.z += fwdZ * playerMomentum; }
                if(keys.s) { force.x -= fwdX * (playerMomentum * 0.6); force.z -= fwdZ * (playerMomentum * 0.6); }
                if(keys.a) { force.x -= rightX * (playerMomentum * 0.8); force.z -= rightZ * (playerMomentum * 0.8); }
                if(keys.d) { force.x += rightX * (playerMomentum * 0.8); force.z += rightZ * (playerMomentum * 0.8); }
                playerBody.velocity.x = force.x * 0.5; playerBody.velocity.z = force.z * 0.5;
                if(keys.w && Math.abs(playerBody.velocity.y) > 0.5) { playerBody.velocity.x += fwdX * 0.2; playerBody.velocity.z += fwdZ * 0.2; }
                if(keys.space && (Date.now() - lastGroundedTime < 200)) { lastGroundedTime = 0; playerBody.velocity.y = 20; }
                if(playerBody.position.y < -30) {
                    playerBody.position.set(currentRespawnPos.x, currentRespawnPos.y, currentRespawnPos.z);
                    playerBody.velocity.set(0, 0, 0); playerMomentum = baseSpeed;
                    if(checkpointActivated) updateCommentary('fall'); else updateCommentary('fall');
                }
                checkFinish();
            }

            if(player) {
                player.mesh.position.copy(player.body.position); player.mesh.position.y -= 0.1; 
                const vel = player.body.velocity; const speed = Math.sqrt(vel.x*vel.x + vel.z*vel.z);
                if(speed > 0.5) player.mesh.rotation.y = Math.atan2(vel.x, vel.z); 
                const armL = player.mesh.getObjectByName('armL'); const armR = player.mesh.getObjectByName('armR');
                const legL = player.mesh.getObjectByName('legL'); const legR = player.mesh.getObjectByName('legR');
                if(speed > 1 && player.body.position.y > -10) {
                    const runTime = Date.now() * 0.015;
                    if(armL) armL.rotation.x = Math.sin(runTime) * 0.8; if(armR) armR.rotation.x = -Math.sin(runTime) * 0.8;
                    if(legL) legL.rotation.x = -Math.sin(runTime) * 0.8; if(legR) legR.rotation.x = Math.sin(runTime) * 0.8;
                } else {
                    if(armL) armL.rotation.x = 0; if(armR) armR.rotation.x = 0; if(legL) legL.rotation.x = 0; if(legR) legR.rotation.x = 0;
                }
            }
        }

        function checkFinish() {
            if(!hasFinished && playerBody.position.x > finishLineX) {
                hasFinished = true; window.hasFinished = true; showEndScreen(); updateCommentary('finish');
            }
            let myX = playerBody.position.x; let countAhead = 0;
            for(const uid in window.opponentsData) { if(window.opponentsData[uid].x > myX) countAhead++; }
            document.getElementById('rank').innerText = `Rank: ${countAhead + 1}`;
        }

        function showEndScreen() {
            window.gameActive = false; document.exitPointerLock();
            const winScreen = document.getElementById('win-screen');
            const leaderboardDiv = document.getElementById('final-leaderboard');
            const controlsDiv = document.getElementById('end-screen-controls');
            leaderboardDiv.innerHTML = ''; controlsDiv.innerHTML = '';
            let allPlayers = [];
            if (window.playerBody) allPlayers.push({ username: myUsername + " (You)", x: window.playerBody.position.x, finished: window.hasFinished, isLocal: true });
            for (const uid in window.opponentsData) {
                const p = window.opponentsData[uid]; if(uid === myId) continue;
                allPlayers.push({ username: p.username, x: p.x, finished: p.finished, isLocal: false });
            }
            allPlayers.sort((a, b) => { if (a.finished && !b.finished) return -1; if (!a.finished && b.finished) return 1; return b.x - a.x; });
            allPlayers.forEach((p, index) => {
                const row = document.createElement('div'); row.className = 'leaderboard-row';
                row.style.color = p.isLocal ? '#ffff00' : 'white'; row.style.fontWeight = p.isLocal ? 'bold' : 'normal';
                const status = p.finished ? '<span style="color:#44cc44">FINISHED</span>' : Math.floor(p.x) + 'm';
                row.innerHTML = `<span>#${index+1} ${p.username}</span><span>${status}</span>`;
                leaderboardDiv.appendChild(row);
            });
            const menuBtn = document.createElement('button'); menuBtn.innerText = "BACK TO MENU"; menuBtn.onclick = window.backToMenu; menuBtn.style.marginRight = "10px"; controlsDiv.appendChild(menuBtn);
            if (isHost) {
                const nextBtn = document.createElement('button'); nextBtn.innerText = "START NEXT LEVEL"; nextBtn.style.backgroundColor = "#00ffff"; nextBtn.style.color = "#000"; nextBtn.onclick = window.hostStartGame; controlsDiv.appendChild(nextBtn);
            } else {
                const waitText = document.createElement('p'); waitText.innerText = "Waiting for host to start next level..."; waitText.style.fontSize = "0.9em"; waitText.style.color = "#aaa"; waitText.style.marginTop = "10px"; controlsDiv.appendChild(waitText);
            }
            winScreen.style.display = 'block';
        }

        function animate() {
            requestAnimationFrame(animate); updatePhysics();
            if(playerBody) {
                const targetPos = playerBody.position; const radius = 14; const camHeight = 10;
                const camX = targetPos.x - radius * Math.cos(cameraAngle); const camZ = targetPos.z - radius * Math.sin(cameraAngle);
                camera.position.lerp(new THREE.Vector3(camX, targetPos.y + camHeight, camZ), 0.1);
                camera.lookAt(targetPos.x, targetPos.y + 2, targetPos.z);
            }
            if (backgroundObjects.length > 0) backgroundObjects[0].position.copy(camera.position);
            renderer.render(scene, camera);
        }

        window.addEventListener('load', () => { init(); });
    </script>
</body>
</html>
