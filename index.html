<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tumble Dudes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDoc, getDocs, onSnapshot, updateDoc, deleteDoc, serverTimestamp, query, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Config & Globals ---
        // --- CONFIGURATION SECTION ---
        // YOUR FIREBASE CONFIG (Tumble Dudes)
        const myFirebaseConfig = {
            apiKey: "AIzaSyAZcHTFks9pRqcHncpeF6s5ZjmGLHHe5MQ",
            authDomain: "tumble-dudes-4330d.firebaseapp.com",
            projectId: "tumble-dudes-4330d",
            storageBucket: "tumble-dudes-4330d.firebasestorage.app",
            messagingSenderId: "565414083389",
            appId: "1:565414083389:web:adfa327e7afcbd58746354"
        };
        // -----------------------------

        let firebaseConfig;
        let appId;
        
        try {
            // Attempt to use Preview environment config first
            if (typeof __firebase_config !== 'undefined') {
                firebaseConfig = JSON.parse(__firebase_config);
                appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            } else {
                throw new Error("No env config");
            }
        } catch (e) {
            // Fallback to manual config for Production/Vercel
            console.log("Using manual Firebase config (Production Mode)");
            firebaseConfig = myFirebaseConfig;
            // This 'appId' is used for the database path, not the firebase config appId
            appId = "tumble-dudes-prod"; 
        }

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        window.db = db;
        window.auth = auth;
        window.appId = appId;
        
        let currentUser = null;
        let currentLobbyId = null;
        let isHost = false;
        let lobbyUnsubscribe = null;
        let playersUnsubscribe = null;
        let myUsername = "Bean";

        // Auth Flow
        const initAuth = async () => {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (e) {
                console.warn("Auth fallback:", e);
                // Standard anonymous login for Vercel deployment
                await signInAnonymously(auth);
            }
        };

        initAuth();

        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                console.log("Logged in as", user.uid);
                document.getElementById('auth-status').innerText = "Connected to Server";
                document.getElementById('lobby-ui').style.display = 'flex';
                document.getElementById('loading-overlay').style.display = 'none';
            }
        });

        // --- Network Logic ---
        
        window.createLobby = async () => {
            if (!currentUser) return;
            const btn = document.querySelector('button[onclick="window.createLobby()"]');
            btn.innerText = "CREATING...";
            btn.disabled = true;

            try {
                const username = document.getElementById('username-input').value || "Host Dude";
                myUsername = username;
                
                const code = Math.random().toString(36).substring(2, 8).toUpperCase();
                currentLobbyId = code;
                isHost = true;

                const lobbyRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', code);
                
                await setDoc(lobbyRef, {
                    hostId: currentUser.uid,
                    status: 'waiting',
                    levelSegments: [], 
                    createdAt: serverTimestamp()
                });

                const playerRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', code, 'players', currentUser.uid);
                await setDoc(playerRef, {
                    username: username,
                    isHost: true,
                    joinedAt: serverTimestamp(),
                    state: { x: -5, y: 5, z: 0, rot: 0, finished: false }
                });

                enterLobbyUI(code);
            } catch (error) {
                console.error("Create Lobby Error:", error);
                alert("Failed to create lobby: " + error.message + "\n\n1. Did you enable Anonymous Auth?\n2. Are Database Rules in Test Mode?");
                btn.innerText = "HOST GAME";
                btn.disabled = false;
            }
        }

        window.joinLobby = async () => {
            if (!currentUser) return;
            const btn = document.querySelector('button[onclick="window.joinLobby()"]');
            btn.innerText = "JOINING...";
            btn.disabled = true;

            try {
                const code = document.getElementById('code-input').value.toUpperCase();
                const username = document.getElementById('username-input').value || "Guest Dude";
                
                if(!code) throw new Error("Please enter a lobby code");
                
                myUsername = username;
                currentLobbyId = code;
                isHost = false;

                const lobbyRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', code);
                const snap = await getDoc(lobbyRef);

                if (!snap.exists()) {
                    throw new Error("Lobby not found! Check the code.");
                }
                
                if (snap.data().status === 'playing') {
                    throw new Error("Game already in progress!");
                }

                const playersRef = collection(db, 'artifacts', appId, 'public', 'data', 'lobbies', code, 'players');
                const playersSnap = await getDocs(playersRef);
                if (playersSnap.size >= 6) {
                    throw new Error("Lobby is full! Max 6 players.");
                }

                const playerRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', code, 'players', currentUser.uid);
                await setDoc(playerRef, {
                    username: username,
                    isHost: false,
                    joinedAt: serverTimestamp(),
                    state: { x: -5, y: 5, z: 0, rot: 0, finished: false }
                });

                enterLobbyUI(code);
            } catch (error) {
                console.error("Join Error:", error);
                alert(error.message);
                btn.innerText = "JOIN GAME";
                btn.disabled = false;
            }
        }

        function enterLobbyUI(code) {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('wait-room').style.display = 'flex';
            document.getElementById('lobby-code-display').innerText = code;

            if(!isHost) document.getElementById('start-btn').style.display = 'none';

            const lobbyRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', code);
            lobbyUnsubscribe = onSnapshot(lobbyRef, (doc) => {
                const data = doc.data();
                if (data && data.status === 'playing') {
                    document.getElementById('ui').style.display = 'block'; 
                    document.getElementById('lobby-ui').style.display = 'none';
                    // Trigger game start logic, this handles cleanup and rebuilding
                    window.startMultiplayerGame(data.levelSegments);
                }
            });

            const playersRef = collection(db, 'artifacts', appId, 'public', 'data', 'lobbies', code, 'players');
            playersUnsubscribe = onSnapshot(playersRef, (snapshot) => {
                const list = document.getElementById('player-list');
                list.innerHTML = '';
                window.opponentsData = {}; 
                
                let count = 0;
                snapshot.forEach(doc => {
                    const p = doc.data();
                    const li = document.createElement('li');
                    li.innerText = `${p.username} ${p.isHost ? 'ðŸ‘‘' : ''}`;
                    list.appendChild(li);
                    
                    if (doc.id !== currentUser.uid) {
                        window.opponentsData[doc.id] = p; 
                    }
                    count++;
                });
                document.getElementById('player-count').innerText = `${count} / 6 Players`;
            });
        }

        window.hostStartGame = async () => {
            if(!isHost) return;
            const btn = document.getElementById('start-btn');
            const wasText = btn.innerText;
            btn.disabled = true;
            btn.innerText = "STARTING...";

            try {
                const level = window.generateRandomLevelStructure(); 
                
                const lobbyRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', currentLobbyId);
                // We add a timestamp 'round' to force a change event if the level is same (unlikely but safe)
                await updateDoc(lobbyRef, {
                    status: 'playing',
                    levelSegments: level,
                    roundId: Date.now()
                });
                
                // If this was triggered from End Screen, reset button text for next time
                setTimeout(() => {
                    btn.disabled = false;
                    btn.innerText = wasText;
                }, 2000);

            } catch (error) {
                console.error("Start Game Error:", error);
                alert("Failed to start game: " + error.message + "\n\nCheck Firebase Database Rules (Write permissions).");
                btn.disabled = false;
                btn.innerText = "START RACE (ANYTIME)";
            }
        }

        // Properly reset state without reload
        window.backToMenu = function() {
            // UI Reset
            document.getElementById('win-screen').style.display = 'none';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('lobby-ui').style.display = 'flex';
            document.getElementById('main-menu').style.display = 'block';
            document.getElementById('wait-room').style.display = 'none';
            
            // Reset buttons
            const createBtn = document.querySelector('button[onclick="window.createLobby()"]');
            createBtn.innerText = "HOST GAME";
            createBtn.disabled = false;
            
            const joinBtn = document.querySelector('button[onclick="window.joinLobby()"]');
            joinBtn.innerText = "JOIN GAME";
            joinBtn.disabled = false;
            
            const startBtn = document.getElementById('start-btn');
            startBtn.innerText = "START RACE (ANYTIME)";
            startBtn.disabled = false;

            // Game State Reset
            window.gameActive = false;
            window.hasFinished = false;
            window.playerMomentum = 20;
            currentLobbyId = null;
            isHost = false;

            // Cleanup Network Listeners
            if (lobbyUnsubscribe) { lobbyUnsubscribe(); lobbyUnsubscribe = null; }
            if (playersUnsubscribe) { playersUnsubscribe(); playersUnsubscribe = null; }

            // Cleanup Scene
            window.clearLevel(); 
            if (window.playerBody) {
                // Main cleanup handled by clearLevel, ensure physics clear
            }
            window.opponentsData = {};
            
            window.changeMusicTrack();
        }

        setInterval(async () => {
            if (window.gameActive && currentUser && currentLobbyId) {
                const playerRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', currentLobbyId, 'players', currentUser.uid);
                updateDoc(playerRef, {
                    "state.x": window.playerBody.position.x,
                    "state.y": window.playerBody.position.y,
                    "state.z": window.playerBody.position.z,
                    "state.rot": window.playerMesh.rotation.y, 
                    "state.finished": window.hasFinished
                }).catch(e => {}); 
            }
        }, 100); 

        // --- Leaderboard Logic ---
        window.showEndScreen = function() {
            window.gameActive = false;
            document.exitPointerLock();
            const winScreen = document.getElementById('win-screen');
            const leaderboardDiv = document.getElementById('final-leaderboard');
            const controlsDiv = document.getElementById('end-screen-controls');
            
            leaderboardDiv.innerHTML = ''; // Clear previous
            controlsDiv.innerHTML = '';    // Clear previous buttons

            // --- 1. POPULATE LEADERBOARD ---
            let allPlayers = [];
            
            // Add Self
            if (window.playerBody) {
                allPlayers.push({
                    username: myUsername + " (You)",
                    x: window.playerBody.position.x,
                    finished: window.hasFinished,
                    isLocal: true
                });
            }

            // Add Opponents
            for (const uid in window.opponentsData) {
                const p = window.opponentsData[uid];
                if(p.state) {
                    allPlayers.push({
                        username: p.username,
                        x: p.state.x,
                        finished: p.state.finished,
                        isLocal: false
                    });
                }
            }

            // Sort: Finished first, then by distance
            allPlayers.sort((a, b) => {
                if (a.finished && !b.finished) return -1;
                if (!a.finished && b.finished) return 1;
                return b.x - a.x; 
            });

            // Render Rows
            allPlayers.forEach((p, index) => {
                const row = document.createElement('div');
                row.className = 'leaderboard-row';
                row.style.color = p.isLocal ? '#ffff00' : 'white';
                row.style.fontWeight = p.isLocal ? 'bold' : 'normal';
                
                const status = p.finished ? '<span style="color:#44cc44">FINISHED</span>' : Math.floor(p.x) + 'm';
                
                row.innerHTML = `
                    <span>#${index+1} ${p.username}</span>
                    <span>${status}</span>
                `;
                leaderboardDiv.appendChild(row);
            });

            // --- 2. POPULATE CONTROLS ---
            const menuBtn = document.createElement('button');
            menuBtn.innerText = "BACK TO MENU";
            menuBtn.onclick = window.backToMenu;
            menuBtn.style.marginRight = "10px";
            controlsDiv.appendChild(menuBtn);

            if (isHost) {
                const nextBtn = document.createElement('button');
                nextBtn.innerText = "START NEXT LEVEL";
                nextBtn.style.backgroundColor = "#00ffff";
                nextBtn.style.color = "#000";
                nextBtn.onclick = window.hostStartGame;
                controlsDiv.appendChild(nextBtn);
            } else {
                const waitText = document.createElement('p');
                waitText.innerText = "Waiting for host to start next level...";
                waitText.style.fontSize = "0.9em";
                waitText.style.color = "#aaa";
                waitText.style.marginTop = "10px";
                controlsDiv.appendChild(waitText);
            }

            winScreen.style.display = 'block';
        }

    </script>

    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #222; }
        
        /* Lobby UI Styles */
        #lobby-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #6a0dad, #222);
            display: none; /* Flex when active */
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; color: white;
        }

        .panel {
            background: rgba(0,0,0,0.85); 
            padding: 30px; 
            border-radius: 20px;
            border: 2px solid #ff00ff; 
            text-align: center; 
            width: 100%;
            max-width: 400px;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            box-sizing: border-box;
        }

        input {
            width: 100%; padding: 12px; margin: 10px 0; background: #333;
            border: 1px solid #555; color: white; border-radius: 8px; box-sizing: border-box;
            text-transform: uppercase; text-align: center; letter-spacing: 2px;
        }

        button.btn-primary {
            width: 100%; padding: 12px; background: #ff00ff; color: white;
            border: none; border-radius: 8px; font-weight: bold; cursor: pointer;
            margin-top: 10px; transition: 0.2s;
        }
        button.btn-primary:hover { background: #d400d4; transform: scale(1.02); }
        button.btn-primary:disabled { background: #555; cursor: not-allowed; transform: none; }

        button.btn-secondary {
            background: transparent; 
            border: 1px solid #777; 
            color: #aaa;
            padding: 8px 16px;
            margin-top: 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        button.btn-secondary:hover { border-color: white; color: white; }

        #player-list {
            list-style: none; padding: 0; margin: 20px 0; text-align: left;
            width: 100%; 
            max-height: 150px; overflow-y: auto;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }
        #player-list li {
            padding: 10px; border-bottom: 1px solid #444; font-size: 1.1em;
        }

        #code-display {
            font-size: 2.5em; 
            font-family: monospace; color: #00ffff;
            margin: 10px 0; letter-spacing: 5px;
            font-weight: bold;
        }

        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 200; color: #ff00ff;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5em;
        }

        /* Game UI */
        #ui {
            position: absolute; top: 20px; left: 20px; color: white; pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8); z-index: 10;
            display: none; /* Hidden until game starts */
            flex-direction: column; gap: 10px;
        }

        #speed-meter {
            width: 200px; height: 20px; background: rgba(0,0,0,0.5);
            border: 2px solid white; border-radius: 10px; overflow: hidden;
            margin-top: 5px;
        }
        #speed-bar {
            width: 0%; height: 100%; background: linear-gradient(90deg, #ffff00, #ff0000);
            transition: width 0.1s;
        }

        #commentary-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            border-left: 4px solid #ff00ff;
            max-width: 400px;
            font-style: italic;
            font-size: 1.1rem;
            color: #fff;
            margin-top: 10px;
            transition: opacity 0.5s;
            opacity: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #win-screen {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(30, 30, 30, 0.95); padding: 40px; border-radius: 20px;
            text-align: center; color: white; box-shadow: 0 0 50px rgba(0,0,0,0.5); z-index: 20;
            width: 400px; border: 2px solid #ff00ff;
        }

        #final-leaderboard {
            width: 100%;
            margin: 20px auto;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            box-sizing: border-box;
        }
        .leaderboard-row {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 1.1em;
        }
        .leaderboard-row:last-child {
            border-bottom: none;
        }

        #end-screen-controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        #end-screen-controls button {
            background: #ff00ff; color: white; border: none; padding: 10px 20px;
            font-size: 1rem; border-radius: 10px; cursor: pointer;
            transition: transform 0.1s;
        }
        #end-screen-controls button:hover { background: #d400d4; transform: scale(1.05); }

        .mute-btn {
            position: absolute; bottom: 20px; left: 20px; z-index: 90;
            background: rgba(0,0,0,0.5); padding: 5px 10px; font-size: 0.8rem;
            pointer-events: auto !important; color: white; border: 1px solid white; border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">Loading Servers...</div>

    <!-- Lobby UI -->
    <div id="lobby-ui">
        <h1 style="margin-bottom: 0;">TUMBLE DUDES</h1>
        <p style="color: #ccc; margin-top: 5px;">Multiplayer Edition</p>
        
        <div id="auth-status" style="margin-bottom: 20px; color: #00ffff;">Connecting...</div>

        <!-- Main Menu -->
        <div id="main-menu" class="panel">
            <input type="text" id="username-input" placeholder="USERNAME" maxlength="10">
            <div style="border-top: 1px solid #444; width: 100%; margin: 20px 0;"></div>
            <button class="btn-primary" onclick="window.createLobby()">HOST GAME</button>
            <div style="margin: 15px 0; color: #aaa;">- OR -</div>
            <input type="text" id="code-input" placeholder="ENTER CODE">
            <button class="btn-primary" onclick="window.joinLobby()">JOIN GAME</button>
            <div style="margin-top: 10px; font-size: 0.7em; color: #666;">v2.7 (Speed+Fix)</div>
        </div>

        <!-- Wait Room -->
        <div id="wait-room" class="panel" style="display: none;">
            <h3 style="margin: 0; color: #ff00ff;">LOBBY CODE</h3>
            <div id="code-display"><span id="lobby-code-display">??????</span></div>
            <div id="player-count">1 / 6 Players</div>
            <ul id="player-list">
                <!-- Players go here -->
            </ul>
            <button id="start-btn" class="btn-primary" onclick="window.hostStartGame()">START RACE (ANYTIME)</button>
            <p style="font-size: 0.8em; color: #aaa; margin-top: 10px;">Waiting for host...</p>
            <button class="btn-secondary" onclick="window.backToMenu()">Cancel</button>
        </div>
    </div>

    <!-- Game UI -->
    <div id="ui">
        <div>
            <h1 style="margin:0;">TUMBLE DUDES</h1>
            <div id="rank">Rank: -- / --</div>
            <div id="speed-meter"><div id="speed-bar"></div></div>
        </div>
        <div id="commentary-box">
            <span id="commentary-wave">ðŸ”Š</span>
            <span id="commentary-text">waiting for sportscaster...</span>
        </div>
    </div>

    <button class="mute-btn" onclick="toggleMusic()">ðŸŽµ Toggle Music</button>

    <div id="win-screen">
        <h2 id="win-text" style="color: #44cc44; margin-top:0;">FINISHED!</h2>
        <div id="final-leaderboard">
            <!-- Leaderboard Items Injected JS -->
        </div>
        <div id="end-screen-controls">
            <!-- Buttons injected JS -->
        </div>
    </div>

    <script>
        // --- Gemini Configuration ---
        const apiKey = ""; 
        
        // --- Three/Cannon Vars ---
        let scene, camera, renderer, world;
        let player, playerBody, playerMesh; // Global for networking
        let opponents = {}; // Map of userId -> { mesh, targetPos, targetRot }
        window.opponentsData = {}; // Raw data from Firestore
        let obstacles = [];
        let gameActive = false;
        let finishLineX = 0;
        let lastCommentaryTime = 0;
        let playerMomentum = 20; 
        let hasFinished = false;
        
        // Checkpoint System
        let currentRespawnPos = { x: -5, y: 5, z: 0 };
        let checkpointPos = null; // Store {x, y, z}
        let checkpointActivated = false;
        window.checkpointFlagMat = null; 

        // Expose globals for Module script
        window.playerBody = null;
        window.playerMesh = null;
        window.gameActive = false;
        window.hasFinished = false;

        // Camera State
        let cameraAngle = 0;
        let isPointerLocked = false;
        
        // Audio
        let audioCtx;
        let isMuted = false;
        let noteIndex = 0;
        let isPlayingMusic = false;
        let currentTrack = null;
        
        const keys = { w: false, a: false, s: false, d: false, space: false };
        
        // --- Initialization ---
        function init() {
            if (typeof THREE === 'undefined' || typeof CANNON === 'undefined') {
                console.error("Three.js or Cannon.js not loaded.");
                return;
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x6a0dad); 
            scene.fog = new THREE.FogExp2(0x6a0dad, 0.006);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);
            
            const sun = new THREE.DirectionalLight(0xffaa00, 0.8);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            sun.shadow.camera.left = -100; sun.shadow.camera.right = 100;
            sun.shadow.camera.top = 100; sun.shadow.camera.bottom = -100;
            scene.add(sun);

            const purpleLight = new THREE.PointLight(0xff00ff, 0.8, 200);
            purpleLight.position.set(50, 50, 50);
            scene.add(purpleLight);

            world = new CANNON.World();
            world.gravity.set(0, -30, 0); 
            world.broadphase = new CANNON.NaiveBroadphase();
            
            const defaultMaterial = new CANNON.Material('default');
            const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
                friction: 0.3,
                restitution: 0.1,
            });
            world.addContactMaterial(defaultContactMaterial);

            createBackgroundScenery();
            
            // We do NOT create player or level here anymore.
            // We wait for startMultiplayerGame()

            // Input Handling
            window.addEventListener('keydown', (e) => { 
                let key = e.key.toLowerCase();
                if (key === ' ') key = 'space'; 
                if(keys.hasOwnProperty(key)) keys[key] = true; 
            });
            window.addEventListener('keyup', (e) => { 
                let key = e.key.toLowerCase();
                if (key === ' ') key = 'space';
                if(keys.hasOwnProperty(key)) keys[key] = false; 
            });
            window.addEventListener('resize', onWindowResize);

            document.addEventListener('click', () => {
                if (!audioCtx) initAudio();
                if (window.gameActive && !isPointerLocked) {
                    document.body.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === document.body;
            });

            document.addEventListener('mousemove', (e) => {
                if (isPointerLocked) {
                    cameraAngle += e.movementX * 0.002;
                }
            });
            
            animate();
        }

        // --- MultiPlayer Start ---
        window.startMultiplayerGame = function(levelSegments) {
            // Hide End Screen if open
            document.getElementById('win-screen').style.display = 'none';
            
            clearLevel();
            buildLevelFromSegments(levelSegments);
            createPlayer();
            
            // Note: Opponents are created dynamically in the update loop based on window.opponentsData
            
            window.gameActive = true;
            gameActive = true;
            window.hasFinished = false;
            hasFinished = false;
            
            if (!audioCtx) initAudio();
            
            window.changeMusicTrack(); // Shuffle music on start
            updateCommentary('start');
        }

        // --- Audio System ---
        
        const musicTracks = [
            {
                name: "Funky Bean",
                tempo: 250,
                bass: [110, 110, 130, 146, 110, 110, 98, 98],
                melody: [440, 0, 523, 440, 0, 587, 523, 0],
                bassType: 'triangle', melodyType: 'square'
            },
            {
                name: "Hyper Space",
                tempo: 200, // Faster interval
                bass: [65, 0, 65, 0, 73, 0, 73, 0],
                melody: [523, 523, 784, 0, 659, 0, 523, 0], 
                bassType: 'sawtooth', melodyType: 'sawtooth'
            },
            {
                name: "Retro Dash",
                tempo: 280, 
                bass: [87, 87, 98, 98, 110, 110, 130, 0], 
                melody: [698, 0, 659, 0, 587, 587, 523, 0],
                bassType: 'square', melodyType: 'triangle'
            }
        ];
        
        window.changeMusicTrack = function() {
            currentTrack = musicTracks[Math.floor(Math.random() * musicTracks.length)];
            // Reset interval if running will handle next loop
        }
        
        // Init with one
        currentTrack = musicTracks[0];

        function initAudio() {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                if(audioCtx.state === 'suspended') audioCtx.resume();
                startMusicLoop();
            } catch(e) { console.error("Audio init failed", e); }
        }

        function toggleMusic() {
            isMuted = !isMuted;
            if(isMuted && audioCtx) audioCtx.suspend();
            if(!isMuted && audioCtx) audioCtx.resume();
        }

        function playTone(freq, duration, type='sine', vol=0.1) {
            if (!audioCtx || isMuted) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function startMusicLoop() {
            if(isPlayingMusic) return;
            isPlayingMusic = true;
            
            // Internal loop function to handle variable tempo
            const loop = () => {
                if(!audioCtx || isMuted || audioCtx.state !== 'running') {
                     setTimeout(loop, 250); return;
                }
                
                const track = currentTrack;
                playTone(track.bass[noteIndex % 8], 0.2, track.bassType, 0.15);
                if(track.melody[noteIndex % 8] !== 0) {
                    playTone(track.melody[noteIndex % 8], 0.1, track.melodyType, 0.05);
                }
                if(noteIndex % 2 === 0) playTone(2000 + Math.random()*500, 0.05, 'sawtooth', 0.02);
                noteIndex++;
                
                setTimeout(loop, track.tempo);
            };
            loop();
        }

        async function playPCM(base64Data) {
            if(!audioCtx) initAudio();
            if(audioCtx.state === 'suspended') await audioCtx.resume();

            const binaryString = atob(base64Data);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            const int16 = new Int16Array(bytes.buffer);
            const float32 = new Float32Array(int16.length);
            for(let i=0; i<int16.length; i++) {
                float32[i] = int16[i] / 32768.0;
            }
            const buffer = audioCtx.createBuffer(1, float32.length, 24000);
            buffer.copyToChannel(float32, 0);
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(audioCtx.destination);
            source.start();
            
            document.getElementById('commentary-wave').style.display = 'inline-block';
            source.onended = () => {
                 document.getElementById('commentary-wave').style.display = 'none';
            };
        }

        // --- Visuals & Level ---

        function createBackgroundScenery() {
            const geom = new THREE.IcosahedronGeometry(15, 0);
            for(let i=0; i<80; i++) {
                const mat = new THREE.MeshPhongMaterial({ 
                    color: Math.random() * 0xffffff, 
                    transparent: true, 
                    opacity: 0.3,
                    flatShading: true
                });
                const mesh = new THREE.Mesh(geom, mat);
                mesh.position.set(
                    (Math.random() - 0.5) * 600,
                    (Math.random() - 0.5) * 400 + 40,
                    (Math.random() - 0.5) * 400
                );
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                scene.add(mesh);
            }
        }

        // Expose for host
        window.generateRandomLevelStructure = function() {
            const types = ['path', 'narrow', 'hammers', 'tilts', 'walls', 'ramp_up', 'ramp_down', 'shift_left', 'shift_right', 'split_hammers_walls', 'split_ramp_tunnel'];
            const length = 25 + Math.floor(Math.random() * 15); 
            const level = ['start'];
            for(let i=0; i<length; i++) {
                level.push(types[Math.floor(Math.random() * types.length)]);
            }
            level.push('finish');
            return level;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        async function updateCommentary(eventType) {
            // Simplified commentary for now to reduce API calls in multiplayer
            if(!gameActive) return;
            const now = Date.now();
            if(now - lastCommentaryTime < 8000 && eventType !== 'checkpoint') return;
            lastCommentaryTime = now;

            const boxText = document.getElementById('commentary-text');
            let promptText = "";

            if (eventType === 'start') promptText = "Say excitedly: Welcome to Tumble Dudes Multiplayer! Race to the finish!";
            else if (eventType === 'fall') promptText = "Say mockingly: Someone took a massive fall!";
            else if (eventType === 'checkpoint') promptText = "Say fast: Checkpoint reached!";
            else if (eventType === 'finish') promptText = `Say cheeringly: We have a finisher! Incredible performance!`;
            
            if(!promptText) return;

            // Fallback visuals immediately
            boxText.innerText = `ðŸŽ™ï¸ "${eventType.toUpperCase()}"`;
            document.getElementById('commentary-box').style.opacity = 1;

            if (!apiKey) return; // Prevent API call if no key

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: promptText }] }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName: "Puck" }
                                }
                            }
                        }
                    })
                });

                const data = await response.json();
                // FIX: Optional chaining
                const pcmData = data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                
                if(pcmData) {
                    playPCM(pcmData);
                    // visual text already set above
                }
            } catch (e) { console.error("TTS Error", e); }
        }


        // --- Level System ---

        let levelObjects = [];
        let currentPos = { x: -5, y: -0.5, z: 0 };

        function createBox(w, h, d, x, y, z, color, mass=0, rotX=0, rotY=0, rotZ=0) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshPhongMaterial({ color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.rotation.set(rotX, rotY, rotZ);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const shape = new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2));
            const body = new CANNON.Body({ mass: mass, material: world.defaultMaterial });
            body.addShape(shape);
            body.position.set(x, y, z);
            
            const q = new CANNON.Quaternion();
            q.setFromEuler(rotX, rotY, rotZ);
            body.quaternion.copy(q);

            world.addBody(body);

            const obj = { mesh, body, type: 'static' };
            levelObjects.push(obj);
            return obj;
        }

        window.clearLevel = function() {
            levelObjects.forEach(obj => {
                scene.remove(obj.mesh);
                world.removeBody(obj.body);
            });
            levelObjects = [];
            obstacles = [];
            currentPos = { x: -5, y: -0.5, z: 0 };
            
            // Checkpoint Reset
            currentRespawnPos = { x: -5, y: 5, z: 0 };
            checkpointPos = null;
            checkpointActivated = false;
            window.checkpointFlagMat = null;

            // Cleanup player if existing
            if(player) {
                scene.remove(player.mesh);
                world.removeBody(player.body);
                player = null;
                window.playerBody = null;
                window.playerMesh = null;
            }
            // Cleanup opponents
            for(let uid in opponents) {
                scene.remove(opponents[uid].mesh);
            }
            opponents = {};
        }

        function createCheckpointVisual(x, y, z) {
            // Pole
            const poleGeo = new THREE.CylinderGeometry(0.5, 0.5, 10);
            const poleMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.set(x, y + 5, z - 12); // To the left
            scene.add(pole);
            const dummyBody = new CANNON.Body({ mass: 0 }); // won't be added to world
            levelObjects.push({ mesh: pole, body: dummyBody });

            // Flag
            const flagGeo = new THREE.BoxGeometry(4, 3, 0.5);
            const flagMat = new THREE.MeshPhongMaterial({ color: 0xff0000 }); // Red
            const flag = new THREE.Mesh(flagGeo, flagMat);
            flag.position.set(x + 2, y + 8, z - 12);
            scene.add(flag);
            levelObjects.push({ mesh: flag, body: dummyBody });
            
            window.checkpointFlagMat = flagMat;
        }

        function buildLevelFromSegments(segments) {
            currentPos = { x: -5, y: -0.5, z: 0 };
            const midIndex = Math.floor(segments.length / 2);
            
            segments.forEach((seg, index) => {
                const baseColor = index % 2 === 0 ? 0xdddddd : 0xcccccc;

                // Checkpoint Logic: Place at start of middle segment
                if (index === midIndex) {
                    checkpointPos = { ...currentPos }; // Save full coordinate
                    createCheckpointVisual(currentPos.x, currentPos.y, currentPos.z);
                }

                switch(seg) {
                    case 'start':
                        createBox(15, 1, 20, currentPos.x, currentPos.y, currentPos.z, 0x44cc44);
                        currentPos.x += 15;
                        break;
                    case 'path':
                        createBox(30, 1, 10, currentPos.x + 15, currentPos.y, currentPos.z, baseColor);
                        currentPos.x += 30;
                        break;
                    case 'narrow':
                        createBox(20, 1, 2, currentPos.x + 10, currentPos.y, currentPos.z, 0xffaa00);
                        currentPos.x += 20;
                        break;
                    case 'ramp_up':
                        const rampLen = 30; const rise = 10;
                        const angle = Math.atan2(rise, rampLen); 
                        const hyp = Math.sqrt(rampLen*rampLen + rise*rise);
                        createBox(hyp, 1, 10, currentPos.x + rampLen/2, currentPos.y + rise/2, currentPos.z, 0xff00ff, 0, 0, 0, angle);
                        currentPos.x += rampLen; currentPos.y += rise;
                        break;
                    case 'ramp_down':
                        const rampLenD = 30; const drop = 10;
                        const angleD = -Math.atan2(drop, rampLenD);
                        const hypD = Math.sqrt(rampLenD*rampLenD + drop*drop);
                        createBox(hypD, 1, 10, currentPos.x + rampLenD/2, currentPos.y - drop/2, currentPos.z, 0x00ffff, 0, 0, 0, angleD);
                        currentPos.x += rampLenD; currentPos.y -= drop;
                        break;
                    case 'shift_left':
                        const diagLen = Math.sqrt(20*20 + 20*20);
                        createBox(diagLen, 1, 10, currentPos.x + 10, currentPos.y, currentPos.z - 10, 0xffff00, 0, 0, -Math.PI/4, 0);
                        currentPos.x += 20; currentPos.z -= 20;
                        break;
                    case 'shift_right':
                        const diagLenR = Math.sqrt(20*20 + 20*20);
                        createBox(diagLenR, 1, 10, currentPos.x + 10, currentPos.y, currentPos.z + 10, 0xffff00, 0, 0, Math.PI/4, 0);
                        currentPos.x += 20; currentPos.z += 20;
                        break;
                    case 'walls':
                        createBox(25, 1, 10, currentPos.x + 12.5, currentPos.y, currentPos.z, baseColor);
                        createBox(1, 4, 10, currentPos.x + 8, currentPos.y + 2, currentPos.z, 0x5555ff);
                        createBox(1, 4, 10, currentPos.x + 16, currentPos.y + 2, currentPos.z, 0x5555ff);
                        currentPos.x += 25;
                        break;
                    case 'hammers':
                        createBox(25, 1, 10, currentPos.x + 12.5, currentPos.y, currentPos.z, 0x888888);
                        const hX = currentPos.x + 12.5; const hY = currentPos.y; const hZ = currentPos.z;
                        const hammerBase = createBox(1, 6, 1, hX, hY + 3, hZ, 0x222222);
                        const hammerHead = createBox(8, 1, 1, hX, hY + 6, hZ, 0xff2222, 10);
                        hammerHead.body.type = CANNON.Body.KINEMATIC; 
                        obstacles.push({ ...hammerHead, type: 'spinner', speed: 3 });
                        currentPos.x += 25;
                        break;
                    case 'tilts':
                        for(let i=0; i<2; i++) {
                            const p = createBox(8, 0.5, 8, currentPos.x + 8 + (i*10), currentPos.y + 0.5, currentPos.z, 0x33aaff, 10);
                            p.body.type = CANNON.Body.KINEMATIC;
                            obstacles.push({ ...p, type: 'tilt', speed: 1.5, offset: i });
                        }
                        currentPos.x += 25;
                        break;

                    case 'split_hammers_walls':
                        // Length 40
                        // Left Path (Hammers)
                        createBox(40, 1, 8, currentPos.x + 20, currentPos.y, currentPos.z - 8, baseColor);
                        const h1 = createBox(8, 1, 1, currentPos.x + 10, currentPos.y + 6, currentPos.z - 8, 0xff2222, 10);
                        h1.body.type = CANNON.Body.KINEMATIC;
                        obstacles.push({ ...h1, type: 'spinner', speed: 4 });
                        const h2 = createBox(8, 1, 1, currentPos.x + 30, currentPos.y + 6, currentPos.z - 8, 0xff2222, 10);
                        h2.body.type = CANNON.Body.KINEMATIC;
                        obstacles.push({ ...h2, type: 'spinner', speed: -4 });

                        // Right Path (Walls)
                        createBox(40, 1, 8, currentPos.x + 20, currentPos.y, currentPos.z + 8, baseColor);
                        createBox(1, 4, 8, currentPos.x + 10, currentPos.y + 2, currentPos.z + 8, 0x5555ff);
                        createBox(1, 4, 8, currentPos.x + 20, currentPos.y + 2, currentPos.z + 8, 0x5555ff);
                        createBox(1, 4, 8, currentPos.x + 30, currentPos.y + 2, currentPos.z + 8, 0x5555ff);

                        currentPos.x += 40;
                        break;

                    case 'split_ramp_tunnel':
                        // Length 50
                        // High Path (Left)
                        // Ramp up 20, flat 10, ramp down 20
                        // Rise 8
                        const riseH = 8;
                        const angleH = Math.atan2(riseH, 20);
                        const hypH = Math.sqrt(20*20 + riseH*riseH);
                        
                        // Up
                        createBox(hypH, 1, 8, currentPos.x + 10, currentPos.y + riseH/2, currentPos.z - 8, 0xff00ff, 0, 0, 0, angleH);
                        // Flat top
                        createBox(10, 1, 8, currentPos.x + 25, currentPos.y + riseH, currentPos.z - 8, 0xff00ff);
                        // Down
                        createBox(hypH, 1, 8, currentPos.x + 40, currentPos.y + riseH/2, currentPos.z - 8, 0xff00ff, 0, 0, 0, -angleH);

                        // Low Path (Right) - Tunnel
                        createBox(50, 1, 8, currentPos.x + 25, currentPos.y, currentPos.z + 8, baseColor);
                        // Roof over low path to make it a tunnel
                        createBox(50, 1, 8, currentPos.x + 25, currentPos.y + 5, currentPos.z + 8, 0x555555);

                        currentPos.x += 50;
                        break;

                    case 'finish':
                        finishLineX = currentPos.x;
                        createBox(20, 1, 20, currentPos.x + 10, currentPos.y, currentPos.z, 0xffd700);
                        const arch = createBox(2, 8, 10, currentPos.x, currentPos.y + 4.5, currentPos.z, 0xffd700);
                        arch.mesh.material.transparent = true;
                        arch.mesh.material.opacity = 0.5;
                        arch.body.collisionFilterGroup = 0;
                        break;
                }
            });
        }

        // --- Actors ---
        
        function createFaceTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // Skin background
            ctx.fillStyle = '#ffccaa';
            ctx.fillRect(0, 0, 128, 128);

            // Random Eyes
            ctx.fillStyle = '#000000';
            const eyeY = 50;
            const eyeXOffset = 20 + Math.random() * 15;
            const eyeSize = 8 + Math.random() * 10;
            
            // Left Eye
            ctx.beginPath();
            ctx.arc(64 - eyeXOffset, eyeY, eyeSize, 0, Math.PI * 2);
            ctx.fill();

            // Right Eye
            ctx.beginPath();
            ctx.arc(64 + eyeXOffset, eyeY, eyeSize, 0, Math.PI * 2);
            ctx.fill();

            // Random Mouth
            ctx.lineWidth = 6;
            ctx.strokeStyle = '#000000';
            ctx.beginPath();
            const mouthType = Math.floor(Math.random() * 4);
            if (mouthType === 0) {
                // Smile
                ctx.arc(64, 80, 20, 0, Math.PI, false);
            } else if (mouthType === 1) {
                // Frown
                ctx.arc(64, 100, 20, Math.PI, 0, false);
            } else if (mouthType === 2) {
                // O face
                ctx.arc(64, 90, 15, 0, Math.PI * 2);
            } else {
                // Straight
                ctx.moveTo(44, 90);
                ctx.lineTo(84, 90);
            }
            ctx.stroke();

            return new THREE.CanvasTexture(canvas);
        }

        function createHumanoid(color) {
            const group = new THREE.Group();
            
            const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            
            // Create face materials (Right, Left, Top, Bottom, Front, Back)
            const skinMat = new THREE.MeshPhongMaterial({ color: 0xffccaa }); 
            const faceTexture = createFaceTexture();
            const faceMat = new THREE.MeshPhongMaterial({ color: 0xffccaa, map: faceTexture });
            
            // Apply face texture only to the Front (+Z, index 4)
            const headMaterials = [
                skinMat, // +x
                skinMat, // -x
                skinMat, // +y
                skinMat, // -y
                faceMat, // +z (Front)
                skinMat  // -z
            ];

            const head = new THREE.Mesh(headGeo, headMaterials);
            head.position.y = 0.85; head.castShadow = true;
            group.add(head);

            const bodyGeo = new THREE.BoxGeometry(0.6, 0.7, 0.35);
            const bodyMat = new THREE.MeshPhongMaterial({ color: color }); 
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.2; body.castShadow = true;
            group.add(body);

            const armGeo = new THREE.BoxGeometry(0.2, 0.7, 0.2);
            const armMat = new THREE.MeshPhongMaterial({ color: 0xffccaa });
            
            const armL = new THREE.Mesh(armGeo, armMat);
            armL.position.set(-0.45, 0.2, 0); armL.name = "armL"; armL.castShadow = true;
            group.add(armL);

            const armR = new THREE.Mesh(armGeo, armMat);
            armR.position.set(0.45, 0.2, 0); armR.name = "armR"; armR.castShadow = true;
            group.add(armR);

            const legGeo = new THREE.BoxGeometry(0.22, 0.8, 0.22);
            const legMat = new THREE.MeshPhongMaterial({ color: 0x333333 }); 
            
            const legL = new THREE.Mesh(legGeo, legMat);
            legL.position.set(-0.2, -0.6, 0); legL.name = "legL"; legL.castShadow = true;
            group.add(legL);

            const legR = new THREE.Mesh(legGeo, legMat);
            legR.position.set(0.2, -0.6, 0); legR.name = "legR"; legR.castShadow = true;
            group.add(legR);

            return group;
        }

        function createPlayer() {
            const mesh = createHumanoid(0x00ff00); 
            scene.add(mesh);
            playerMesh = mesh;
            window.playerMesh = mesh;

            const shape = new CANNON.Sphere(0.6);
            playerBody = new CANNON.Body({ mass: 1, fixedRotation: true, material: world.defaultMaterial });
            playerBody.addShape(shape);
            playerBody.position.set(-5, 5, 0);
            playerBody.linearDamping = 0.0;
            world.addBody(playerBody);

            player = { mesh, body: playerBody, isPlayer: true };
            window.playerBody = playerBody;
        }

        // --- Game Logic ---
        function updatePhysics() {
            world.step(1/60);

            let isGrounded = false;
            for(let i = 0; i < world.contacts.length; i++) {
                const c = world.contacts[i];
                if(c.bi === playerBody || c.bj === playerBody) {
                    if(c.bi === playerBody) { if(c.ni.y < -0.5) isGrounded = true; } 
                    else { if(c.ni.y > 0.5) isGrounded = true; }
                }
            }

            const time = Date.now() * 0.001;
            
            obstacles.forEach(obs => {
                if(obs.type === 'spinner') {
                    obs.body.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), time * obs.speed);
                } else if(obs.type === 'tilt') {
                    obs.body.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.sin(time * obs.speed + obs.offset) * 0.5);
                }
                obs.mesh.position.copy(obs.body.position);
                obs.mesh.quaternion.copy(obs.body.quaternion);
            });

            if(gameActive) {
                // Checkpoint Activation Logic
                if(checkpointPos && !checkpointActivated && playerBody.position.x > checkpointPos.x) {
                    checkpointActivated = true;
                    // Respawn slightly higher to be safe
                    // Use captured Z coordinate
                    currentRespawnPos = { x: checkpointPos.x, y: checkpointPos.y + 10, z: checkpointPos.z };
                    
                    // Update visuals
                    if(window.checkpointFlagMat) {
                        window.checkpointFlagMat.color.setHex(0x00ff00); // Green
                    }
                    playTone(880, 0.1, 'sine', 0.2); // Ding sound
                    setTimeout(() => playTone(1100, 0.2, 'sine', 0.2), 100);
                    
                    updateCommentary('checkpoint');
                }

                // --- OPPONENT SYNC & RENDER ---
                // We iterate over the window.opponentsData object which is updated by Firestore
                for (const uid in window.opponentsData) {
                    const data = window.opponentsData[uid];
                    if (!opponents[uid]) {
                        // New player connected! Create mesh.
                        const mesh = createHumanoid(0xff0000); // Red for enemies
                        scene.add(mesh);
                        opponents[uid] = { mesh: mesh };
                    }
                    
                    // Simple Lerp (Interpolation) for smoothness
                    const mesh = opponents[uid].mesh;
                    if (data.state) {
                        mesh.position.lerp(new THREE.Vector3(data.state.x, data.state.y - 0.1, data.state.z), 0.1);
                        // For rotation, we just set it or lerp it. Simplest is direct set for now.
                        mesh.rotation.y = data.state.rot;
                    }
                }
                // Cleanup disconnected players
                for (const uid in opponents) {
                    if (!window.opponentsData[uid]) {
                        scene.remove(opponents[uid].mesh);
                        delete opponents[uid];
                    }
                }

                // --- PLAYER CONTROLS ---
                const baseSpeed = 30; // Increased from 25 to 30
                const maxSpeed = 50; 
                const acceleration = 0.15; // Kept as requested
                const deceleration = 0.5;

                if (keys.w) {
                    playerMomentum = Math.min(playerMomentum + acceleration, maxSpeed);
                } else {
                    playerMomentum = Math.max(playerMomentum - deceleration, baseSpeed);
                }
                
                const pct = ((playerMomentum - baseSpeed) / (maxSpeed - baseSpeed)) * 100;
                document.getElementById('speed-bar').style.width = `${pct}%`;

                const force = new CANNON.Vec3(0, 0, 0);
                
                const fwdX = Math.cos(cameraAngle);
                const fwdZ = Math.sin(cameraAngle);
                const rightX = -Math.sin(cameraAngle);
                const rightZ = Math.cos(cameraAngle);

                if(keys.w) { force.x += fwdX * playerMomentum; force.z += fwdZ * playerMomentum; }
                if(keys.s) { force.x -= fwdX * (playerMomentum * 0.6); force.z -= fwdZ * (playerMomentum * 0.6); }
                if(keys.a) { force.x -= rightX * (playerMomentum * 0.8); force.z -= rightZ * (playerMomentum * 0.8); }
                if(keys.d) { force.x += rightX * (playerMomentum * 0.8); force.z += rightZ * (playerMomentum * 0.8); }
                
                playerBody.velocity.x = force.x * 0.5; 
                playerBody.velocity.z = force.z * 0.5;

                if(keys.w && Math.abs(playerBody.velocity.y) > 0.5) {
                    playerBody.velocity.x += fwdX * 0.2;
                    playerBody.velocity.z += fwdZ * 0.2;
                }

                if(keys.space && isGrounded) {
                    playerBody.velocity.y = 20;
                }

                // Respawn Logic
                if(playerBody.position.y < -30) {
                    playerBody.position.set(currentRespawnPos.x, currentRespawnPos.y, currentRespawnPos.z);
                    playerBody.velocity.set(0, 0, 0);
                    playerMomentum = baseSpeed;
                    
                    // Only say "fall" if not at checkpoint start
                    if(checkpointActivated) updateCommentary('fall'); // Maybe different fall logic?
                    else updateCommentary('fall');
                }

                checkFinish();
            }

            // Sync LOCAL player mesh
            if(player) {
                player.mesh.position.copy(player.body.position);
                player.mesh.position.y -= 0.1; 
                
                const vel = player.body.velocity;
                const speed = Math.sqrt(vel.x*vel.x + vel.z*vel.z);

                if(speed > 0.5) {
                      player.mesh.rotation.y = Math.atan2(vel.x, vel.z); 
                }

                // Animation logic shared for all beans could be added here
                // For now just animate local player limbs
                const armL = player.mesh.getObjectByName('armL');
                const armR = player.mesh.getObjectByName('armR');
                const legL = player.mesh.getObjectByName('legL');
                const legR = player.mesh.getObjectByName('legR');

                if(speed > 1 && player.body.position.y > -10) {
                    const runTime = Date.now() * 0.015;
                    if(armL) armL.rotation.x = Math.sin(runTime) * 0.8;
                    if(armR) armR.rotation.x = -Math.sin(runTime) * 0.8;
                    if(legL) legL.rotation.x = -Math.sin(runTime) * 0.8;
                    if(legR) legR.rotation.x = Math.sin(runTime) * 0.8;
                } else {
                    if(armL) armL.rotation.x = 0;
                    if(armR) armR.rotation.x = 0;
                    if(legL) legL.rotation.x = 0;
                    if(legR) legR.rotation.x = 0;
                }
            }
        }

        function checkFinish() {
            if(!hasFinished && playerBody.position.x > finishLineX) {
                hasFinished = true;
                window.hasFinished = true;
                showEndScreen();
                updateCommentary('finish');
            }
            
            // Calculate Rank based on opponents data
            let myX = playerBody.position.x;
            let countAhead = 0;
            for(const uid in window.opponentsData) {
                if(window.opponentsData[uid].state && window.opponentsData[uid].state.x > myX) {
                    countAhead++;
                }
            }
            document.getElementById('rank').innerText = `Rank: ${countAhead + 1}`;
        }

        function showEndScreen() {
            gameActive = false;
            window.gameActive = false;
            document.exitPointerLock();
            // This function is now exposed to window for calling
            window.showEndScreen();
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            
            if(playerBody) {
                const targetPos = playerBody.position;
                const radius = 14;
                const camHeight = 10;
                const camX = targetPos.x - radius * Math.cos(cameraAngle);
                const camZ = targetPos.z - radius * Math.sin(cameraAngle);
                camera.position.lerp(new THREE.Vector3(camX, targetPos.y + camHeight, camZ), 0.1);
                camera.lookAt(targetPos.x, targetPos.y + 2, targetPos.z);
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('load', () => {
            init();
        });
    </script>
</body>
</html>
