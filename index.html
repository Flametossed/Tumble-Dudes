<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tumble Dudes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <!-- PeerJS for P2P Networking (Replaces Firebase) -->
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #222; }
        
        /* Lobby UI Styles */
        #lobby-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #6a0dad, #222);
            display: flex; /* Default flex */
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; color: white;
        }

        .panel {
            background: rgba(0,0,0,0.85); 
            padding: 30px; 
            border-radius: 20px;
            border: 2px solid #ff00ff; 
            text-align: center; 
            width: 90%; 
            max-width: 400px;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            box-sizing: border-box;
        }

        input {
            width: 100%; padding: 12px; margin: 10px 0; background: #333;
            border: 1px solid #555; color: white; border-radius: 8px; box-sizing: border-box;
            text-transform: uppercase; text-align: center; letter-spacing: 2px;
        }

        button.btn-primary {
            width: 100%; padding: 12px; background: #ff00ff; color: white;
            border: none; border-radius: 8px; font-weight: bold; cursor: pointer;
            margin-top: 10px; transition: 0.2s;
        }
        button.btn-primary:hover { background: #d400d4; transform: scale(1.02); }
        button.btn-primary:disabled { background: #555; cursor: not-allowed; transform: none; }

        button.btn-secondary {
            background: transparent; 
            border: 1px solid #777; 
            color: #aaa;
            padding: 8px 16px;
            margin-top: 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        button.btn-secondary:hover { border-color: white; color: white; }

        #player-list {
            list-style: none; padding: 0; margin: 20px 0; text-align: left;
            width: 100%; 
            max-height: 150px; overflow-y: auto;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }
        #player-list li {
            padding: 10px; border-bottom: 1px solid #444; font-size: 1.1em;
            display: flex; align-items: center; gap: 10px;
        }
        
        .player-color-dot {
            width: 12px; height: 12px; border-radius: 50%;
            display: inline-block; border: 2px solid white;
        }

        #code-display {
            font-size: 2.5em; 
            font-family: monospace; color: #00ffff;
            margin: 10px 0; letter-spacing: 5px;
            font-weight: bold;
        }

        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 200; color: #ff00ff;
            display: none; align-items: center; justify-content: center;
            font-size: 1.5em; flex-direction: column; gap: 20px;
        }

        /* Game UI */
        #ui {
            position: absolute; top: 20px; left: 20px; color: white; pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8); z-index: 10;
            display: none; 
            flex-direction: column; gap: 10px;
        }

        #speed-meter {
            width: 200px; height: 20px; background: rgba(0,0,0,0.5);
            border: 2px solid white; border-radius: 10px; overflow: hidden;
            margin-top: 5px;
        }
        #speed-bar {
            width: 0%; height: 100%; background: linear-gradient(90deg, #ffff00, #ff0000);
            transition: width 0.1s;
        }

        #commentary-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            border-left: 4px solid #ff00ff;
            max-width: 400px;
            font-style: italic;
            font-size: 1.1rem;
            color: #fff;
            margin-top: 10px;
            transition: opacity 0.5s;
            opacity: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Ping indicator */
        #ping-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.6);
            padding: 8px 12px;
            border-radius: 6px;
            color: white;
            font-size: 0.9em;
            display: none;
            align-items: center;
            gap: 8px;
        }
        
        .ping-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        .ping-good { background: #44cc44; }
        .ping-medium { background: #ffaa00; }
        .ping-bad { background: #ff4444; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
        
        /* Disconnect notification */
        #notification-area {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 150;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }
        
        .notification {
            background: rgba(255, 68, 68, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideIn 0.3s, slideOut 0.3s 2.7s;
            min-width: 250px;
            text-align: center;
        }
        
        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(-20px); opacity: 0; }
        }
        
        /* Countdown overlay */
        #countdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 110;
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 8em;
            font-weight: bold;
            text-shadow: 0 0 20px #ff00ff;
        }
        
        #countdown-overlay.go {
            color: #44cc44;
            text-shadow: 0 0 20px #44cc44;
        }
        
        #win-screen {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(30, 30, 30, 0.95); padding: 40px; border-radius: 20px;
            text-align: center; color: white; box-shadow: 0 0 50px rgba(0,0,0,0.5); z-index: 20;
            width: 400px; border: 2px solid #ff00ff;
        }

        #final-leaderboard {
            width: 100%;
            margin: 20px auto;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            box-sizing: border-box;
        }
        .leaderboard-row {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 1.1em;
        }
        .leaderboard-row:last-child {
            border-bottom: none;
        }

        #end-screen-controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        #end-screen-controls button {
            background: #ff00ff; color: white; border: none; padding: 10px 20px;
            font-size: 1rem; border-radius: 10px; cursor: pointer;
            transition: transform 0.1s;
        }
        #end-screen-controls button:hover { background: #d400d4; transform: scale(1.05); }

        .mute-btn {
            position: absolute; bottom: 20px; left: 20px; z-index: 90;
            background: rgba(0,0,0,0.5); padding: 5px 10px; font-size: 0.8rem;
            pointer-events: auto !important; color: white; border: 1px solid white; border-radius: 4px;
        }
        
        /* Improved invite button */
        #invite-btn {
            background: linear-gradient(135deg, #00ffff, #0088ff) !important;
            border: none !important;
            color: white !important;
            padding: 10px 20px !important;
            margin: 15px 0 !important;
            font-size: 1em !important;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
            animation: glow 2s infinite;
        }
        
        #invite-btn:hover {
            transform: scale(1.05) !important;
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.5) !important;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 4px 25px rgba(0, 255, 255, 0.6); }
        }
        
        #waiting-message {
            font-size: 1.1em;
            color: #ffaa00;
            margin: 15px 0;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div>Connecting to Cloud...</div>
        <div style="font-size: 0.5em; color: #888;">v7.2</div>
    </div>
    
    <div id="notification-area"></div>
    <div id="countdown-overlay"></div>

    <!-- Lobby UI -->
    <div id="lobby-ui">
        <h1 style="margin-bottom: 0;">TUMBLE DUDES</h1>
        
        <div id="auth-status" style="margin-bottom: 20px; color: #00ffff;">Ready to Connect</div>

        <!-- Main Menu -->
        <div id="main-menu" class="panel">
            <input type="text" id="username-input" placeholder="USERNAME" maxlength="10">
            <div style="border-top: 1px solid #444; width: 100%; margin: 20px 0;"></div>
            <button class="btn-primary" onclick="createLobby()">HOST GAME</button>
            <div style="margin: 15px 0; color: #aaa;">- OR -</div>
            <input type="text" id="code-input" placeholder="ENTER HOST CODE">
            <button class="btn-primary" onclick="joinLobby()">JOIN GAME</button>
            <div style="margin-top: 20px; font-size: 0.75em; color: #888; max-width: 300px; line-height: 1.4;">
                üõ°Ô∏è If connection fails: Disable browser tracking protection or try Incognito mode
            </div>
            <div style="margin-top: 10px; font-size: 0.7em; color: #666;">v7.2</div>
        </div>

        <!-- Wait Room -->
        <div id="wait-room" class="panel" style="display: none;">
            <h3 style="margin: 0; color: #ff00ff;">LOBBY CODE</h3>
            <div id="code-display"><span id="lobby-code-display">??????</span></div>
            <button id="invite-btn" class="btn-secondary" onclick="copyInviteLink()">üîó SHARE INVITE LINK</button>
            <div id="waiting-message" style="display: none;">‚è≥ Waiting for other players to join...</div>
            <div id="player-count">1 / 6 Players</div>
            <ul id="player-list">
                <!-- Players go here -->
            </ul>
            <button id="ready-btn" class="btn-primary" onclick="toggleReady()">‚úì READY UP</button>
            <button id="start-btn" class="btn-primary" onclick="hostStartGame()" style="display: none;">START RACE</button>
            <p id="wait-text" style="font-size: 0.8em; color: #aaa; margin-top: 10px;">Waiting for host...</p>
            <button class="btn-secondary" onclick="backToMenu()">Cancel</button>
        </div>
    </div>

    <!-- Game UI -->
    <div id="ui">
        <div>
            <h1 style="margin:0;">TUMBLE DUDES</h1>
            <div id="rank">Rank: -- / --</div>
            <div id="speed-meter"><div id="speed-bar"></div></div>
        </div>
        <div id="commentary-box">
            <span id="commentary-wave">üîä</span>
            <span id="commentary-text">waiting for sportscaster...</span>
        </div>
    </div>
    
    <div id="ping-indicator">
        <div class="ping-dot ping-good"></div>
        <span id="ping-text">-- ms</span>
    </div>

    <button class="mute-btn" onclick="toggleMusic()">üéµ Toggle Music</button>

    <div id="win-screen">
        <h2 id="win-text" style="color: #44cc44; margin-top:0;">FINISHED!</h2>
        <div id="final-leaderboard">
            <!-- Leaderboard Items Injected JS -->
        </div>
        <div id="end-screen-controls">
            <!-- Buttons injected JS -->
        </div>
    </div>

    <script>
        // --- PLAYER COLORS ---
        const PLAYER_COLORS = [
            0x00ff00, // Green
            0xff0000, // Red
            0x0088ff, // Blue
            0xffff00, // Yellow
            0xff00ff, // Magenta
            0x00ffff  // Cyan
        ];
        
        const PLAYER_COLOR_NAMES = [
            "Green", "Red", "Blue", "Yellow", "Magenta", "Cyan"
        ];
        
        // --- PEERJS CONFIG ---
        let peer = null;
        let connections = [];
        let hostConn = null;
        
        let myId = null;
        let myUsername = "Bean";
        let myColorIndex = 0;
        let isHost = false;
        
        // Ping tracking
        let lastPingTime = 0;
        let currentPing = 0;
        let pingHistory = [];
        
        // Game State Sync
        window.opponentsData = {};
        let myState = { x: 0, y: 0, z: 0, rot: 0, finished: false };

        // --- GAME VARS ---
        let scene, camera, renderer, world;
        let player, playerBody, playerMesh; 
        let opponents = {};
        let obstacles = [];
        let gameActive = false;
        let finishLineX = 0;
        let lastCommentaryTime = 0;
        let playerMomentum = 20; 
        let hasFinished = false;
        
        // Checkpoint System
        let currentRespawnPos = { x: -5, y: 5, z: 0 };
        let checkpointPos = null;
        let checkpointActivated = false;
        window.checkpointFlagMat = null; 

        // Jump Vars
        let lastGroundedTime = 0;
        let backgroundObjects = [];
        let cameraAngle = 0;
        let isPointerLocked = false;
        let audioCtx;
        let isMuted = false;
        let noteIndex = 0;
        let isPlayingMusic = false;
        let currentTrack = null;
        const keys = { w: false, a: false, s: false, d: false, space: false };
        
        // Countdown state
        let isCountingDown = false;
        
        // Sound effect cooldowns
        let lastCollisionSound = 0;

        // Fixed timestep for consistent physics across all refresh rates
        let lastFrameTime = performance.now();
        let accumulator = 0;
        const fixedTimeStep = 1/60; // 60 FPS physics

        // --- COMMENTARY PHRASES ---
        const COMMENTARY = {
            start: [
                "And they're off!",
                "Let the tumbling begin!",
                "It's race time, folks!",
                "Who will reach the finish first?"
            ],
            checkpoint: [
                "Checkpoint secured!",
                "Halfway there!",
                "What a recovery!",
                "Crushing it so far!"
            ],
            fall: [
                "Ouch! That's gonna hurt!",
                "Down they go!",
                "Back to the checkpoint!",
                "That looked painful!"
            ],
            finish: [
                "They've crossed the line!",
                "What an incredible run!",
                "Ladies and gentlemen, we have a finisher!",
                "That's how it's done!"
            ]
        };

        // --- SOUND EFFECTS ---
        function playSoundEffect(type) {
            if (!audioCtx || isMuted) return;
            
            switch(type) {
                case 'jump':
                    playTone(400, 0.1, 'sine', 0.15);
                    setTimeout(() => playTone(600, 0.08, 'sine', 0.1), 50);
                    break;
                case 'collision':
                    playTone(100, 0.2, 'sawtooth', 0.2);
                    break;
                case 'finish':
                    playTone(523, 0.15, 'sine', 0.2);
                    setTimeout(() => playTone(659, 0.15, 'sine', 0.2), 150);
                    setTimeout(() => playTone(784, 0.3, 'sine', 0.2), 300);
                    break;
                case 'countdown':
                    playTone(800, 0.1, 'square', 0.15);
                    break;
                case 'go':
                    playTone(1000, 0.2, 'sine', 0.2);
                    setTimeout(() => playTone(1200, 0.3, 'sine', 0.2), 100);
                    break;
            }
        }

        // --- NOTIFICATION SYSTEM ---
        function showNotification(message, duration = 3000) {
            const notifArea = document.getElementById('notification-area');
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;
            notifArea.appendChild(notif);
            
            setTimeout(() => {
                notif.remove();
            }, duration);
        }

        // --- NETWORK FUNCTIONS ---

        function createLobby() {
            if (typeof Peer === 'undefined') {
                alert('PeerJS library not loaded yet. Please wait a moment and try again.');
                return;
            }
            
            const username = document.getElementById('username-input').value || "Host Dude";
            myUsername = username;
            isHost = true;
            myColorIndex = 0; // Host is always first color
            
            const code = Math.floor(1000 + Math.random() * 9000).toString();
            const peerId = "tumble-" + code;

            initPeer(peerId, code);
        }

        function joinLobby() {
            if (typeof Peer === 'undefined') {
                alert('PeerJS library not loaded yet. Please wait a moment and try again.');
                return;
            }
            
            const username = document.getElementById('username-input').value || "Guest Dude";
            myUsername = username;
            isHost = false;
            
            const code = document.getElementById('code-input').value;
            if(!code) { alert("Enter code!"); return; }
            
            initPeer(null, code);
        }

        function copyInviteLink() {
            const code = document.getElementById('lobby-code-display').innerText;
            if(!code || code === "??????") return;
            
            const baseUrl = window.location.href.split('?')[0];
            const url = baseUrl + '?code=' + code;
            
            navigator.clipboard.writeText(url).then(() => {
                const btn = document.getElementById('invite-btn');
                const orig = btn.innerText;
                btn.innerText = "‚úÖ LINK COPIED!";
                btn.style.background = "linear-gradient(135deg, #44cc44, #228822)";
                setTimeout(() => {
                    btn.innerText = orig;
                    btn.style.background = "";
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy: ', err);
                alert("Invite Link: " + url);
            });
        }

        function initPeer(customId, lobbyCode) {
            document.getElementById('loading-overlay').style.display = 'flex';
            
            // Set a timeout to detect hung connections
            const connectionTimeout = setTimeout(() => {
                if(peer && !peer.id) {
                    document.getElementById('loading-overlay').style.display = 'none';
                    alert(`Connection timeout!\n\nThis usually means your browser is blocking the connection.\n\n` +
                          `Try:\n` +
                          `1. Disable tracking protection/shields for this site\n` +
                          `2. Open in Incognito/Private window\n` +
                          `3. Try a different browser (Chrome, Edge, Safari)`);
                    if(peer) peer.destroy();
                    peer = null;
                    backToMenu();
                }
            }, 15000); // 15 second timeout
            
            // Explicit configuration for better compatibility
            peer = new Peer(customId, {
                host: '0.peerjs.com',
                secure: true,
                port: 443,
                path: '/',
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                },
                debug: 1
            });

            peer.on('open', (id) => {
                clearTimeout(connectionTimeout); // Connection successful
                myId = id;
                document.getElementById('loading-overlay').style.display = 'none';
                
                if(isHost) {
                    enterLobbyUI(lobbyCode);
                    window.opponentsData[myId] = { 
                        username: myUsername, 
                        isHost: true,
                        colorIndex: myColorIndex,
                        ready: false
                    };
                    updateLobbyList();
                    startPingLoop();
                } else {
                    const hostId = "tumble-" + lobbyCode;
                    hostConn = peer.connect(hostId);
                    
                    hostConn.on('open', () => {
                        console.log("Connected to Host!");
                        hostConn.send({ type: 'join', username: myUsername });
                        enterLobbyUI(lobbyCode);
                        startPingLoop();
                    });

                    hostConn.on('data', handleDataFromHost);
                    hostConn.on('close', () => { 
                        showNotification("Host disconnected!");
                        setTimeout(() => backToMenu(), 2000);
                    });
                    hostConn.on('error', (err) => { 
                        alert("Connection Error: " + err); 
                        backToMenu(); 
                    });
                }
            });

            peer.on('connection', (conn) => {
                if(!isHost) return;

                conn.on('open', () => {
                    connections.push(conn);
                    conn.send({ type: 'state_update', players: window.opponentsData });
                });

                conn.on('data', (data) => handleDataFromClient(data, conn.peer));
                
                conn.on('close', () => {
                    const disconnectedPlayer = window.opponentsData[conn.peer];
                    if(disconnectedPlayer) {
                        showNotification(`${disconnectedPlayer.username} disconnected`);
                    }
                    delete window.opponentsData[conn.peer];
                    connections = connections.filter(c => c.peer !== conn.peer);
                    updateLobbyList();
                    broadcastState();
                });
            });

            peer.on('error', (err) => {
                clearTimeout(connectionTimeout); // Clear timeout
                document.getElementById('loading-overlay').style.display = 'none';
                console.error('Peer error:', err);
                
                let errorMsg = "Network Error: ";
                
                if(err.type === 'unavailable-id') {
                    errorMsg = "Lobby Code already taken. Try again.";
                } else if(err.type === 'network' || err.message?.includes('NS_ERROR_CONTENT_BLOCKED')) {
                    errorMsg = `Connection blocked by browser!\n\n` +
                              `Firefox users: Disable Enhanced Tracking Protection for this site:\n` +
                              `1. Click the shield icon in the address bar\n` +
                              `2. Turn off "Enhanced Tracking Protection"\n` +
                              `3. Refresh the page\n\n` +
                              `Chrome users: Check if any extensions are blocking connections.\n\n` +
                              `Alternative: Try opening in an Incognito/Private window.`;
                } else if(err.type === 'peer-unavailable') {
                    errorMsg = "Could not find that lobby code. Check the code and try again.";
                } else if(err.type === 'server-error') {
                    errorMsg = "PeerJS server is unavailable. Please try again in a moment.";
                } else {
                    errorMsg += err.type || err.message || "Unknown error";
                }
                
                alert(errorMsg);
                backToMenu();
            });
        }

        // --- PING SYSTEM ---
        function startPingLoop() {
            setInterval(() => {
                if(!gameActive) return;
                
                lastPingTime = Date.now();
                
                if(isHost) {
                    connections.forEach(c => {
                        c.send({ type: 'ping', timestamp: Date.now() });
                    });
                } else if(hostConn && hostConn.open) {
                    hostConn.send({ type: 'pong', timestamp: Date.now() });
                }
            }, 2000);
        }
        
        function updatePingDisplay() {
            if(!gameActive) return;
            
            const pingIndicator = document.getElementById('ping-indicator');
            const pingText = document.getElementById('ping-text');
            const pingDot = pingIndicator.querySelector('.ping-dot');
            
            pingIndicator.style.display = 'flex';
            pingText.textContent = `${currentPing} ms`;
            
            // Update color based on ping
            pingDot.className = 'ping-dot';
            if(currentPing < 100) {
                pingDot.classList.add('ping-good');
            } else if(currentPing < 200) {
                pingDot.classList.add('ping-medium');
            } else {
                pingDot.classList.add('ping-bad');
            }
        }

        // --- HOST LOGIC ---
        function handleDataFromClient(data, clientId) {
            if(data.type === 'join') {
                if(Object.keys(window.opponentsData).length >= 6) return;
                
                // Assign next available color
                const usedColors = Object.values(window.opponentsData).map(p => p.colorIndex);
                let colorIndex = 0;
                for(let i = 0; i < PLAYER_COLORS.length; i++) {
                    if(!usedColors.includes(i)) {
                        colorIndex = i;
                        break;
                    }
                }
                
                window.opponentsData[clientId] = { 
                    username: data.username, 
                    isHost: false,
                    colorIndex: colorIndex,
                    ready: false,
                    x: -5, y: 5, z: 0, rot: 0, finished: false
                };
                
                // Unready all players when a new player joins
                for (const pid in window.opponentsData) {
                    window.opponentsData[pid].ready = false;
                }
                
                updateLobbyList();
                broadcastState();
            } else if (data.type === 'pos') {
                if(window.opponentsData[clientId]) {
                    Object.assign(window.opponentsData[clientId], data.state);
                }
            } else if (data.type === 'ready') {
                if(window.opponentsData[clientId]) {
                    window.opponentsData[clientId].ready = data.ready;
                    updateLobbyList();
                    broadcastState();
                }
            } else if (data.type === 'pong') {
                // Client responded to ping
                const rtt = Date.now() - data.timestamp;
                // Could track per-client ping if needed
            }
        }

        function broadcastState() {
            const msg = { type: 'state_update', players: window.opponentsData };
            connections.forEach(c => c.send(msg));
        }

        // --- CLIENT LOGIC ---
        function handleDataFromHost(data) {
            if (data.type === 'state_update') {
                window.opponentsData = data.players;
                
                // Set our color from host assignment
                if(window.opponentsData[myId]) {
                    myColorIndex = window.opponentsData[myId].colorIndex;
                }
                
                updateLobbyList();
            } else if (data.type === 'start_game') {
                startCountdown(data.level);
            } else if (data.type === 'ping') {
                // Respond to host ping
                const rtt = Date.now() - data.timestamp;
                currentPing = rtt;
                pingHistory.push(rtt);
                if(pingHistory.length > 5) pingHistory.shift();
                
                // Calculate average
                currentPing = Math.round(pingHistory.reduce((a,b) => a+b, 0) / pingHistory.length);
                updatePingDisplay();
                
                if(hostConn && hostConn.open) {
                    hostConn.send({ type: 'pong', timestamp: data.timestamp });
                }
            }
        }

        // --- UI FUNCS ---
        function enterLobbyUI(code) {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('wait-room').style.display = 'flex';
            document.getElementById('lobby-code-display').innerText = code;
            
            const startBtn = document.getElementById('start-btn');
            const waitText = document.getElementById('wait-text');

            if(isHost) {
                startBtn.style.display = 'block';
                waitText.style.display = 'none';
            } else {
                startBtn.style.display = 'none';
                waitText.style.display = 'block';
            }
        }

        function updateLobbyList() {
            const list = document.getElementById('player-list');
            const waitingMsg = document.getElementById('waiting-message');
            const startBtn = document.getElementById('start-btn');
            const readyBtn = document.getElementById('ready-btn');
            
            list.innerHTML = '';
            let count = 0;
            let allReady = true;
            
            for(const pid in window.opponentsData) {
                const p = window.opponentsData[pid];
                const li = document.createElement('li');
                
                const colorDot = document.createElement('span');
                colorDot.className = 'player-color-dot';
                colorDot.style.backgroundColor = `#${PLAYER_COLORS[p.colorIndex].toString(16).padStart(6, '0')}`;
                
                li.appendChild(colorDot);
                
                const nameSpan = document.createElement('span');
                const readyIcon = p.ready ? '‚úì ' : '';
                nameSpan.innerText = `${readyIcon}${p.username} ${p.isHost ? 'üëë' : ''}`;
                nameSpan.style.color = p.ready ? '#44cc44' : '#ffffff';
                li.appendChild(nameSpan);
                
                list.appendChild(li);
                count++;
                
                if (!p.ready) allReady = false;
            }
            
            document.getElementById('player-count').innerText = `${count} / 6 Players`;
            
            // Update ready button text and styling
            const myData = window.opponentsData[myId];
            if (myData && myData.ready) {
                readyBtn.innerText = '‚úó UNREADY';
                readyBtn.style.background = '#cc4444';
            } else {
                readyBtn.innerText = '‚úì READY UP';
                readyBtn.style.background = '#44cc44';
            }
            
            // Update button visibility and state
            if (isHost) {
                // Single player: hide ready button, enable start button
                if (count === 1) {
                    readyBtn.style.display = 'none';
                    startBtn.style.display = 'block';
                    startBtn.disabled = false;
                } else {
                    // Multiplayer: show ready button, require all ready to start
                    readyBtn.style.display = 'block';
                    startBtn.style.display = 'block';
                    startBtn.disabled = !allReady;
                }
            } else {
                readyBtn.style.display = 'block';
                startBtn.style.display = 'none';
            }
            
            // Show waiting message if solo
            if(isHost && count === 1) {
                waitingMsg.style.display = 'block';
            } else {
                waitingMsg.style.display = 'none';
            }
        }

        function toggleReady() {
            if (!myId || !window.opponentsData[myId]) return;
            
            const newReadyState = !window.opponentsData[myId].ready;
            window.opponentsData[myId].ready = newReadyState;
            
            if (isHost) {
                // Host updates locally and broadcasts
                updateLobbyList();
                broadcastState();
            } else {
                // Client sends ready state to host
                if (hostConn && hostConn.open) {
                    hostConn.send({ type: 'ready', ready: newReadyState });
                }
                updateLobbyList();
            }
        }

        // --- COUNTDOWN SYSTEM ---
        function startCountdown(level) {
            if(isCountingDown) return;
            isCountingDown = true;
            
            // Prepare game but don't start yet
            document.getElementById('lobby-ui').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            
            window.startMultiplayerGame(level, false); // false = don't activate yet
            
            const overlay = document.getElementById('countdown-overlay');
            overlay.style.display = 'flex';
            
            let count = 3;
            overlay.textContent = count;
            overlay.classList.remove('go');
            playSoundEffect('countdown');
            
            const countInterval = setInterval(() => {
                count--;
                if(count > 0) {
                    overlay.textContent = count;
                    playSoundEffect('countdown');
                } else {
                    overlay.textContent = 'GO!';
                    overlay.classList.add('go');
                    playSoundEffect('go');
                    
                    // Activate game
                    window.gameActive = true;
                    gameActive = true;
                    
                    setTimeout(() => {
                        overlay.style.display = 'none';
                        isCountingDown = false;
                    }, 1000);
                    
                    clearInterval(countInterval);
                }
            }, 1000);
        }

        window.hostStartGame = function() {
            if(!isHost || isCountingDown) return;
            
            const level = window.generateRandomLevelStructure(); 
            
            // Broadcast Start with countdown
            const msg = { type: 'start_game', level: level };
            connections.forEach(c => c.send(msg));
            
            // Start Local countdown
            startCountdown(level);
        }

        window.backToMenu = function() {
            if(peer) peer.destroy();
            peer = null;
            connections = [];
            hostConn = null;
            window.opponentsData = {};
            
            document.getElementById('win-screen').style.display = 'none';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('ping-indicator').style.display = 'none';
            document.getElementById('lobby-ui').style.display = 'flex';
            document.getElementById('main-menu').style.display = 'flex';
            document.getElementById('wait-room').style.display = 'none';
            document.getElementById('loading-overlay').style.display = 'none';
            
            window.gameActive = false;
            gameActive = false;
            isCountingDown = false;
            window.clearLevel();
            window.changeMusicTrack();
        }

        // --- NETWORK LOOP ---
        setInterval(() => {
            if(!window.gameActive || !myId) return;
            
            if(window.playerBody) {
                myState = {
                    x: parseFloat(window.playerBody.position.x.toFixed(2)),
                    y: parseFloat(window.playerBody.position.y.toFixed(2)),
                    z: parseFloat(window.playerBody.position.z.toFixed(2)),
                    rot: parseFloat(window.playerMesh.rotation.y.toFixed(2)),
                    finished: window.hasFinished
                };
            }

            if(isHost) {
                if(window.opponentsData[myId]) Object.assign(window.opponentsData[myId], myState);
                broadcastState();
            } else if (hostConn && hostConn.open) {
                hostConn.send({ type: 'pos', state: myState });
            }
        }, 50);

        // --- EXPOSE GLOBALS ---
        window.createLobby = createLobby;
        window.joinLobby = joinLobby;
        window.hostStartGame = hostStartGame;
        window.toggleReady = toggleReady;
        window.copyInviteLink = copyInviteLink;
        window.backToMenu = backToMenu;

        // --- LIBRARY LOADING CHECK ---
        function waitForLibraries() {
            return new Promise((resolve) => {
                const statusDiv = document.getElementById('auth-status');
                statusDiv.innerText = 'Loading libraries...';
                statusDiv.style.color = '#ffaa00';
                
                const checkLibraries = () => {
                    if (typeof THREE !== 'undefined' && 
                        typeof CANNON !== 'undefined' && 
                        typeof Peer !== 'undefined') {
                        statusDiv.innerText = 'Ready to Connect ‚úì';
                        statusDiv.style.color = '#44cc44';
                        resolve();
                    } else {
                        console.log('Waiting for libraries...', {
                            THREE: typeof THREE !== 'undefined',
                            CANNON: typeof CANNON !== 'undefined',
                            Peer: typeof Peer !== 'undefined'
                        });
                        setTimeout(checkLibraries, 100);
                    }
                };
                checkLibraries();
            });
        }

        // --- GAME INIT ---
        async function init() {
            // Wait for all libraries to load
            await waitForLibraries();
            
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            if(code) {
                document.getElementById('code-input').value = code;
                document.getElementById('username-input').focus();
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x6a0dad); 
            scene.fog = new THREE.FogExp2(0x6a0dad, 0.006);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);
            
            const sun = new THREE.DirectionalLight(0xffaa00, 0.8);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            scene.add(sun);

            const purpleLight = new THREE.PointLight(0xff00ff, 0.8, 200);
            purpleLight.position.set(50, 50, 50);
            scene.add(purpleLight);

            world = new CANNON.World();
            world.gravity.set(0, -30, 0); 
            world.broadphase = new CANNON.NaiveBroadphase();
            
            const defaultMaterial = new CANNON.Material('default');
            const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
                friction: 0.3,
                restitution: 0.1,
            });
            world.addContactMaterial(defaultContactMaterial);

            createBackgroundScenery(); 
            
            window.addEventListener('keydown', (e) => { 
                let key = e.key.toLowerCase();
                if (key === ' ') key = 'space'; 
                if(keys.hasOwnProperty(key)) keys[key] = true; 
            });
            window.addEventListener('keyup', (e) => { 
                let key = e.key.toLowerCase();
                if (key === ' ') key = 'space';
                if(keys.hasOwnProperty(key)) keys[key] = false; 
            });
            window.addEventListener('resize', onWindowResize);

            document.addEventListener('click', () => {
                if (!audioCtx) initAudio();
                if (window.gameActive && !isPointerLocked && !isCountingDown) {
                    document.body.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === document.body;
            });

            document.addEventListener('mousemove', (e) => {
                if (isPointerLocked) {
                    cameraAngle += e.movementX * 0.002;
                }
            });
            
            animate();
        }

        window.startMultiplayerGame = function(levelSegments, activate = true) {
            document.getElementById('win-screen').style.display = 'none';
            clearLevel();
            createBackgroundScenery(); 
            buildLevelFromSegments(levelSegments);
            createPlayer();
            
            if(activate) {
                window.gameActive = true;
                gameActive = true;
            }
            
            window.hasFinished = false;
            hasFinished = false;
            
            if (!audioCtx) initAudio();
            window.changeMusicTrack(); 
            
            if(activate) {
                updateCommentary('start');
            }
        }

        // --- Audio System ---
        const musicTracks = [
            { name: "Funky Bean", tempo: 250, bass: [110, 110, 130, 146, 110, 110, 98, 98], melody: [440, 0, 523, 440, 0, 587, 523, 0], bassType: 'triangle', melodyType: 'square' },
            { name: "Hyper Space", tempo: 200, bass: [65, 0, 65, 0, 73, 0, 73, 0], melody: [523, 523, 784, 0, 659, 0, 523, 0], bassType: 'sawtooth', melodyType: 'sawtooth' },
            { name: "Retro Dash", tempo: 280, bass: [87, 87, 98, 98, 110, 110, 130, 0], melody: [698, 0, 659, 0, 587, 587, 523, 0], bassType: 'square', melodyType: 'triangle' }
        ];
        window.changeMusicTrack = function() {
            currentTrack = musicTracks[Math.floor(Math.random() * musicTracks.length)];
        }
        currentTrack = musicTracks[0];

        function initAudio() {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                if(audioCtx.state === 'suspended') audioCtx.resume();
                startMusicLoop();
            } catch(e) { console.error("Audio init failed", e); }
        }

        function toggleMusic() {
            isMuted = !isMuted;
            if(isMuted && audioCtx) audioCtx.suspend();
            if(!isMuted && audioCtx) audioCtx.resume();
        }

        function playTone(freq, duration, type='sine', vol=0.1) {
            if (!audioCtx || isMuted) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function startMusicLoop() {
            if(isPlayingMusic) return;
            isPlayingMusic = true;
            const loop = () => {
                if(!audioCtx || isMuted || audioCtx.state !== 'running') { setTimeout(loop, 250); return; }
                const track = currentTrack;
                playTone(track.bass[noteIndex % 8], 0.2, track.bassType, 0.15);
                if(track.melody[noteIndex % 8] !== 0) playTone(track.melody[noteIndex % 8], 0.1, track.melodyType, 0.05);
                if(noteIndex % 2 === 0) playTone(2000 + Math.random()*500, 0.05, 'sawtooth', 0.02);
                noteIndex++;
                setTimeout(loop, track.tempo);
            };
            loop();
        }

        // --- Visuals & Level ---

        function generateSkyboxTexture(theme) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const w = canvas.width; const h = canvas.height;

            if (theme === 0) {
                const grad = ctx.createLinearGradient(0, 0, 0, h);
                grad.addColorStop(0, '#000000'); grad.addColorStop(1, '#220033');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
                ctx.fillStyle = '#ffffff';
                for(let i=0; i<400; i++) { ctx.beginPath(); ctx.arc(Math.random()*w, Math.random()*h, Math.random()*1.5, 0, Math.PI*2); ctx.fill(); }
            } else if (theme === 1) {
                const grad = ctx.createLinearGradient(0, 0, 0, h);
                grad.addColorStop(0, '#00BFFF'); grad.addColorStop(1, '#FFFFFF');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
            } else if (theme === 2) {
                const grad = ctx.createLinearGradient(0, 0, 0, h);
                grad.addColorStop(0, '#4B0082'); grad.addColorStop(0.5, '#FF4500'); grad.addColorStop(1, '#FFD700');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
            } else {
                const grad = ctx.createLinearGradient(0, 0, 0, h);
                grad.addColorStop(0, '#000000'); grad.addColorStop(1, '#001133');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)'; ctx.lineWidth = 3;
                for(let i=0; i<w; i+=150) { ctx.beginPath(); ctx.moveTo(w/2, h/2); ctx.lineTo(i, h); ctx.stroke(); }
            }
            return new THREE.CanvasTexture(canvas);
        }

        function createBackgroundScenery() {
            backgroundObjects.forEach(obj => scene.remove(obj));
            backgroundObjects = [];
            const theme = Math.floor(Math.random() * 4);
            
            if (theme === 0) scene.background = new THREE.Color(0x110022);
            else if (theme === 1) scene.background = new THREE.Color(0x87CEFA);
            else if (theme === 2) scene.background = new THREE.Color(0x4B0082);
            else scene.background = new THREE.Color(0x001133);

            const texture = generateSkyboxTexture(theme);
            const geo = new THREE.SphereGeometry(800, 60, 40);
            const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide, fog: false });
            const skybox = new THREE.Mesh(geo, mat);
            scene.add(skybox);
            backgroundObjects.push(skybox);
        }

        window.generateRandomLevelStructure = function() {
            const types = ['path', 'narrow', 'hammers', 'tilts', 'walls', 'ramp_up', 'ramp_down', 'shift_left', 'shift_right', 'split_hammers_walls', 'split_ramp_tunnel'];
            const length = 25 + Math.floor(Math.random() * 15); 
            const level = ['start'];
            for(let i=0; i<length; i++) {
                level.push(types[Math.floor(Math.random() * types.length)]);
            }
            level.push('finish');
            return level;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        async function updateCommentary(eventType) {
            if(!gameActive && eventType !== 'start') return;
            const now = Date.now();
            if(now - lastCommentaryTime < 8000 && eventType !== 'checkpoint') return;
            lastCommentaryTime = now;
            
            const boxText = document.getElementById('commentary-text');
            const phrases = COMMENTARY[eventType] || [`${eventType}!`];
            const randomPhrase = phrases[Math.floor(Math.random() * phrases.length)];
            
            boxText.innerText = randomPhrase;
            document.getElementById('commentary-box').style.opacity = 1;
            
            setTimeout(() => {
                document.getElementById('commentary-box').style.opacity = 0;
            }, 5000);
        }

        // --- Level System ---
        let levelObjects = [];
        let currentPos = { x: -5, y: -0.5, z: 0 };
        let levelMinY = -0.5;

        function createBox(w, h, d, x, y, z, color, mass=0, rotX=0, rotY=0, rotZ=0) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshPhongMaterial({ color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.rotation.set(rotX, rotY, rotZ);
            mesh.castShadow = true; mesh.receiveShadow = true;
            scene.add(mesh);
            const shape = new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2));
            const body = new CANNON.Body({ mass: mass, material: world.defaultMaterial });
            body.addShape(shape); body.position.set(x, y, z);
            const q = new CANNON.Quaternion(); q.setFromEuler(rotX, rotY, rotZ); body.quaternion.copy(q);
            world.addBody(body);
            const obj = { mesh, body, type: 'static' };
            levelObjects.push(obj);
            return obj;
        }

        window.clearLevel = function() {
            levelObjects.forEach(obj => { scene.remove(obj.mesh); world.removeBody(obj.body); });
            levelObjects = []; obstacles = []; currentPos = { x: -5, y: -0.5, z: 0 }; levelMinY = -0.5;
            currentRespawnPos = { x: -5, y: 5, z: 0 }; checkpointPos = null; checkpointActivated = false; window.checkpointFlagMat = null;
            if(player) { scene.remove(player.mesh); world.removeBody(player.body); player = null; window.playerBody = null; window.playerMesh = null; }
            for(let uid in opponents) { scene.remove(opponents[uid].mesh); }
            opponents = {};
        }

        function createCheckpointVisual(x, y, z) {
            const poleGeo = new THREE.CylinderGeometry(0.5, 0.5, 10);
            const poleMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const pole = new THREE.Mesh(poleGeo, poleMat); pole.position.set(x, y + 5, z - 12); scene.add(pole);
            const dummyBody = new CANNON.Body({ mass: 0 }); 
            levelObjects.push({ mesh: pole, body: dummyBody });
            const flagGeo = new THREE.BoxGeometry(4, 3, 0.5);
            const flagMat = new THREE.MeshPhongMaterial({ color: 0xff0000 }); 
            const flag = new THREE.Mesh(flagGeo, flagMat); flag.position.set(x + 2, y + 8, z - 12); scene.add(flag);
            levelObjects.push({ mesh: flag, body: dummyBody });
            window.checkpointFlagMat = flagMat;
        }

        function buildLevelFromSegments(segments) {
            currentPos = { x: -5, y: -0.5, z: 0 };
            levelMinY = -0.5;
            const midIndex = Math.floor(segments.length / 2);
            segments.forEach((seg, index) => {
                const baseColor = index % 2 === 0 ? 0xdddddd : 0xcccccc;
                if (index === midIndex) {
                    checkpointPos = { x: currentPos.x + 10, y: currentPos.y + 2, z: currentPos.z }; 
                    createCheckpointVisual(currentPos.x + 10, currentPos.y, currentPos.z);
                    createBox(25, 1, 25, currentPos.x + 10, currentPos.y - 0.2, currentPos.z, 0x66ff66);
                }
                switch(seg) {
                    case 'start': createBox(15, 1, 20, currentPos.x, currentPos.y, currentPos.z, 0x44cc44); currentPos.x += 15; break;
                    case 'path': createBox(30, 1, 10, currentPos.x + 15, currentPos.y, currentPos.z, baseColor); currentPos.x += 30; break;
                    case 'narrow': createBox(20, 1, 2, currentPos.x + 10, currentPos.y, currentPos.z, 0xffaa00); currentPos.x += 20; break;
                    case 'ramp_up': { const rampLen = 30; const rise = 10; const angle = Math.atan2(rise, rampLen); const hyp = Math.sqrt(rampLen*rampLen + rise*rise); createBox(hyp, 1, 10, currentPos.x + rampLen/2, currentPos.y + rise/2, currentPos.z, 0xff00ff, 0, 0, 0, angle); currentPos.x += rampLen; currentPos.y += rise; break; }
                    case 'ramp_down': { const rampLenD = 30; const drop = 10; const angleD = -Math.atan2(drop, rampLenD); const hypD = Math.sqrt(rampLenD*rampLenD + drop*drop); createBox(hypD, 1, 10, currentPos.x + rampLenD/2, currentPos.y - drop/2, currentPos.z, 0x00ffff, 0, 0, 0, angleD); currentPos.x += rampLenD; currentPos.y -= drop; break; }
                    case 'shift_left': createBox(Math.sqrt(800), 1, 10, currentPos.x + 10, currentPos.y, currentPos.z - 10, 0xffff00, 0, 0, -Math.PI/4, 0); currentPos.x += 20; currentPos.z -= 20; break;
                    case 'shift_right': createBox(Math.sqrt(800), 1, 10, currentPos.x + 10, currentPos.y, currentPos.z + 10, 0xffff00, 0, 0, Math.PI/4, 0); currentPos.x += 20; currentPos.z += 20; break;
                    case 'walls': createBox(25, 1, 10, currentPos.x + 12.5, currentPos.y, currentPos.z, baseColor); createBox(1, 4, 10, currentPos.x + 8, currentPos.y + 2, currentPos.z, 0x5555ff); createBox(1, 4, 10, currentPos.x + 16, currentPos.y + 2, currentPos.z, 0x5555ff); currentPos.x += 25; break;
                    case 'hammers': { createBox(25, 1, 10, currentPos.x + 12.5, currentPos.y, currentPos.z, 0x888888); const hX = currentPos.x + 12.5; const hY = currentPos.y; const hZ = currentPos.z; createBox(1, 6, 1, hX, hY + 3, hZ, 0x222222); const hammerHead = createBox(8, 1, 1, hX, hY + 6, hZ, 0xff2222, 10); hammerHead.body.type = CANNON.Body.KINEMATIC; obstacles.push({ ...hammerHead, type: 'spinner', speed: 3 }); currentPos.x += 25; break; }
                    case 'tilts': { for(let i=0; i<2; i++) { const p = createBox(8, 0.5, 8, currentPos.x + 8 + (i*10), currentPos.y + 0.5, currentPos.z, 0x33aaff, 10); p.body.type = CANNON.Body.KINEMATIC; obstacles.push({ ...p, type: 'tilt', speed: 1.5, offset: i }); } currentPos.x += 25; break; }
                    case 'split_hammers_walls': { createBox(40, 1, 8, currentPos.x + 20, currentPos.y, currentPos.z - 8, baseColor); const h1 = createBox(8, 1, 1, currentPos.x + 10, currentPos.y + 6, currentPos.z - 8, 0xff2222, 10); h1.body.type = CANNON.Body.KINEMATIC; obstacles.push({ ...h1, type: 'spinner', speed: 4 }); const h2 = createBox(8, 1, 1, currentPos.x + 30, currentPos.y + 6, currentPos.z - 8, 0xff2222, 10); h2.body.type = CANNON.Body.KINEMATIC; obstacles.push({ ...h2, type: 'spinner', speed: -4 }); createBox(40, 1, 8, currentPos.x + 20, currentPos.y, currentPos.z + 8, baseColor); createBox(1, 4, 8, currentPos.x + 10, currentPos.y + 2, currentPos.z + 8, 0x5555ff); createBox(1, 4, 8, currentPos.x + 20, currentPos.y + 2, currentPos.z + 8, 0x5555ff); createBox(1, 4, 8, currentPos.x + 30, currentPos.y + 2, currentPos.z + 8, 0x5555ff); currentPos.x += 40; break; }
                    case 'split_ramp_tunnel': { const riseH = 8; const angleH = Math.atan2(riseH, 20); const hypH = Math.sqrt(20*20 + riseH*riseH); createBox(hypH, 1, 8, currentPos.x + 10, currentPos.y + riseH/2, currentPos.z - 8, 0xff00ff, 0, 0, 0, angleH); createBox(10, 1, 8, currentPos.x + 25, currentPos.y + riseH, currentPos.z - 8, 0xff00ff); createBox(hypH, 1, 8, currentPos.x + 40, currentPos.y + riseH/2, currentPos.z - 8, 0xff00ff, 0, 0, 0, -angleH); createBox(50, 1, 8, currentPos.x + 25, currentPos.y, currentPos.z + 8, baseColor); createBox(50, 1, 8, currentPos.x + 25, currentPos.y + 5, currentPos.z + 8, 0x555555); currentPos.x += 50; break; }
                    case 'finish': { finishLineX = currentPos.x; createBox(20, 1, 20, currentPos.x + 10, currentPos.y, currentPos.z, 0xffd700); const arch = createBox(2, 8, 10, currentPos.x, currentPos.y + 4.5, currentPos.z, 0xffd700); arch.mesh.material.transparent = true; arch.mesh.material.opacity = 0.5; arch.body.collisionFilterGroup = 0; break; }
                }
                if(currentPos.y < levelMinY) levelMinY = currentPos.y;
            });
        }

        // --- Actors ---
        function createFaceTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128; const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffccaa'; ctx.fillRect(0, 0, 128, 128); ctx.fillStyle = '#000000';
            const eyeY = 50; const eyeXOffset = 20 + Math.random() * 15; const eyeSize = 8 + Math.random() * 10;
            ctx.beginPath(); ctx.arc(64 - eyeXOffset, eyeY, eyeSize, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(64 + eyeXOffset, eyeY, eyeSize, 0, Math.PI * 2); ctx.fill();
            ctx.lineWidth = 6; ctx.strokeStyle = '#000000'; ctx.beginPath();
            const mouthType = Math.floor(Math.random() * 4);
            if (mouthType === 0) ctx.arc(64, 80, 20, 0, Math.PI, false);
            else if (mouthType === 1) ctx.arc(64, 100, 20, Math.PI, 0, false);
            else if (mouthType === 2) ctx.arc(64, 90, 15, 0, Math.PI * 2);
            else { ctx.moveTo(44, 90); ctx.lineTo(84, 90); }
            ctx.stroke(); return new THREE.CanvasTexture(canvas);
        }

        function createNameSprite(name) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Background with semi-transparent black
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Text
            ctx.font = 'bold 32px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(name, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(2, 0.5, 1);
            return sprite;
        }

        function createHumanoid(color, name) {
            const group = new THREE.Group();
            const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const skinMat = new THREE.MeshPhongMaterial({ color: 0xffccaa }); 
            const faceTexture = createFaceTexture(); const faceMat = new THREE.MeshPhongMaterial({ color: 0xffccaa, map: faceTexture });
            const headMaterials = [skinMat, skinMat, skinMat, skinMat, faceMat, skinMat];
            const head = new THREE.Mesh(headGeo, headMaterials); head.position.y = 0.85; head.castShadow = true; group.add(head);
            const bodyGeo = new THREE.BoxGeometry(0.6, 0.7, 0.35); const bodyMat = new THREE.MeshPhongMaterial({ color: color }); 
            const body = new THREE.Mesh(bodyGeo, bodyMat); body.position.y = 0.2; body.castShadow = true; group.add(body);
            const armGeo = new THREE.BoxGeometry(0.2, 0.7, 0.2); const armMat = new THREE.MeshPhongMaterial({ color: 0xffccaa });
            const armL = new THREE.Mesh(armGeo, armMat); armL.position.set(-0.45, 0.2, 0); armL.name = "armL"; armL.castShadow = true; group.add(armL);
            const armR = new THREE.Mesh(armGeo, armMat); armR.position.set(0.45, 0.2, 0); armR.name = "armR"; armR.castShadow = true; group.add(armR);
            const legGeo = new THREE.BoxGeometry(0.22, 0.8, 0.22); const legMat = new THREE.MeshPhongMaterial({ color: 0x333333 }); 
            const legL = new THREE.Mesh(legGeo, legMat); legL.position.set(-0.2, -0.6, 0); legL.name = "legL"; legL.castShadow = true; group.add(legL);
            const legR = new THREE.Mesh(legGeo, legMat); legR.position.set(0.2, -0.6, 0); legR.name = "legR"; legR.castShadow = true; group.add(legR);
            
            // Add name sprite if name is provided
            if (name) {
                const nameSprite = createNameSprite(name);
                nameSprite.position.y = 1.6;
                nameSprite.name = "nameSprite";
                group.add(nameSprite);
            }
            
            return group;
        }

        function createPlayer() {
            const mesh = createHumanoid(PLAYER_COLORS[myColorIndex], myUsername); 
            scene.add(mesh);
            playerMesh = mesh; 
            window.playerMesh = mesh;
            
            const shape = new CANNON.Sphere(0.6); 
            playerBody = new CANNON.Body({ mass: 1, fixedRotation: true, material: world.defaultMaterial });
            playerBody.addShape(shape); 
            playerBody.position.set(-5, 2, 0);
            playerBody.linearDamping = 0.0; 
            world.addBody(playerBody);
            
            player = { mesh, body: playerBody, isPlayer: true }; 
            window.playerBody = playerBody;
        }

        function updatePhysics() {
            world.step(fixedTimeStep);
            let isGrounded = false;
            for(let i = 0; i < world.contacts.length; i++) {
                const c = world.contacts[i];
                if(c.bi === playerBody || c.bj === playerBody) {
                    if(c.bi === playerBody) { 
                        if(c.ni.y < -0.5) isGrounded = true; 
                    } else { 
                        if(c.ni.y > 0.5) isGrounded = true; 
                    }
                    
                    // Collision sound effect (with cooldown to prevent buzzing)
                    if(gameActive) {
                        const now = Date.now();
                        const relVel = c.bi === playerBody ? 
                            c.bi.velocity.length() : c.bj.velocity.length();
                        // Only play on significant impacts (not normal running), with cooldown
                        if(relVel > 25 && now - lastCollisionSound > 500) {
                            playSoundEffect('collision');
                            lastCollisionSound = now;
                        }
                    }
                }
            }
            if (isGrounded) lastGroundedTime = Date.now();
            
            const time = Date.now() * 0.001;
            obstacles.forEach(obs => {
                if(obs.type === 'spinner') obs.body.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), time * obs.speed);
                else if(obs.type === 'tilt') obs.body.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.sin(time * obs.speed + obs.offset) * 0.5);
                obs.mesh.position.copy(obs.body.position); obs.mesh.quaternion.copy(obs.body.quaternion);
            });

            if(gameActive || !gameActive) { // Run respawn check ALWAYS (fixes black screen glitch on load)
                if(playerBody && playerBody.position.y < levelMinY - 30) {
                    playerBody.position.set(currentRespawnPos.x, currentRespawnPos.y, currentRespawnPos.z);
                    playerBody.velocity.set(0, 0, 0); 
                    if(gameActive) {
                        playerMomentum = 30; // Reset momentum
                        if(checkpointActivated) updateCommentary('fall'); else updateCommentary('fall');
                    }
                }
            }

            if(gameActive) {
                // Checkpoint
                if(checkpointPos && !checkpointActivated && playerBody.position.x > checkpointPos.x) {
                    checkpointActivated = true; 
                    currentRespawnPos = { x: checkpointPos.x, y: checkpointPos.y + 10, z: checkpointPos.z };
                    if(window.checkpointFlagMat) window.checkpointFlagMat.color.setHex(0x00ff00);
                    playTone(880, 0.1, 'sine', 0.2); 
                    setTimeout(() => playTone(1100, 0.2, 'sine', 0.2), 100);
                    updateCommentary('checkpoint');
                }

                // Update Opponents
                for (const uid in window.opponentsData) {
                    const data = window.opponentsData[uid];
                    if(uid === myId) continue; 
                    
                    if (!opponents[uid]) {
                        const oppColor = PLAYER_COLORS[data.colorIndex] || 0xff0000;
                        const mesh = createHumanoid(oppColor, data.username); 
                        scene.add(mesh);
                        opponents[uid] = { 
                            mesh: mesh, 
                            lastPos: new THREE.Vector3(data.x, data.y, data.z) 
                        };
                    }
                    
                    const opp = opponents[uid];
                    const currentPos = new THREE.Vector3(data.x, data.y, data.z);
                    const speed = currentPos.distanceTo(opp.lastPos) * 60; 
                    opp.lastPos.copy(currentPos);
                    opp.mesh.position.lerp(new THREE.Vector3(data.x, data.y - 0.1, data.z), 0.2);
                    opp.mesh.rotation.y = data.rot;
                    
                    // Animation
                    const armL = opp.mesh.getObjectByName('armL'); 
                    const armR = opp.mesh.getObjectByName('armR');
                    const legL = opp.mesh.getObjectByName('legL'); 
                    const legR = opp.mesh.getObjectByName('legR');
                    if(speed > 0.5) {
                        const runTime = Date.now() * 0.015;
                        if(armL) armL.rotation.x = Math.sin(runTime) * 0.8; 
                        if(armR) armR.rotation.x = -Math.sin(runTime) * 0.8;
                        if(legL) legL.rotation.x = -Math.sin(runTime) * 0.8; 
                        if(legR) legR.rotation.x = Math.sin(runTime) * 0.8;
                    } else {
                        if(armL) armL.rotation.x = 0; if(armR) armR.rotation.x = 0; 
                        if(legL) legL.rotation.x = 0; if(legR) legR.rotation.x = 0;
                    }
                }
                
                // Cleanup
                for (const uid in opponents) { 
                    if (!window.opponentsData[uid]) { 
                        scene.remove(opponents[uid].mesh); 
                        delete opponents[uid]; 
                    } 
                }

                // Player Controls
                const baseSpeed = 30; const maxSpeed = 50; 
                const acceleration = 0.15; const deceleration = 0.5;
                
                if (keys.w) playerMomentum = Math.min(playerMomentum + acceleration, maxSpeed);
                else playerMomentum = Math.max(playerMomentum - deceleration, baseSpeed);
                
                const pct = ((playerMomentum - baseSpeed) / (maxSpeed - baseSpeed)) * 100;
                document.getElementById('speed-bar').style.width = `${pct}%`;
                
                const force = new CANNON.Vec3(0, 0, 0);
                const fwdX = Math.cos(cameraAngle); const fwdZ = Math.sin(cameraAngle);
                const rightX = -Math.sin(cameraAngle); const rightZ = Math.cos(cameraAngle);
                
                if(keys.w) { force.x += fwdX * playerMomentum; force.z += fwdZ * playerMomentum; }
                if(keys.s) { force.x -= fwdX * (playerMomentum * 0.6); force.z -= fwdZ * (playerMomentum * 0.6); }
                if(keys.a) { force.x -= rightX * (playerMomentum * 0.8); force.z -= rightZ * (playerMomentum * 0.8); }
                if(keys.d) { force.x += rightX * (playerMomentum * 0.8); force.z += rightZ * (playerMomentum * 0.8); }
                
                playerBody.velocity.x = force.x * 0.5; 
                playerBody.velocity.z = force.z * 0.5;
                
                if(keys.w && Math.abs(playerBody.velocity.y) > 0.5) { 
                    playerBody.velocity.x += fwdX * 0.2; 
                    playerBody.velocity.z += fwdZ * 0.2; 
                }
                
                if(keys.space && (Date.now() - lastGroundedTime < 200)) { 
                    lastGroundedTime = 0; 
                    playerBody.velocity.y = 20; 
                    playSoundEffect('jump');
                }
                
                checkFinish();
            }

            if(player) {
                player.mesh.position.copy(player.body.position); 
                player.mesh.position.y -= 0.1; 
                
                const vel = player.body.velocity; 
                const speed = Math.sqrt(vel.x*vel.x + vel.z*vel.z);
                if(speed > 0.5) player.mesh.rotation.y = Math.atan2(vel.x, vel.z); 
                
                const armL = player.mesh.getObjectByName('armL'); 
                const armR = player.mesh.getObjectByName('armR');
                const legL = player.mesh.getObjectByName('legL'); 
                const legR = player.mesh.getObjectByName('legR');
                
                if(speed > 1 && player.body.position.y > -10) {
                    const runTime = Date.now() * 0.015;
                    if(armL) armL.rotation.x = Math.sin(runTime) * 0.8; 
                    if(armR) armR.rotation.x = -Math.sin(runTime) * 0.8;
                    if(legL) legL.rotation.x = -Math.sin(runTime) * 0.8; 
                    if(legR) legR.rotation.x = Math.sin(runTime) * 0.8;
                } else {
                    if(armL) armL.rotation.x = 0; if(armR) armR.rotation.x = 0; 
                    if(legL) legL.rotation.x = 0; if(legR) legR.rotation.x = 0;
                }
            }
        }

        function checkFinish() {
            if(!hasFinished && playerBody.position.x > finishLineX) {
                hasFinished = true; 
                window.hasFinished = true; 
                playSoundEffect('finish');
                showEndScreen(); 
                updateCommentary('finish');
            }
            
            let myX = playerBody.position.x; 
            let countAhead = 0;
            for(const uid in window.opponentsData) { 
                if(window.opponentsData[uid].x > myX) countAhead++; 
            }
            document.getElementById('rank').innerText = `Rank: ${countAhead + 1}`;
        }

        function showEndScreen() {
            window.gameActive = false; 
            gameActive = false;
            document.exitPointerLock();
            
            const winScreen = document.getElementById('win-screen');
            const leaderboardDiv = document.getElementById('final-leaderboard');
            const controlsDiv = document.getElementById('end-screen-controls');
            
            leaderboardDiv.innerHTML = ''; 
            controlsDiv.innerHTML = '';
            
            let allPlayers = [];
            if (window.playerBody) allPlayers.push({ 
                username: myUsername + " (You)", 
                x: window.playerBody.position.x, 
                finished: window.hasFinished, 
                isLocal: true 
            });
            
            for (const uid in window.opponentsData) {
                const p = window.opponentsData[uid]; 
                if(uid === myId) continue;
                allPlayers.push({ 
                    username: p.username, 
                    x: p.x, 
                    finished: p.finished, 
                    isLocal: false 
                });
            }
            
            allPlayers.sort((a, b) => { 
                if (a.finished && !b.finished) return -1; 
                if (!a.finished && b.finished) return 1; 
                return b.x - a.x; 
            });
            
            allPlayers.forEach((p, index) => {
                const row = document.createElement('div'); 
                row.className = 'leaderboard-row';
                row.style.color = p.isLocal ? '#ffff00' : 'white'; 
                row.style.fontWeight = p.isLocal ? 'bold' : 'normal';
                const status = p.finished ? '<span style="color:#44cc44">FINISHED</span>' : Math.floor(p.x) + 'm';
                row.innerHTML = `<span>#${index+1} ${p.username}</span><span>${status}</span>`;
                leaderboardDiv.appendChild(row);
            });
            
            const menuBtn = document.createElement('button'); 
            menuBtn.innerText = "BACK TO MENU"; 
            menuBtn.onclick = window.backToMenu; 
            menuBtn.style.marginRight = "10px"; 
            controlsDiv.appendChild(menuBtn);
            
            if (isHost) {
                const nextBtn = document.createElement('button'); 
                nextBtn.innerText = "START NEXT LEVEL"; 
                nextBtn.style.backgroundColor = "#00ffff"; 
                nextBtn.style.color = "#000"; 
                nextBtn.onclick = window.hostStartGame; 
                controlsDiv.appendChild(nextBtn);
            } else {
                const waitText = document.createElement('p'); 
                waitText.innerText = "Waiting for host to start next level..."; 
                waitText.style.fontSize = "0.9em"; 
                waitText.style.color = "#aaa"; 
                waitText.style.marginTop = "10px"; 
                controlsDiv.appendChild(waitText);
            }
            
            winScreen.style.display = 'block';
        }

        function animate() {
            requestAnimationFrame(animate); 
            
            // Fixed timestep accumulator for consistent physics across all refresh rates
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastFrameTime) / 1000; // Convert to seconds
            lastFrameTime = currentTime;
            
            // Cap delta time to prevent spiral of death
            const clampedDelta = Math.min(deltaTime, 0.1);
            accumulator += clampedDelta;
            
            // Update physics in fixed timesteps
            while (accumulator >= fixedTimeStep) {
                updatePhysics();
                accumulator -= fixedTimeStep;
            }
            
            if(playerBody) {
                const targetPos = playerBody.position; 
                const radius = 14; 
                const camHeight = 10;
                const camX = targetPos.x - radius * Math.cos(cameraAngle); 
                const camZ = targetPos.z - radius * Math.sin(cameraAngle);
                camera.position.lerp(new THREE.Vector3(camX, targetPos.y + camHeight, camZ), 0.1);
                camera.lookAt(targetPos.x, targetPos.y + 2, targetPos.z);
            }
            
            // Make name sprites face camera
            if (playerMesh) {
                const nameSprite = playerMesh.getObjectByName('nameSprite');
                if (nameSprite) nameSprite.lookAt(camera.position);
            }
            for (const uid in opponents) {
                const nameSprite = opponents[uid].mesh.getObjectByName('nameSprite');
                if (nameSprite) nameSprite.lookAt(camera.position);
            }
            
            if (backgroundObjects.length > 0) backgroundObjects[0].position.copy(camera.position);
            renderer.render(scene, camera);
        }

        window.addEventListener('load', () => { init(); });
    </script>
</body>
</html>
